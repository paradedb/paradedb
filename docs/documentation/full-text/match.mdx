---
title: Match
---

Match queries are the go-to query type for text search in ParadeDB and use the `|||` match operator. `|||` means "find all documents that contain one or more of the terms tokenized from this text input." To understand what this looks like in practice, let's consider the following query:

```sql
SELECT description, rating, category
FROM mock_items
WHERE description ||| 'running shoes';
```

This query returns:

```csv
     description     | rating | category
---------------------+--------+----------
 Sleek running shoes |      5 | Footwear
 White jogging shoes |      3 | Footwear
 Generic shoes       |      4 | Footwear
(3 rows)
```

To see why, let's look at what the `|||` operator does:

1. Retrieves the [tokenizer configuration](/documentation/indexing/tokenizers) of the `description` column. In this example,
   let's assume `description` uses the [default](/documentation/indexing/tokenizers#default) tokenizer, which splits on whitespace
   and punctuation.
2. Tokenizes the query string with the same tokenizer. This means `running shoes` becomes two tokens: `running` and `shoes`.
3. Finds all rows where `description` contains **any one** of the tokens, `running` or `shoes`.

This is why all results have either `running` or `shoes` tokens in `description`.

## Match Conjunction

Suppose we want to find rows that contain both `running` AND `shoes` tokens. This is where the `&&&` match conjunction operator comes in.
`&&&` means "find all documents that contain all terms tokenized from this text input."

```sql
SELECT description, rating, category
FROM mock_items
WHERE description &&& 'running shoes';
```

This query returns:

```csv
     description     | rating | category
---------------------+--------+----------
 Sleek running shoes |      5 | Footwear
(1 row)
```

Note that `White jogging shoes` and `Generic shoes` are no longer returned because they do not have the token `running`.

## Case Sensitivity

Suppose we want to find rows regardless of upper/lowercasing. This is where the
[lowercase filter](/documentation/indexing/token_filters#lowercase) comes in. By default, lowercasing is enabled, which means
that match queries are case-insensitive.

```sql
INSERT INTO mock_items (description, rating, category) VALUES
('SLEEK RUNNING SHOES', 5, 'Footwear'),
('sleeK rUnNing ShOes', 5, 'Footwear');

SELECT description, rating, category
FROM mock_items
WHERE description &&& 'running shoes';
```

This query returns:

```csv
     description     | rating | category
---------------------+--------+----------
 Sleek running shoes |      5 | Footwear
 SLEEK RUNNING SHOES |      5 | Footwear
 sleeK rUnNing ShOes |      5 | Footwear
(3 rows)
```

## Stemming

Suppose we want to match documents based on the root form of a word. For instance, matching the query `run shoe` to `running shoes`.
This can be achieved by configuring the [English stemmer](/documentation/indexing/stemming) (not enabled by default).

## Fuzzy Matching
