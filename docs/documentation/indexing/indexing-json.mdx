---
title: Indexing JSON
description: Add JSON and JSONB types to the index
canonical: https://docs.paradedb.com/documentation/indexing/indexing-json
---

When indexing JSON, ParadeDB automatically indexes all sub-fields of the JSON object. The type of each sub-field is also inferred automatically.
For example, consider the following statement where `metadata` is `JSONB`:

<CodeGroup>
```sql SQL
CREATE INDEX search_idx ON mock_items
USING bm25 (id, metadata)
WITH (key_field='id');
```

```python Django
from django.db import models
from paradedb.indexes import BM25Index

class MockItem(models.Model):
    metadata = models.JSONField()

    class Meta:
        indexes = [
            BM25Index(
                fields={
                    'id': {},
                    'metadata': {},
                },
                key_field='id',
                name='search_idx',
            ),
        ]
```

```ruby Rails
class MockItemIndex < ParadeDB::Index
  self.table_name = :mock_items
  self.key_field = :id
  self.index_name = :search_idx
  self.fields = {
    id: {},
    metadata: {}
  }
end
```

</CodeGroup>

A single `metadata` JSON may look like:

```json
{ "color": "Silver", "location": "United States" }
```

ParadeDB will automatically index both `metadata.color` and `metadata.location` as text.

By default, all text sub-fields of a JSON object use the same tokenizer. The tokenizer can be configured the same way as text fields:

<CodeGroup>
```sql SQL
CREATE INDEX search_idx ON mock_items
USING bm25 (id, (metadata::pdb.ngram(2,3)))
WITH (key_field='id');
```

```python Django
from django.db import models
from paradedb.indexes import BM25Index

class MockItem(models.Model):
    metadata = models.JSONField()

    class Meta:
        indexes = [
            BM25Index(
                fields={
                    'id': {},
                    'metadata': {'tokenizer': 'ngram', 'args': [2, 3]},
                },
                key_field='id',
                name='search_idx',
            ),
        ]
```

```ruby Rails
class MockItemIndex < ParadeDB::Index
  self.table_name = :mock_items
  self.key_field = :id
  self.index_name = :search_idx
  self.fields = {
    id: {},
    metadata: { tokenizer: :ngram, args: [2, 3] }
  }
end
```

</CodeGroup>

Instead of indexing the entire JSON, sub-fields of the JSON can be indexed individually. This allows for configuring separate tokenizers
within a larger JSON:

<CodeGroup>
```sql SQL
CREATE INDEX search_idx ON mock_items
USING bm25 (id, ((metadata->>'color')::pdb.ngram(2,3)))
WITH (key_field='id');
```

```python Django
from django.db import models
from paradedb.indexes import BM25Index

class MockItem(models.Model):
    metadata = models.JSONField()

    class Meta:
        indexes = [
            BM25Index(
                fields={
                    'id': {},
                    'metadata': {
                        'json_keys': {
                            'color': {'tokenizer': 'ngram', 'args': [2, 3]},
                        },
                    },
                },
                key_field='id',
                name='search_idx',
            ),
        ]
```

```ruby Rails
class MockItemIndex < ParadeDB::Index
  self.table_name = :mock_items
  self.key_field = :id
  self.index_name = :search_idx
  self.fields = {
    id: {},
    "metadata->>'color'" => { tokenizer: :ngram, args: [2, 3], alias: "metadata_color" }
  }
end
```

</CodeGroup>
