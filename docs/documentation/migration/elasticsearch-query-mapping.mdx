---
title: Elasticsearch Query Mapping
description: Side-by-side reference translating Elasticsearch DSL queries to ParadeDB SQL
canonical: https://docs.paradedb.com/documentation/migration/elasticsearch-query-mapping
---

This guide provides a comprehensive mapping from Elasticsearch Query DSL to ParadeDB SQL. Each section includes
side-by-side examples showing the Elasticsearch JSON and the equivalent ParadeDB SQL.

All examples assume a table and BM25 index created as follows:

```sql
CREATE TABLE products (
  id SERIAL PRIMARY KEY,
  description TEXT,
  category TEXT,
  rating INT,
  price NUMERIC,
  created_at TIMESTAMP
);

CREATE INDEX search_idx ON products
USING bm25 (id, description, (category::pdb.literal), rating, price, created_at)
WITH (key_field = 'id');
```

<Accordion title="Sample data">
  ```sql INSERT INTO products (description, category, rating, price, created_at)
  VALUES ('Sleek running shoes for athletes', 'footwear', 5, 89.99,
  '2025-01-15'), ('Cheap running shoes on sale', 'footwear', 3, 29.99,
  '2025-02-20'), ('Premium leather boots', 'footwear', 4, 149.99, '2025-03-10'),
  ('Wireless bluetooth headphones', 'electronics', 4, 59.99, '2025-04-05'),
  ('Ergonomic mechanical keyboard', 'electronics', 5, 129.99, '2025-05-12'),
  ('Cotton running shorts', 'apparel', 4, 34.99, '2025-06-01'), ('Waterproof
  hiking jacket', 'apparel', 5, 199.99, '2025-07-18'), ('Stainless steel water
  bottle', 'accessories', 4, 24.99, '2025-08-22'), ('Yoga mat with carrying
  strap', 'fitness', 3, 39.99, '2025-09-30'), ('Digital fitness tracker watch',
  'electronics', 4, 79.99, '2025-10-14'); ```
</Accordion>

## Full-Text Queries

### match

The Elasticsearch `match` query tokenizes the input and searches for any matching token. The `operator` parameter
controls whether tokens are combined with OR (default) or AND.

**OR (default)**

```json Elasticsearch
{
  "query": {
    "match": {
      "description": {
        "query": "running shoes"
      }
    }
  }
}
```

```sql ParadeDB
SELECT * FROM products
WHERE description ||| 'running shoes';
```

<Accordion title="Result">
  ``` id | description | category | rating | price | created_at
  ----+----------------------------------+----------+--------+-------+--------------------------
  1 | Sleek running shoes for athletes | footwear | 5 | 89.99 | Wed Jan 15
  00:00:00 2025 2 | Cheap running shoes on sale | footwear | 3 | 29.99 | Thu Feb
  20 00:00:00 2025 6 | Cotton running shorts | apparel | 4 | 34.99 | Sun Jun 01
  00:00:00 2025 (3 rows) ```
</Accordion>

The [`|||` operator](/documentation/full-text/match) performs a match disjunction — it matches documents containing **any** of the query tokens.

**AND**

```json Elasticsearch
{
  "query": {
    "match": {
      "description": {
        "query": "running shoes",
        "operator": "and"
      }
    }
  }
}
```

```sql ParadeDB
SELECT * FROM products
WHERE description &&& 'running shoes';
```

<Accordion title="Result">
  ``` id | description | category | rating | price | created_at
  ----+----------------------------------+----------+--------+-------+--------------------------
  1 | Sleek running shoes for athletes | footwear | 5 | 89.99 | Wed Jan 15
  00:00:00 2025 2 | Cheap running shoes on sale | footwear | 3 | 29.99 | Thu Feb
  20 00:00:00 2025 (2 rows) ```
</Accordion>

The [`&&&` operator](/documentation/full-text/match) performs a match conjunction — it matches documents containing **all** of the query tokens.

### match with fuzziness

```json Elasticsearch
{
  "query": {
    "match": {
      "description": {
        "query": "runing shose",
        "fuzziness": 2
      }
    }
  }
}
```

```sql ParadeDB
SELECT * FROM products
WHERE description ||| 'runing shose'::pdb.fuzzy(2);
```

<Accordion title="Result">
  ``` id | description | category | rating | price | created_at
  ----+----------------------------------+----------+--------+-------+--------------------------
  1 | Sleek running shoes for athletes | footwear | 5 | 89.99 | Wed Jan 15
  00:00:00 2025 2 | Cheap running shoes on sale | footwear | 3 | 29.99 | Thu Feb
  20 00:00:00 2025 6 | Cotton running shorts | apparel | 4 | 34.99 | Sun Jun 01
  00:00:00 2025 (3 rows) ```
</Accordion>

See [Fuzzy](/documentation/full-text/fuzzy) for details on edit distance and prefix matching.

### match_phrase

```json Elasticsearch
{
  "query": {
    "match_phrase": {
      "description": "running shoes"
    }
  }
}
```

```sql ParadeDB
SELECT * FROM products
WHERE description ### 'running shoes';
```

<Accordion title="Result">
  ``` id | description | category | rating | price | created_at
  ----+----------------------------------+----------+--------+-------+--------------------------
  1 | Sleek running shoes for athletes | footwear | 5 | 89.99 | Wed Jan 15
  00:00:00 2025 2 | Cheap running shoes on sale | footwear | 3 | 29.99 | Thu Feb
  20 00:00:00 2025 (2 rows) ```
</Accordion>

The [`###` operator](/documentation/full-text/phrase) matches documents where the tokens appear in the exact order specified.

### match_phrase_prefix

```json Elasticsearch
{
  "query": {
    "match_phrase_prefix": {
      "description": "running sh"
    }
  }
}
```

```sql ParadeDB
SELECT * FROM products
WHERE description @@@ pdb.phrase_prefix(ARRAY['running', 'sh']);
```

<Accordion title="Result">
  ``` id | description | category | rating | price | created_at
  ----+----------------------------------+----------+--------+-------+--------------------------
  1 | Sleek running shoes for athletes | footwear | 5 | 89.99 | Wed Jan 15
  00:00:00 2025 2 | Cheap running shoes on sale | footwear | 3 | 29.99 | Thu Feb
  20 00:00:00 2025 6 | Cotton running shorts | apparel | 4 | 34.99 | Sun Jun 01
  00:00:00 2025 (3 rows) ```
</Accordion>

See [Phrase Prefix](/documentation/query-builder/phrase/phrase-prefix) for additional options like `max_expansions`.

### multi_match

```json Elasticsearch
{
  "query": {
    "multi_match": {
      "query": "running shoes",
      "fields": ["description", "category"]
    }
  }
}
```

```sql ParadeDB
SELECT * FROM products
WHERE description ||| 'running shoes' OR category ||| 'running shoes';
```

<Accordion title="Result">
  ``` id | description | category | rating | price | created_at
  ----+----------------------------------+----------+--------+-------+--------------------------
  1 | Sleek running shoes for athletes | footwear | 5 | 89.99 | Wed Jan 15
  00:00:00 2025 2 | Cheap running shoes on sale | footwear | 3 | 29.99 | Thu Feb
  20 00:00:00 2025 6 | Cotton running shorts | apparel | 4 | 34.99 | Sun Jun 01
  00:00:00 2025 (3 rows) ```
</Accordion>

For `type: "best_fields"` with a tie breaker, use [`paradedb.disjunction_max`](/documentation/query-builder/overview):

```sql ParadeDB
SELECT * FROM products
WHERE id @@@ paradedb.disjunction_max(
  disjuncts => ARRAY[
    paradedb.match('description', 'running shoes'),
    paradedb.match('category', 'running shoes')
  ],
  tie_breaker => 0.3
);
```

<Accordion title="Result">
  ``` id | description | category | rating | price | created_at
  ----+----------------------------------+----------+--------+-------+--------------------------
  1 | Sleek running shoes for athletes | footwear | 5 | 89.99 | Wed Jan 15
  00:00:00 2025 2 | Cheap running shoes on sale | footwear | 3 | 29.99 | Thu Feb
  20 00:00:00 2025 6 | Cotton running shorts | apparel | 4 | 34.99 | Sun Jun 01
  00:00:00 2025 (3 rows) ```
</Accordion>

### query_string

```json Elasticsearch
{
  "query": {
    "query_string": {
      "query": "running AND shoes",
      "default_field": "description"
    }
  }
}
```

```sql ParadeDB
SELECT * FROM products
WHERE description @@@ pdb.parse('running AND shoes');
```

<Accordion title="Result">
  ``` id | description | category | rating | price | created_at
  ----+----------------------------------+----------+--------+-------+--------------------------
  1 | Sleek running shoes for athletes | footwear | 5 | 89.99 | Wed Jan 15
  00:00:00 2025 2 | Cheap running shoes on sale | footwear | 3 | 29.99 | Thu Feb
  20 00:00:00 2025 (2 rows) ```
</Accordion>

The [`pdb.parse`](/documentation/query-builder/compound/query-parser) function supports Lucene-style query syntax including `AND`, `OR`, `NOT`, field references, and grouping.

## Term-Level Queries

### term

```json Elasticsearch
{
  "query": {
    "term": {
      "category": "electronics"
    }
  }
}
```

```sql ParadeDB
SELECT * FROM products
WHERE category === 'electronics';
```

<Accordion title="Result">
  ``` id | description | category | rating | price | created_at
  ----+-------------------------------+-------------+--------+--------+--------------------------
  4 | Wireless bluetooth headphones | electronics | 4 | 59.99 | Sat Apr 05
  00:00:00 2025 5 | Ergonomic mechanical keyboard | electronics | 5 | 129.99 |
  Mon May 12 00:00:00 2025 10 | Digital fitness tracker watch | electronics | 4
  | 79.99 | Tue Oct 14 00:00:00 2025 (3 rows) ```
</Accordion>

The [`===` operator](/documentation/full-text/term) performs an exact token match without tokenization of the query string.

### terms

```json Elasticsearch
{
  "query": {
    "terms": {
      "category": ["electronics", "footwear"]
    }
  }
}
```

```sql ParadeDB
SELECT * FROM products
WHERE category === 'electronics' OR category === 'footwear';
```

<Accordion title="Result">
  ``` id | description | category | rating | price | created_at
  ----+----------------------------------+-------------+--------+--------+--------------------------
  1 | Sleek running shoes for athletes | footwear | 5 | 89.99 | Wed Jan 15
  00:00:00 2025 2 | Cheap running shoes on sale | footwear | 3 | 29.99 | Thu Feb
  20 00:00:00 2025 3 | Premium leather boots | footwear | 4 | 149.99 | Mon Mar
  10 00:00:00 2025 4 | Wireless bluetooth headphones | electronics | 4 | 59.99 |
  Sat Apr 05 00:00:00 2025 5 | Ergonomic mechanical keyboard | electronics | 5 |
  129.99 | Mon May 12 00:00:00 2025 10 | Digital fitness tracker watch |
  electronics | 4 | 79.99 | Tue Oct 14 00:00:00 2025 (6 rows) ```
</Accordion>

### range

```json Elasticsearch
{
  "query": {
    "range": {
      "price": {
        "gte": 10,
        "lte": 100
      }
    }
  }
}
```

```sql ParadeDB
SELECT * FROM products
WHERE price >= 10 AND price <= 100;
```

<Accordion title="Result">
  ``` id | description | category | rating | price | created_at
  ----+----------------------------------+-------------+--------+-------+--------------------------
  1 | Sleek running shoes for athletes | footwear | 5 | 89.99 | Wed Jan 15
  00:00:00 2025 2 | Cheap running shoes on sale | footwear | 3 | 29.99 | Thu Feb
  20 00:00:00 2025 4 | Wireless bluetooth headphones | electronics | 4 | 59.99 |
  Sat Apr 05 00:00:00 2025 6 | Cotton running shorts | apparel | 4 | 34.99 | Sun
  Jun 01 00:00:00 2025 8 | Stainless steel water bottle | accessories | 4 |
  24.99 | Fri Aug 22 00:00:00 2025 9 | Yoga mat with carrying strap | fitness |
  3 | 39.99 | Tue Sep 30 00:00:00 2025 10 | Digital fitness tracker watch |
  electronics | 4 | 79.99 | Tue Oct 14 00:00:00 2025 (7 rows) ```
</Accordion>

When `price` is part of the BM25 index, this filter is automatically pushed down into the index scan. See [Filtering](/documentation/filtering) for details.

<Note>
  If your table uses Postgres [range
  types](https://www.postgresql.org/docs/current/rangetypes.html) (e.g.,
  `int4range`), you can use
  [`pdb.range_term`](/documentation/query-builder/term/range-term) for
  index-accelerated range containment, overlap, and intersection queries.
</Note>

### exists

```json Elasticsearch
{
  "query": {
    "exists": {
      "field": "description"
    }
  }
}
```

```sql ParadeDB
-- For non-text fields or text fields with the literal tokenizer
SELECT * FROM products
WHERE rating @@@ pdb.exists();

-- For text fields with the default tokenizer, use SQL instead
SELECT * FROM products
WHERE description IS NOT NULL;
```

<Accordion title="Result">
  ``` id | description | category | rating | price | created_at
  ----+----------------------------------+-------------+--------+--------+--------------------------
  1 | Sleek running shoes for athletes | footwear | 5 | 89.99 | Wed Jan 15
  00:00:00 2025 2 | Cheap running shoes on sale | footwear | 3 | 29.99 | Thu Feb
  20 00:00:00 2025 3 | Premium leather boots | footwear | 4 | 149.99 | Mon Mar
  10 00:00:00 2025 4 | Wireless bluetooth headphones | electronics | 4 | 59.99 |
  Sat Apr 05 00:00:00 2025 5 | Ergonomic mechanical keyboard | electronics | 5 |
  129.99 | Mon May 12 00:00:00 2025 6 | Cotton running shorts | apparel | 4 |
  34.99 | Sun Jun 01 00:00:00 2025 7 | Waterproof hiking jacket | apparel | 5 |
  199.99 | Fri Jul 18 00:00:00 2025 8 | Stainless steel water bottle |
  accessories | 4 | 24.99 | Fri Aug 22 00:00:00 2025 9 | Yoga mat with carrying
  strap | fitness | 3 | 39.99 | Tue Sep 30 00:00:00 2025 10 | Digital fitness
  tracker watch | electronics | 4 | 79.99 | Tue Oct 14 00:00:00 2025 (10 rows)
  ```
</Accordion>

See [Exists](/documentation/query-builder/term/exists).

<Note>
  `pdb.exists()` requires text fields to use the
  [literal](/documentation/tokenizers/available-tokenizers/literal) tokenizer.
  For text fields with other tokenizers, use `IS NOT NULL` instead.
</Note>

### fuzzy

```json Elasticsearch
{
  "query": {
    "fuzzy": {
      "description": {
        "value": "shose",
        "fuzziness": 2
      }
    }
  }
}
```

```sql ParadeDB
SELECT * FROM products
WHERE description === 'shose'::pdb.fuzzy(2);
```

<Accordion title="Result">
  ``` id | description | category | rating | price | created_at
  ----+----------------------------------+----------+--------+-------+--------------------------
  1 | Sleek running shoes for athletes | footwear | 5 | 89.99 | Wed Jan 15
  00:00:00 2025 2 | Cheap running shoes on sale | footwear | 3 | 29.99 | Thu Feb
  20 00:00:00 2025 (2 rows) ```
</Accordion>

See [Fuzzy](/documentation/full-text/fuzzy) for details on edit distance, prefix matching, and transposition cost.

### prefix

```json Elasticsearch
{
  "query": {
    "prefix": {
      "description": "runn"
    }
  }
}
```

```sql ParadeDB
SELECT * FROM products
WHERE description === 'runn'::pdb.fuzzy(0, t);
```

<Accordion title="Result">
  ``` id | description | category | rating | price | created_at
  ----+----------------------------------+----------+--------+-------+--------------------------
  1 | Sleek running shoes for athletes | footwear | 5 | 89.99 | Wed Jan 15
  00:00:00 2025 2 | Cheap running shoes on sale | footwear | 3 | 29.99 | Thu Feb
  20 00:00:00 2025 6 | Cotton running shorts | apparel | 4 | 34.99 | Sun Jun 01
  00:00:00 2025 (3 rows) ```
</Accordion>

Setting `fuzzy(0, t)` enables prefix matching with zero edit distance. See [Fuzzy Prefix](/documentation/full-text/fuzzy#fuzzy-prefix).

### regexp

```json Elasticsearch
{
  "query": {
    "regexp": {
      "description": "run.*ing"
    }
  }
}
```

```sql ParadeDB
SELECT * FROM products
WHERE description @@@ pdb.regex('run.*ing');
```

<Accordion title="Result">
  ``` id | description | category | rating | price | created_at
  ----+----------------------------------+----------+--------+-------+--------------------------
  1 | Sleek running shoes for athletes | footwear | 5 | 89.99 | Wed Jan 15
  00:00:00 2025 2 | Cheap running shoes on sale | footwear | 3 | 29.99 | Thu Feb
  20 00:00:00 2025 6 | Cotton running shorts | apparel | 4 | 34.99 | Sun Jun 01
  00:00:00 2025 (3 rows) ```
</Accordion>

See [Regex](/documentation/query-builder/term/regex).

### wildcard

```json Elasticsearch
{
  "query": {
    "wildcard": {
      "description": "run*"
    }
  }
}
```

```sql ParadeDB
SELECT * FROM products
WHERE description @@@ pdb.regex('run.*');
```

<Accordion title="Result">
  ``` id | description | category | rating | price | created_at
  ----+----------------------------------+----------+--------+-------+--------------------------
  1 | Sleek running shoes for athletes | footwear | 5 | 89.99 | Wed Jan 15
  00:00:00 2025 2 | Cheap running shoes on sale | footwear | 3 | 29.99 | Thu Feb
  20 00:00:00 2025 6 | Cotton running shorts | apparel | 4 | 34.99 | Sun Jun 01
  00:00:00 2025 (3 rows) ```
</Accordion>

<Note>
  Elasticsearch wildcard patterns use `*` (any characters) and `?` (single
  character). Translate these to regex: `*` becomes `.*` and `?` becomes `.`.
</Note>

### ids

```json Elasticsearch
{
  "query": {
    "ids": {
      "values": [1, 2, 3]
    }
  }
}
```

```sql ParadeDB
SELECT * FROM products
WHERE id IN (1, 2, 3);
```

<Accordion title="Result">
  ``` id | description | category | rating | price | created_at
  ----+----------------------------------+----------+--------+--------+--------------------------
  1 | Sleek running shoes for athletes | footwear | 5 | 89.99 | Wed Jan 15
  00:00:00 2025 2 | Cheap running shoes on sale | footwear | 3 | 29.99 | Thu Feb
  20 00:00:00 2025 3 | Premium leather boots | footwear | 4 | 149.99 | Mon Mar
  10 00:00:00 2025 (3 rows) ```
</Accordion>

## Compound Queries

### bool

The Elasticsearch `bool` query maps directly to SQL boolean logic.

```json Elasticsearch
{
  "query": {
    "bool": {
      "must": [{ "match": { "description": "shoes" } }],
      "should": [{ "term": { "category": "footwear" } }],
      "must_not": [{ "range": { "price": { "gte": 100 } } }],
      "filter": [{ "term": { "rating": 5 } }]
    }
  }
}
```

```sql ParadeDB
SELECT * FROM products
WHERE description ||| 'shoes'            -- must
  AND (category === 'footwear' OR TRUE)   -- should (at least one should match)
  AND NOT (price >= 100)                  -- must_not
  AND rating = 5;                         -- filter
```

<Accordion title="Result">
  ``` id | description | category | rating | price | created_at
  ----+----------------------------------+----------+--------+-------+--------------------------
  1 | Sleek running shoes for athletes | footwear | 5 | 89.99 | Wed Jan 15
  00:00:00 2025 (1 row) ```
</Accordion>

For full control over `must`, `should`, and `must_not` clauses with proper scoring behavior, use [`paradedb.boolean`](/documentation/query-builder/overview):

```sql ParadeDB
SELECT * FROM products
WHERE id @@@ paradedb.boolean(
  must => ARRAY[paradedb.match('description', 'shoes')],
  should => ARRAY[paradedb.term('category', 'footwear')]
)
AND NOT (price >= 100)
AND rating = 5;
```

<Accordion title="Result">
  ``` id | description | category | rating | price | created_at
  ----+----------------------------------+----------+--------+-------+--------------------------
  1 | Sleek running shoes for athletes | footwear | 5 | 89.99 | Wed Jan 15
  00:00:00 2025 (1 row) ```
</Accordion>

| `bool` clause | ParadeDB equivalent                              | Scoring                                                     |
| ------------- | ------------------------------------------------ | ----------------------------------------------------------- |
| `must`        | `AND` or `paradedb.boolean(must => ...)`         | Contributes to score                                        |
| `should`      | `OR` or `paradedb.boolean(should => ...)`        | Contributes to score                                        |
| `must_not`    | `AND NOT` or `paradedb.boolean(must_not => ...)` | No score contribution                                       |
| `filter`      | `AND` with non-text conditions                   | No score contribution (use SQL `WHERE` for filter pushdown) |

### boosting

```json Elasticsearch
{
  "query": {
    "boosting": {
      "positive": { "match": { "description": "shoes" } },
      "negative": { "match": { "description": "cheap" } },
      "negative_boost": 0.5
    }
  }
}
```

```sql ParadeDB
SELECT * FROM products
WHERE id @@@ paradedb.boolean(
  must => ARRAY[paradedb.match('description', 'shoes')],
  should => ARRAY[paradedb.boost(-0.5, paradedb.match('description', 'cheap'))]
);
```

<Accordion title="Result">
  ``` id | description | category | rating | price | created_at
  ----+----------------------------------+----------+--------+-------+--------------------------
  1 | Sleek running shoes for athletes | footwear | 5 | 89.99 | Wed Jan 15
  00:00:00 2025 2 | Cheap running shoes on sale | footwear | 3 | 29.99 | Thu Feb
  20 00:00:00 2025 (2 rows) ```
</Accordion>

See [Boost](/documentation/sorting/boost) for details on the `pdb.boost()` type cast.

### constant_score

```json Elasticsearch
{
  "query": {
    "constant_score": {
      "filter": { "term": { "category": "electronics" } },
      "boost": 1.5
    }
  }
}
```

```sql ParadeDB
SELECT * FROM products
WHERE id @@@ paradedb.const_score(
  score => 1.5,
  query => paradedb.term('category', 'electronics')
);
```

<Accordion title="Result">
  ``` id | description | category | rating | price | created_at
  ----+-------------------------------+-------------+--------+--------+--------------------------
  4 | Wireless bluetooth headphones | electronics | 4 | 59.99 | Sat Apr 05
  00:00:00 2025 5 | Ergonomic mechanical keyboard | electronics | 5 | 129.99 |
  Mon May 12 00:00:00 2025 10 | Digital fitness tracker watch | electronics | 4
  | 79.99 | Tue Oct 14 00:00:00 2025 (3 rows) ```
</Accordion>

### dis_max

```json Elasticsearch
{
  "query": {
    "dis_max": {
      "queries": [
        { "match": { "description": "shoes" } },
        { "match": { "category": "footwear" } }
      ],
      "tie_breaker": 0.5
    }
  }
}
```

```sql ParadeDB
SELECT * FROM products
WHERE id @@@ paradedb.disjunction_max(
  disjuncts => ARRAY[
    paradedb.match('description', 'shoes'),
    paradedb.term('category', 'footwear')
  ],
  tie_breaker => 0.5
);
```

<Accordion title="Result">
  ``` id | description | category | rating | price | created_at
  ----+----------------------------------+----------+--------+--------+--------------------------
  1 | Sleek running shoes for athletes | footwear | 5 | 89.99 | Wed Jan 15
  00:00:00 2025 2 | Cheap running shoes on sale | footwear | 3 | 29.99 | Thu Feb
  20 00:00:00 2025 3 | Premium leather boots | footwear | 4 | 149.99 | Mon Mar
  10 00:00:00 2025 (3 rows) ```
</Accordion>

## Specialized Queries

### more_like_this

```json Elasticsearch
{
  "query": {
    "more_like_this": {
      "fields": ["description"],
      "like": [{ "_id": "1" }],
      "min_term_freq": 1,
      "min_doc_freq": 1
    }
  }
}
```

```sql ParadeDB
SELECT * FROM products
WHERE id @@@ pdb.more_like_this(1, ARRAY['description']);
```

<Accordion title="Result">
  ``` id | description | category | rating | price | created_at
  ----+----------------------------------+----------+--------+-------+--------------------------
  1 | Sleek running shoes for athletes | footwear | 5 | 89.99 | Wed Jan 15
  00:00:00 2025 2 | Cheap running shoes on sale | footwear | 3 | 29.99 | Thu Feb
  20 00:00:00 2025 6 | Cotton running shorts | apparel | 4 | 34.99 | Sun Jun 01
  00:00:00 2025 (3 rows) ```
</Accordion>

See [More Like This](/documentation/query-builder/specialized/more-like-this).

### Proximity (span_near)

```json Elasticsearch
{
  "query": {
    "span_near": {
      "clauses": [
        { "span_term": { "description": "running" } },
        { "span_term": { "description": "shoes" } }
      ],
      "slop": 3,
      "in_order": false
    }
  }
}
```

```sql ParadeDB
-- Unordered proximity (terms within 3 tokens of each other)
SELECT * FROM products
WHERE description @@@ ('running' ##3## 'shoes');
```

<Accordion title="Result">
  ``` id | description | category | rating | price | created_at
  ----+----------------------------------+----------+--------+-------+--------------------------
  1 | Sleek running shoes for athletes | footwear | 5 | 89.99 | Wed Jan 15
  00:00:00 2025 2 | Cheap running shoes on sale | footwear | 3 | 29.99 | Thu Feb
  20 00:00:00 2025 (2 rows) ```
</Accordion>

For ordered proximity (`in_order: true`):

```sql ParadeDB
-- Ordered proximity (terms must appear in order, within 3 tokens)
SELECT * FROM products
WHERE description @@@ ('running' ##> 3 ##> 'shoes');
```

<Accordion title="Result">
  ``` id | description | category | rating | price | created_at
  ----+----------------------------------+----------+--------+-------+--------------------------
  1 | Sleek running shoes for athletes | footwear | 5 | 89.99 | Wed Jan 15
  00:00:00 2025 2 | Cheap running shoes on sale | footwear | 3 | 29.99 | Thu Feb
  20 00:00:00 2025 (2 rows) ```
</Accordion>

See [Proximity](/documentation/full-text/proximity).

### match_all

```json Elasticsearch
{
  "query": { "match_all": {} }
}
```

```sql ParadeDB
SELECT * FROM products
WHERE id @@@ pdb.all();
```

<Accordion title="Result">
  ``` id | description | category | rating | price | created_at
  ----+----------------------------------+-------------+--------+--------+--------------------------
  1 | Sleek running shoes for athletes | footwear | 5 | 89.99 | Wed Jan 15
  00:00:00 2025 2 | Cheap running shoes on sale | footwear | 3 | 29.99 | Thu Feb
  20 00:00:00 2025 3 | Premium leather boots | footwear | 4 | 149.99 | Mon Mar
  10 00:00:00 2025 4 | Wireless bluetooth headphones | electronics | 4 | 59.99 |
  Sat Apr 05 00:00:00 2025 5 | Ergonomic mechanical keyboard | electronics | 5 |
  129.99 | Mon May 12 00:00:00 2025 6 | Cotton running shorts | apparel | 4 |
  34.99 | Sun Jun 01 00:00:00 2025 7 | Waterproof hiking jacket | apparel | 5 |
  199.99 | Fri Jul 18 00:00:00 2025 8 | Stainless steel water bottle |
  accessories | 4 | 24.99 | Fri Aug 22 00:00:00 2025 9 | Yoga mat with carrying
  strap | fitness | 3 | 39.99 | Tue Sep 30 00:00:00 2025 10 | Digital fitness
  tracker watch | electronics | 4 | 79.99 | Tue Oct 14 00:00:00 2025 (10 rows)
  ```
</Accordion>

See [All](/documentation/query-builder/compound/all).

### match_none

```json Elasticsearch
{
  "query": { "match_none": {} }
}
```

```sql ParadeDB
SELECT * FROM products
WHERE id @@@ pdb.empty();
```

<Accordion title="Result">
  ``` id | description | category | rating | price | created_at
  ----+-------------+----------+--------+-------+------------ (0 rows) ```
</Accordion>

## Not Supported Queries

The following Elasticsearch query types do not have a direct equivalent in ParadeDB:

| ES Query                                       | Status        | Alternative                                                                                            |
| ---------------------------------------------- | ------------- | ------------------------------------------------------------------------------------------------------ |
| `nested` / `has_child` / `has_parent`          | Not supported | Use SQL `JOIN`s to query across related tables                                                         |
| `percolator`                                   | Not supported | No equivalent — consider application-level matching                                                    |
| `geo_*` (geo_distance, geo_bounding_box, etc.) | Not supported | Use [PostGIS](https://postgis.net/) alongside ParadeDB for geospatial queries                          |
| `script_score` / `function_score`              | Not supported | Use [`pdb.boost()`](/documentation/sorting/boost) and `paradedb.const_score()` as partial alternatives |
| `span_or` / `span_containing` / `span_within`  | Not supported | Only proximity queries (`##` operator) are supported; other span queries are not                       |

## Scoring and Relevance

| ES Feature          | ParadeDB SQL                                                                             | Reference                             |
| ------------------- | ---------------------------------------------------------------------------------------- | ------------------------------------- |
| `_score`            | `pdb.score(key_field)`                                                                   | [Score](/documentation/sorting/score) |
| `boost` (per-query) | `'query'::pdb.boost(2.0)`                                                                | [Boost](/documentation/sorting/boost) |
| `constant_score`    | `paradedb.const_score(1.0, ...)`                                                         |                                       |
| `explain`           | `EXPLAIN (FORMAT TEXT, COSTS OFF)`                                                       |                                       |
| `function_score`    | **Not supported** — use `pdb.boost()` / `paradedb.const_score()` as partial alternatives |                                       |

**Retrieving scores:**

```json Elasticsearch
{
  "query": { "match": { "description": "shoes" } }
}
// Response includes "_score" for each hit
```

```sql ParadeDB
SELECT id, description, pdb.score(id)
FROM products
WHERE description ||| 'shoes'
ORDER BY pdb.score(id) DESC;
```

<Accordion title="Result">
  ``` id | description | score
  ----+----------------------------------+---------- 1 | Sleek running shoes for
  athletes | 1.312099 2 | Cheap running shoes on sale | 1.312099 (2 rows) ```
</Accordion>

**Boosting a query:**

```json Elasticsearch
{
  "query": {
    "match": {
      "description": {
        "query": "shoes",
        "boost": 2.0
      }
    }
  }
}
```

```sql ParadeDB
SELECT * FROM products
WHERE description ||| 'shoes'::pdb.boost(2.0)
ORDER BY pdb.score(id) DESC;
```

<Accordion title="Result">
  ``` id | description ----+---------------------------------- 1 | Sleek running
  shoes for athletes 2 | Cheap running shoes on sale (2 rows) ```
</Accordion>

## Highlighting

| ES Feature               | ParadeDB SQL                                                   | Reference                                                                 |
| ------------------------ | -------------------------------------------------------------- | ------------------------------------------------------------------------- |
| `highlight`              | `pdb.snippet(column)`                                          | [Highlighting](/documentation/full-text/highlight)                        |
| Multiple highlights      | `pdb.snippets(column)`                                         | [Multiple Snippets](/documentation/full-text/highlight#multiple-snippets) |
| `pre_tags` / `post_tags` | `pdb.snippet(column, start_tag => '<em>', end_tag => '</em>')` |                                                                           |
| Byte offsets             | `pdb.snippet_positions(column)`                                | [Byte Offsets](/documentation/full-text/highlight#byte-offsets)           |

```json Elasticsearch
{
  "query": { "match": { "description": "shoes" } },
  "highlight": {
    "fields": { "description": {} },
    "pre_tags": ["<em>"],
    "post_tags": ["</em>"]
  }
}
```

```sql ParadeDB
SELECT id, pdb.snippet(description, start_tag => '<em>', end_tag => '</em>')
FROM products
WHERE description ||| 'shoes'
LIMIT 10;
```

<Accordion title="Result">
  ``` id | snippet ----+------------------------------------------- 1 | Sleek
  running <em>shoes</em> for athletes 2 | Cheap running <em>shoes</em> on sale
  (2 rows) ```
</Accordion>

<Warning>Highlighting is not supported for fuzzy search.</Warning>

## Aggregations

<Note>
  ParadeDB's `pdb.agg()` function accepts **Elasticsearch-compatible JSON**, so
  many of your existing aggregation queries can be reused with minimal changes.
  This is one of the biggest migration wins.
</Note>

### Bucket Aggregations

**terms**

```json Elasticsearch
{
  "aggs": {
    "categories": {
      "terms": { "field": "category" }
    }
  }
}
```

```sql ParadeDB
SELECT pdb.agg('{"terms": {"field": "category"}}')
FROM products
WHERE id @@@ pdb.all();
```

<Accordion title="Result">
```json
{
  "buckets": [
    {"key": "electronics", "doc_count": 3},
    {"key": "footwear", "doc_count": 3},
    {"key": "apparel", "doc_count": 2},
    {"key": "fitness", "doc_count": 1},
    {"key": "accessories", "doc_count": 1}
  ],
  "sum_other_doc_count": 0,
  "doc_count_error_upper_bound": 0
}
```
</Accordion>

**histogram**

```json Elasticsearch
{
  "aggs": {
    "rating_buckets": {
      "histogram": { "field": "rating", "interval": 1 }
    }
  }
}
```

```sql ParadeDB
SELECT pdb.agg('{"histogram": {"field": "rating", "interval": 1}}')
FROM products
WHERE id @@@ pdb.all();
```

<Accordion title="Result">
```json
{
  "buckets": [
    {"key": 3.0, "doc_count": 2},
    {"key": 4.0, "doc_count": 5},
    {"key": 5.0, "doc_count": 3}
  ]
}
```
</Accordion>

**date_histogram**

```json Elasticsearch
{
  "aggs": {
    "monthly": {
      "date_histogram": {
        "field": "created_at",
        "calendar_interval": "month"
      }
    }
  }
}
```

```sql ParadeDB
SELECT pdb.agg('{"date_histogram": {"field": "created_at", "fixed_interval": "30d"}}')
FROM products
WHERE id @@@ pdb.all();
```

<Accordion title="Result">
```json
{
  "buckets": [
    {"key": 1736640000000.0, "doc_count": 1, "key_as_string": "2025-01-12T00:00:00Z"},
    {"key": 1739232000000.0, "doc_count": 2, "key_as_string": "2025-02-11T00:00:00Z"},
    {"key": 1741824000000.0, "doc_count": 1, "key_as_string": "2025-03-13T00:00:00Z"},
    ...
  ]
}
```
</Accordion>

<Note>
  ParadeDB supports `fixed_interval` (e.g., `"30d"`, `"1h"`) but not
  `calendar_interval`.
</Note>

See [Date Histogram](/documentation/aggregates/bucket/datehistogram).

**range**

```json Elasticsearch
{
  "aggs": {
    "rating_buckets": {
      "range": {
        "field": "rating",
        "ranges": [{ "to": 3 }, { "from": 3, "to": 5 }, { "from": 5 }]
      }
    }
  }
}
```

```sql ParadeDB
SELECT pdb.agg('{"range": {"field": "rating", "ranges": [{"to": 3}, {"from": 3, "to": 5}, {"from": 5}]}}')
FROM products
WHERE id @@@ pdb.all();
```

<Accordion title="Result">
```json
{
  "buckets": [
    {"to": 3.0, "key": "*-3", "doc_count": 0},
    {"to": 5.0, "key": "3-5", "from": 3.0, "doc_count": 7},
    {"key": "5-*", "from": 5.0, "doc_count": 3}
  ]
}
```
</Accordion>

See [Range](/documentation/aggregates/bucket/range).

### Metric Aggregations

| ES Aggregation | ParadeDB SQL                                                                                        |
| -------------- | --------------------------------------------------------------------------------------------------- |
| `avg`          | `pdb.agg('{"avg": {"field": "rating"}}')`                                                           |
| `sum`          | `pdb.agg('{"sum": {"field": "rating"}}')`                                                           |
| `min` / `max`  | `pdb.agg('{"min": {"field": "rating"}}')`                                                           |
| `value_count`  | `pdb.agg('{"value_count": {"field": "id"}}')`                                                       |
| `stats`        | `pdb.agg('{"stats": {"field": "rating"}}')`                                                         |
| `percentiles`  | `pdb.agg('{"percentiles": {"field": "rating"}}')`                                                   |
| `cardinality`  | `pdb.agg('{"cardinality": {"field": "category"}}')`                                                 |
| `top_hits`     | `pdb.agg('{"top_hits": {"size": 3, "sort": [{"created_at": "desc"}], "docvalue_fields": ["id"]}}')` |

See [Aggregates](/documentation/aggregates/overview) for the full reference.

### Not Supported Aggregations

| ES Aggregation                                               | Status                                                   |
| ------------------------------------------------------------ | -------------------------------------------------------- |
| Pipeline aggregations (`derivative`, `cumulative_sum`, etc.) | Use SQL window functions (`SUM() OVER()`, `LAG()`, etc.) |
| Nested aggregations (sub-aggregations within bucket aggs)    | Use `pdb.agg()` with SQL `GROUP BY`                      |

<Note>
  As an alternative to aggregations, you can always use standard SQL `GROUP BY`
  with Postgres aggregate functions (`AVG`, `SUM`, `COUNT`, etc.) alongside
  ParadeDB search queries.
</Note>

## Text Analysis and Tokenizers

| ES Analyzer                | ParadeDB Tokenizer                      | Reference                                                                                                                                              |
| -------------------------- | --------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `standard`                 | `pdb.unicode` (default)                 | [Unicode](/documentation/tokenizers/available-tokenizers/unicode)                                                                                      |
| `simple`                   | `pdb.simple`                            | [Simple](/documentation/tokenizers/available-tokenizers/simple)                                                                                        |
| `whitespace`               | `pdb.whitespace`                        | [Whitespace](/documentation/tokenizers/available-tokenizers/whitespace)                                                                                |
| `keyword`                  | `pdb.literal`                           | [Literal](/documentation/tokenizers/available-tokenizers/literal)                                                                                      |
| `pattern`                  | `pdb.regex`                             | [Regex](/documentation/tokenizers/available-tokenizers/regex)                                                                                          |
| `ngram` / `edge_ngram`     | `pdb.ngram`                             | [N-grams](/documentation/tokenizers/available-tokenizers/ngrams)                                                                                       |
| ICU analyzer               | `pdb.icu`                               | [ICU](/documentation/tokenizers/available-tokenizers/icu)                                                                                              |
| Chinese analyzer           | `pdb.jieba` or `pdb.chinese_compatible` | [Jieba](/documentation/tokenizers/available-tokenizers/jieba), [Chinese Compatible](/documentation/tokenizers/available-tokenizers/chinese-compatible) |
| Japanese / Korean analyzer | `pdb.lindera`                           | [Lindera](/documentation/tokenizers/available-tokenizers/lindera)                                                                                      |

Tokenizers are configured at index creation time by casting columns:

```sql
CREATE INDEX search_idx ON products
USING bm25 (id, (description::pdb.ngram(3, 3)), (category::pdb.literal))
WITH (key_field = 'id');
```

To use a different tokenizer at search time, see [search_tokenizer](/documentation/tokenizers/search-tokenizer) or [Multiple Tokenizers Per Field](/documentation/tokenizers/multiple-per-field).

## Token Filters

| ES Token Filter                                                | ParadeDB Token Filter      | Reference                                                   |
| -------------------------------------------------------------- | -------------------------- | ----------------------------------------------------------- |
| `lowercase`                                                    | `lowercase`                | [Lowercase](/documentation/token-filters/lowercase)         |
| `stemmer`                                                      | `stemmer` (19 languages)   | [Stemming](/documentation/token-filters/stemming)           |
| `stop`                                                         | `stopwords` (29 languages) | [Stopwords](/documentation/token-filters/stopwords)         |
| `asciifolding`                                                 | `ascii_folding`            | [ASCII Folding](/documentation/token-filters/ascii-folding) |
| `length`                                                       | `token_length`             | [Token Length](/documentation/token-filters/token-length)   |
| `trim`                                                         | `trim`                     | [Trim](/documentation/token-filters/trim)                   |
| `alphanumeric`                                                 | `alpha_num_only`           | [Alphanumeric](/documentation/token-filters/alphanumeric)   |
| `synonym`                                                      | **Coming soon**            |                                                             |
| `synonym_graph`                                                | **Coming soon**            |                                                             |
| `word_delimiter`                                               | **Not supported**          |                                                             |
| Character filters (`html_strip`, `mapping`, `pattern_replace`) | **Not supported**          |                                                             |

## Pagination

| ES Feature      | ParadeDB SQL                      | Notes                                      |
| --------------- | --------------------------------- | ------------------------------------------ |
| `from` / `size` | `LIMIT` / `OFFSET`                | Standard SQL pagination                    |
| `scroll` API    | SQL cursors (`DECLARE` / `FETCH`) | Use Postgres cursors for large result sets |
| `search_after`  | Keyset pagination                 | `WHERE id > last_id ORDER BY id LIMIT n`   |

ParadeDB also supports a [TopN optimization](/documentation/sorting/topn) via the `paradedb.limit_fetch_multiplier`
GUC setting, which can significantly accelerate queries with `ORDER BY pdb.score(id) LIMIT n`.
