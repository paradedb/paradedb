---
title: Literal
description: Indexes the text in its raw form, without any splitting or processing
canonical: https://docs.paradedb.com/documentation/tokenizers/available-tokenizers/literal
---

<Note>
  The literal tokenizer is not ideal for text search queries like
  [match](/documentation/full-text/match) or
  [phrase](/documentation/full-text/phrase). If you need to do text search over
  a field that is literal tokenized, consider using [multiple
  tokenizers](/documentation/tokenizers/multiple-per-field).
</Note>

<Note>
  Because the literal tokenizer preserves the source text exactly, [token
  filters](/documentation/token-filters/overview) cannot be configured for this
  tokenizer.
</Note>

The literal tokenizer applies no tokenization to the text, preserving it as-is. It is the default for `uuid` fields (since
exact UUID matching is a common use case), and is useful for doing exact string matching over text fields.

It is also required if the text field is used as a sort field in a [Top N](/documentation/sorting/topn) query,
or as part of an [aggregate](/documentation/aggregates/overview).

<CodeGroup>
```sql SQL
CREATE INDEX search_idx ON mock_items
USING bm25 (id, (description::pdb.literal))
WITH (key_field='id');
```

```python Django
from django.db import models
from paradedb.indexes import BM25Index

class MockItem(models.Model):
    description = models.TextField()

    class Meta:
        indexes = [
            BM25Index(
                fields={
                    'id': {},
                    'description': {'tokenizer': 'literal'},
                },
                key_field='id',
                name='search_idx',
            ),
        ]
```

```ruby Rails
class MockItemIndex < ParadeDB::Index
  self.table_name = :mock_items
  self.key_field = :id
  self.index_name = :search_idx
  self.fields = {
    id: {},
    description: { tokenizer: :literal }
  }
end
```

</CodeGroup>

To get a feel for this tokenizer, run the following command and replace the text with your own:

<CodeGroup>
```sql SQL
SELECT 'Tokenize me!'::pdb.literal::text[];
```

```python Django
# Coming soon
```

```ruby Rails
ActiveRecord::Base.connection.exec_query("SELECT 'Tokenize me!'::pdb.literal::text[];")
```

</CodeGroup>

```ini Expected Response
       text
------------------
 {"Tokenize me!"}
(1 row)
```
