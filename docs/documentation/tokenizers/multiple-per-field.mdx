---
title: Multiple Tokenizers Per Field
description: Apply different token configurations to the same field
canonical: https://docs.paradedb.com/documentation/tokenizers/multiple-per-field
---

In many cases, a text field needs to be tokenized multiple ways. For instance, using the [unicode](/documentation/tokenizers/available-tokenizers/unicode)
tokenizer for search, and the [literal](/documentation/tokenizers/available-tokenizers/literal) tokenizer for [Top N ordering](/documentation/sorting/topn).

To tokenize a field in more than one way, append an `alias=<alias_name>` argument to the additional tokenizer configurations.
The alias name can be any string you like. For instance, the following statement tokenizes `description` using both the simple and literal tokenizers.

<CodeGroup>
```sql SQL
CREATE INDEX search_idx ON mock_items
USING bm25 (
  id,
  (description::pdb.literal),
  (description::pdb.simple('alias=description_simple'))
) WITH (key_field='id');
```

```python Django
from django.db import models
from paradedb.indexes import BM25Index

class MockItem(models.Model):
    description = models.TextField()

    class Meta:
        indexes = [
            BM25Index(
                fields={
                    'id': {},
                    'description': {
                        'tokenizers': [
                            {'tokenizer': 'literal'},
                            {'tokenizer': 'simple', 'alias': 'description_simple'},
                        ],
                    },
                },
                key_field='id',
                name='search_idx',
            ),
        ]
```

```ruby Rails
class MockItemIndex < ParadeDB::Index
  self.table_name = :mock_items
  self.key_field = :id
  self.fields = {
    id: {},
    description: {
      tokenizers: [
        { tokenizer: :literal },
        { tokenizer: :simple, alias: "description_simple" }
      ]
    }
  }
end
```

</CodeGroup>

Under the hood, two distinct fields are created in the index: a field called `description`, which uses the literal tokenizer,
and an aliased field called `description_simple`, which uses the simple tokenizer.

To query against the aliased field, cast it to `pdb.alias('alias_name')`:

<CodeGroup>
```sql SQL
-- Query against `description_simple`
SELECT description, rating, category
FROM mock_items
WHERE description::pdb.alias('description_simple') ||| 'Sleek running shoes';

-- Query against `description`
SELECT description, rating, category
FROM mock_items
WHERE description ||| 'Sleek running shoes';

````

```python Django
from django.db.models.expressions import RawSQL

# Query against `description_simple`
MockItem.objects.filter(
    RawSQL("(description::pdb.alias('description_simple')) ||| %s", ['Sleek running shoes'])
)

# Query against `description`
MockItem.objects.filter(RawSQL("description ||| %s", ['Sleek running shoes']))
````

```ruby Rails
# Query against `description_simple`
MockItem.search(:description).parse("description_simple:(Sleek OR running OR shoes)")

# Query against `description`
MockItem.search(:description).matching_any("Sleek", "running", "shoes")
```

</CodeGroup>

<Note>
If a text field uses multiple tokenizers and one of them is [literal](/documentation/tokenizers/available-tokenizers/literal), we recommend aliasing
the other tokenizers and leaving the literal tokenizer un-aliased. This is so queries that `GROUP BY`, `ORDER BY`, or aggregate the
text field can reference the field directly:

<CodeGroup>
```sql SQL
CREATE INDEX search_idx ON mock_items
USING bm25 (
  id,
  (description::pdb.literal),
  (description::pdb.simple('alias=description_simple'))
) WITH (key_field='id');

SELECT description, rating, category
FROM mock_items
WHERE description @@@ 'shoes'
ORDER BY description
LIMIT 5;

````

```python Django
from django.db import models
from paradedb.indexes import BM25Index
from paradedb.search import ParadeDB, Parse

class MockItem(models.Model):
    description = models.TextField()

    class Meta:
        indexes = [
            BM25Index(
                fields={
                    'id': {},
                    'description': {
                        'tokenizers': [
                            {'tokenizer': 'literal'},
                            {'tokenizer': 'simple', 'alias': 'description_simple'},
                        ],
                    },
                },
                key_field='id',
                name='search_idx',
            ),
        ]

MockItem.objects.filter(
    description=ParadeDB(Parse('shoes'))
).order_by('description')[:5]
````

```ruby Rails
MockItem.search(:description)
        .parse("description:shoes")
        .order(:description)
        .limit(5)
```

</CodeGroup>

</Note>
