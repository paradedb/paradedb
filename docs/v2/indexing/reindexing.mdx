---
title: Reindexing
---

Reindexing is necessary to change the index's schema. This includes adding, removing, or renaming fields, or changing a field's tokenizer
configuration.

The basic syntax for `REINDEX` is:

```sql
REINDEX INDEX search_idx;
```

This operation takes an exclusive lock on the table, which blocks incoming writes (but not reads) while the new index is being built.

To allow for concurrent writes during a reindex, use `REINDEX CONCURRENTLY`:

```sql
REINDEX INDEX CONCURRENTLY search_idx;
```

The tradeoff is that `REINDEX CONCURRENTLY` is slower than a plain `REINDEX`. Generally speaking, `REINDEX CONCURRENTLY` is recommended for
production systems that cannot tolerate temporarily blocked writes.

<Note>
  In order for `REINDEX CONCURRENTLY` to succeed, Postgres requires that the
  session that is executing the command remain open. If the session is closed,
  Postgres will cancel the reindex. This is relevant if you are using a
  connection pooler like `pgbouncer`, which can be configured to terminate
  sessions after a certain idle timeout is reached.
</Note>

<Note>
If `REINDEX CONCURRENTLY` fails or is cancelled, an invalid transient index will be left behind that must be dropped manually.
To check for invalid indexes in `psql`, run `\d <table_name>` and look for indexes suffixed by `_ccnew`.
</Note>
