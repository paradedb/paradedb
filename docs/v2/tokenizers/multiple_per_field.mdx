---
title: Multiple Tokenizers Per Field
---

In many cases, a text field needs to be tokenized multiple ways. For instance, using the [simple](/v2/tokenizers/available_tokenizers/simple)
tokenizer for search, and the [exact](/v2/tokenizers/available_tokenizers/exact) tokenizer for [Top N ordering](/v2/full-text/topn).

To tokenize a field in more than one way, append an `alias=<alias_name>` argument to the additional tokenizer configurations.
The alias name can be any string you like. For instance, the following statement tokenizes `description` using both the simple and exact tokenizers.

```sql
CREATE INDEX search_idx ON mock_items
USING bm25 (
  id,
  (description::pdb.exact),
  (description::pdb.simple('alias=description_simple'))
) WITH (key_field='id');
```

Under the hood, two distinct fields are created in the index: a field called `description`, which uses the exact tokenizer,
and an aliased field called `description_simple`, which uses the simple tokenizer.

To query against the aliased field, cast it to `pdb.alias('alias_name')`:

```sql
-- Query against `description_simple`
SELECT description, rating, category
FROM mock_items
WHERE description::pdb.alias('description_simple') ||| 'Sleek running shoes';

-- Query against `description`
SELECT description, rating, category
FROM mock_items
WHERE description ||| 'Sleek running shoes';
```

<Note>
If a text field uses multiple tokenizers and one of them is [exact](/v2/tokenizers/available_tokenizers/exact), we recommend aliasing
the other tokenizers and leaving the exact tokenizer un-aliased. This is so queries that `GROUP BY`, `ORDER BY`, or aggregate the
text field can reference the field directly:

```sql
CREATE INDEX search_idx ON mock_items
USING bm25 (
  id,
  (description::pdb.exact),
  (description::pdb.simple('alias=description_simple'))
) WITH (key_field='id');

SELECT description, rating, category
FROM mock_items
WHERE description @@@ 'shoes'
ORDER BY description
LIMIT 5;
```

</Note>
