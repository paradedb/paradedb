---
title: Architecture
---

All of the functionalities of ParadeDB are shipped as a Postgres extension called `pg_search`, which integrates with
Postgres' core mechanisms to deliver full-text search and analytics over Postgres tables.

## Index Access Method

PostgreSQL supports pluggable index access methods, which define how indexes are structured, stored, and queried. ParadeDB introduces a custom access method called the BM25 index.

### LSM Tree

The BM25 index is arranged as Log-Structured Merge (LSM) tree on disk. An LSM tree is a write-optimized data structure commonly used in systems like RocksDB and Cassandra.

The core idea behind an LSM tree is to turn random writes into sequential ones. Incoming writes are first stored in an in-memory buffer called a memtable, which is fast to update. Once the memtable fills up, it is flushed to disk as a sorted, immutable segment file (often called an SSTable).

These segment files are organized by size into layers or levels. Newer data is written to the topmost layer. Over time, data is gradually pushed down into lower levels through a process called compaction, where data from smaller segments is merged, deduplicated, and rewritten into larger segments.

### Write Patterns

When a table row is inserted or updated, Postgres automatically notifies the index via the access method's insert hooks. These changes are recorded as part of the current transaction, ensuring that index updates are fully transactional.

### Read Patterns

## Guarantees

ParadeDB inherits the strong guarantees of the underlying Postgres engine.

### Strong Consistency

All reads and writes go through Postgres’ transaction engine, ensuring serializability and consistency across indexes and base tables. Search results are always consistent with the current transactional state—no eventual consistency, lag, or stale reads.

### ACID

Search indexes participate fully in Postgres transactions. Inserts, updates, and deletes to indexed columns are atomic and durable. If a transaction is rolled back, associated index changes are also rolled back.

### SQL Syntax

ParadeDB extends standard SQL with additional functions and operators for search and analytics, but remains fully compatible with core SQL syntax. You can use search indexes in any query context—`SELECT`, `JOIN`, `CTE`, `VIEW`, `MATERIALIZED VIEW`—just like any native Postgres index.

### Postgres WAL Compatible

All index changes are logged via Postgres' Write-Ahead Log (WAL), ensuring crash safety and support for physical and logical replication. ParadeDB indexes replicate and recover like any other Postgres relation, requiring no special setup or coordination.

## Design Decisions

### Why We Built a Custom Index

Postgres indexes are a ...

Postgres' existing indexes have key limitations for modern search use cases:

- Filtered/boolean query support is limited and inefficient
- Not optimized for high-ingest workloads
- No support for query parallelization
- Lacks built-in BM25 scoring

In addition, PostgreSQL has limited support for efficient aggregations. Clauses like COUNT, GROUP BY, and ORDER BY are not optimized:

- Postgres must materialize the full result set and perform aggregation in memory, which becomes a bottleneck at scale
- There is no support for aggregation pushdown into Postgres' built-in indexes
- Batch reads are inefficient because Postgres does not provide a way to read index data in a columnar or vectorized format
