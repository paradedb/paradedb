(() => {
var exports = {};
exports.id = 931;
exports.ids = [931];
exports.modules = {

/***/ 18038:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/react");

/***/ }),

/***/ 98704:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/react-dom/server-rendering-stub");

/***/ }),

/***/ 97897:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/react-server-dom-webpack/client");

/***/ }),

/***/ 56786:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/compiled/react/jsx-runtime");

/***/ }),

/***/ 5868:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/app-render");

/***/ }),

/***/ 41844:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/app-render/get-segment-param");

/***/ }),

/***/ 96624:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/future/helpers/interception-routes");

/***/ }),

/***/ 75281:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/server/future/route-modules/route-module");

/***/ }),

/***/ 57085:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/app-router-context");

/***/ }),

/***/ 20199:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/hash");

/***/ }),

/***/ 39569:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/hooks-client-context");

/***/ }),

/***/ 30893:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/add-path-prefix");

/***/ }),

/***/ 17887:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/handle-smooth-scroll");

/***/ }),

/***/ 98735:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/is-bot");

/***/ }),

/***/ 68231:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/parse-path");

/***/ }),

/***/ 53750:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/router/utils/remove-trailing-slash");

/***/ }),

/***/ 79618:
/***/ ((module) => {

"use strict";
module.exports = require("next/dist/shared/lib/server-inserted-html");

/***/ }),

/***/ 9792:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   GlobalError: () => (/* reexport safe */ next_dist_client_components_error_boundary__WEBPACK_IMPORTED_MODULE_1__.GlobalError),
/* harmony export */   __next_app__: () => (/* binding */ __next_app__),
/* harmony export */   originalPathname: () => (/* binding */ originalPathname),
/* harmony export */   pages: () => (/* binding */ pages),
/* harmony export */   routeModule: () => (/* binding */ routeModule),
/* harmony export */   tree: () => (/* binding */ tree)
/* harmony export */ });
/* harmony import */ var next_dist_server_future_route_modules_app_page_module__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(31240);
/* harmony import */ var next_dist_server_future_route_modules_app_page_module__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_page_module__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var next_dist_client_components_error_boundary__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(49506);
/* harmony import */ var next_dist_client_components_error_boundary__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(next_dist_client_components_error_boundary__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var next_dist_server_app_render_entry_base__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(95394);
/* harmony import */ var next_dist_server_app_render_entry_base__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_app_render_entry_base__WEBPACK_IMPORTED_MODULE_2__);
/* harmony reexport (unknown) */ var __WEBPACK_REEXPORT_OBJECT__ = {};
/* harmony reexport (unknown) */ for(const __WEBPACK_IMPORT_KEY__ in next_dist_server_app_render_entry_base__WEBPACK_IMPORTED_MODULE_2__) if(["default","tree","pages","GlobalError","originalPathname","__next_app__","routeModule"].indexOf(__WEBPACK_IMPORT_KEY__) < 0) __WEBPACK_REEXPORT_OBJECT__[__WEBPACK_IMPORT_KEY__] = () => next_dist_server_app_render_entry_base__WEBPACK_IMPORTED_MODULE_2__[__WEBPACK_IMPORT_KEY__]
/* harmony reexport (unknown) */ __webpack_require__.d(__webpack_exports__, __WEBPACK_REEXPORT_OBJECT__);

    

    const tree = {
        children: [
        '',
        {
        children: ['__PAGE__', {}, {
          page: [() => Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 725)), "/Users/mingying/Retake/retake/examples/mdx/app/page.tsx"],
          
        }]
      },
        {
          'layout': [() => Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 75200)), "/Users/mingying/Retake/retake/examples/mdx/app/layout.tsx"],
          
        }
      ]
      }.children;
    const pages = ["/Users/mingying/Retake/retake/examples/mdx/app/page.tsx"];

    

    const originalPathname = "/page"
    const __next_app__ = {
      require: __webpack_require__,
      // all modules are in the entry chunk, so we never actually need to load chunks in webpack
      loadChunk: () => Promise.resolve()
    }

    

    // Create and export the route module that will be consumed.
    const options = {"definition":{"kind":"APP_PAGE","page":"/page","pathname":"/","bundlePath":"app/page","filename":"","appPaths":[]}}
    const routeModule = new (next_dist_server_future_route_modules_app_page_module__WEBPACK_IMPORTED_MODULE_0___default())({
      ...options,
      userland: {
        loaderTree: tree,
      },
    })
  

/***/ }),

/***/ 56515:
/***/ (() => {



/***/ }),

/***/ 2767:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

Promise.resolve(/* import() eager */).then(__webpack_require__.bind(__webpack_require__, 76141))

/***/ }),

/***/ 7006:
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

Promise.resolve(/* import() eager */).then(__webpack_require__.t.bind(__webpack_require__, 50885, 23));
Promise.resolve(/* import() eager */).then(__webpack_require__.t.bind(__webpack_require__, 94564, 23));
Promise.resolve(/* import() eager */).then(__webpack_require__.t.bind(__webpack_require__, 80772, 23));
Promise.resolve(/* import() eager */).then(__webpack_require__.t.bind(__webpack_require__, 68262, 23));
Promise.resolve(/* import() eager */).then(__webpack_require__.t.bind(__webpack_require__, 4249, 23))

/***/ }),

/***/ 76141:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  "default": () => (/* binding */ page)
});

// EXTERNAL MODULE: external "next/dist/compiled/react/jsx-runtime"
var jsx_runtime_ = __webpack_require__(56786);
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(71198);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
// EXTERNAL MODULE: external "next/dist/compiled/react"
var react_ = __webpack_require__(18038);
var react_default = /*#__PURE__*/__webpack_require__.n(react_);
// EXTERNAL MODULE: ./node_modules/@tremor/react/dist/index.cjs
var dist = __webpack_require__(48213);
// EXTERNAL MODULE: ./node_modules/@headlessui/react/dist/components/transitions/transition.js + 4 modules
var transition = __webpack_require__(86235);
// EXTERNAL MODULE: ./node_modules/@headlessui/react/dist/components/dialog/dialog.js + 22 modules
var dialog = __webpack_require__(83483);
// EXTERNAL MODULE: ./node_modules/@headlessui/react/dist/components/combobox/combobox.js + 7 modules
var combobox = __webpack_require__(68424);
// EXTERNAL MODULE: ./node_modules/@heroicons/react/24/outline/esm/MagnifyingGlassIcon.js
var MagnifyingGlassIcon = __webpack_require__(92523);
// EXTERNAL MODULE: ./node_modules/@heroicons/react/24/outline/esm/HashtagIcon.js
var HashtagIcon = __webpack_require__(18086);
// EXTERNAL MODULE: ./node_modules/@heroicons/react/24/outline/esm/ExclamationCircleIcon.js
var ExclamationCircleIcon = __webpack_require__(61470);
;// CONCATENATED MODULE: ../../clients/typescript/dist/index-6bd0eeff.js
var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

var src = {};

var core = {};

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT$1 = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$2 = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY$2 = 1 / 0,
    MAX_SAFE_INTEGER$2 = 9007199254740991;

/** `Object#toString` result references. */
var argsTag$2 = '[object Arguments]',
    funcTag$2 = '[object Function]',
    genTag$2 = '[object GeneratorFunction]',
    symbolTag$2 = '[object Symbol]';

/** Used to match property names within property paths. */
var reIsDeepProp$1 = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp$1 = /^\w*$/,
    reLeadingDot$1 = /^\./,
    rePropName$1 = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar$2 = /[\\^$.*+?()[\]{}|]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar$1 = /\\(\\)?/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor$2 = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint$2 = /^(?:0|[1-9]\d*)$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal$2 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

/** Detect free variable `self`. */
var freeSelf$2 = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root$2 = freeGlobal$2 || freeSelf$2 || Function('return this')();

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue$2(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject$2(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto$2 = Array.prototype,
    funcProto$2 = Function.prototype,
    objectProto$3 = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData$2 = root$2['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey$2 = (function() {
  var uid = /[^.]+$/.exec(coreJsData$2 && coreJsData$2.keys && coreJsData$2.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString$2 = funcProto$2.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$3 = objectProto$3.toString;

/** Used to detect if a method is native. */
var reIsNative$2 = RegExp('^' +
  funcToString$2.call(hasOwnProperty$3).replace(reRegExpChar$2, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol$2 = root$2.Symbol,
    propertyIsEnumerable$2 = objectProto$3.propertyIsEnumerable,
    splice$2 = arrayProto$2.splice;

/* Built-in method references that are verified to be native. */
var Map$2 = getNative$2(root$2, 'Map'),
    nativeCreate$2 = getNative$2(Object, 'create');

/** Used to convert symbols to primitives and strings. */
var symbolProto$1 = Symbol$2 ? Symbol$2.prototype : undefined,
    symbolToString$1 = symbolProto$1 ? symbolProto$1.toString : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash$2(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear$2() {
  this.__data__ = nativeCreate$2 ? nativeCreate$2(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete$2(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet$2(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? undefined : result;
  }
  return hasOwnProperty$3.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas$2(key) {
  var data = this.__data__;
  return nativeCreate$2 ? data[key] !== undefined : hasOwnProperty$3.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet$2(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate$2 && value === undefined) ? HASH_UNDEFINED$2 : value;
  return this;
}

// Add methods to `Hash`.
Hash$2.prototype.clear = hashClear$2;
Hash$2.prototype['delete'] = hashDelete$2;
Hash$2.prototype.get = hashGet$2;
Hash$2.prototype.has = hashHas$2;
Hash$2.prototype.set = hashSet$2;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache$2(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear$2() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete$2(key) {
  var data = this.__data__,
      index = assocIndexOf$2(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice$2.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet$2(key) {
  var data = this.__data__,
      index = assocIndexOf$2(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas$2(key) {
  return assocIndexOf$2(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet$2(key, value) {
  var data = this.__data__,
      index = assocIndexOf$2(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache$2.prototype.clear = listCacheClear$2;
ListCache$2.prototype['delete'] = listCacheDelete$2;
ListCache$2.prototype.get = listCacheGet$2;
ListCache$2.prototype.has = listCacheHas$2;
ListCache$2.prototype.set = listCacheSet$2;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache$2(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear$2() {
  this.__data__ = {
    'hash': new Hash$2,
    'map': new (Map$2 || ListCache$2),
    'string': new Hash$2
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete$2(key) {
  return getMapData$2(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet$2(key) {
  return getMapData$2(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas$2(key) {
  return getMapData$2(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet$2(key, value) {
  getMapData$2(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache$2.prototype.clear = mapCacheClear$2;
MapCache$2.prototype['delete'] = mapCacheDelete$2;
MapCache$2.prototype.get = mapCacheGet$2;
MapCache$2.prototype.has = mapCacheHas$2;
MapCache$2.prototype.set = mapCacheSet$2;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf$2(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$2(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.has` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHas(object, key) {
  return object != null && hasOwnProperty$3.call(object, key);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative$2(value) {
  if (!isObject$7(value) || isMasked$2(value)) {
    return false;
  }
  var pattern = (isFunction$2(value) || isHostObject$2(value)) ? reIsNative$2 : reIsHostCtor$2;
  return pattern.test(toSource$2(value));
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString$1(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol$2(value)) {
    return symbolToString$1 ? symbolToString$1.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY$2) ? '-0' : result;
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath$1(value) {
  return isArray$3(value) ? value : stringToPath$1(value);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData$2(map, key) {
  var data = map.__data__;
  return isKeyable$2(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative$2(object, key) {
  var value = getValue$2(object, key);
  return baseIsNative$2(value) ? value : undefined;
}

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath$1(object, path, hasFunc) {
  path = isKey$1(path, object) ? [path] : castPath$1(path);

  var result,
      index = -1,
      length = path.length;

  while (++index < length) {
    var key = toKey$2(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result) {
    return result;
  }
  var length = object ? object.length : 0;
  return !!length && isLength$2(length) && isIndex$2(key, length) &&
    (isArray$3(object) || isArguments$2(object));
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex$2(value, length) {
  length = length == null ? MAX_SAFE_INTEGER$2 : length;
  return !!length &&
    (typeof value == 'number' || reIsUint$2.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey$1(value, object) {
  if (isArray$3(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol$2(value)) {
    return true;
  }
  return reIsPlainProp$1.test(value) || !reIsDeepProp$1.test(value) ||
    (object != null && value in Object(object));
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable$2(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked$2(func) {
  return !!maskSrcKey$2 && (maskSrcKey$2 in func);
}

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath$1 = memoize$1(function(string) {
  string = toString$1(string);

  var result = [];
  if (reLeadingDot$1.test(string)) {
    result.push('');
  }
  string.replace(rePropName$1, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar$1, '$1') : (number || match));
  });
  return result;
});

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey$2(value) {
  if (typeof value == 'string' || isSymbol$2(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY$2) ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$2.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize$1(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize$1.Cache || MapCache$2);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize$1.Cache = MapCache$2;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq$2(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments$2(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject$2(value) && hasOwnProperty$3.call(value, 'callee') &&
    (!propertyIsEnumerable$2.call(value, 'callee') || objectToString$3.call(value) == argsTag$2);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray$3 = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike$2(value) {
  return value != null && isLength$2(value.length) && !isFunction$2(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject$2(value) {
  return isObjectLike$3(value) && isArrayLike$2(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction$2(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject$7(value) ? objectToString$3.call(value) : '';
  return tag == funcTag$2 || tag == genTag$2;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength$2(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$2;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject$7(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike$3(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol$2(value) {
  return typeof value == 'symbol' ||
    (isObjectLike$3(value) && objectToString$3.call(value) == symbolTag$2);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString$1(value) {
  return value == null ? '' : baseToString$1(value);
}

/**
 * Checks if `path` is a direct property of `object`.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = { 'a': { 'b': 2 } };
 * var other = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.has(object, 'a');
 * // => true
 *
 * _.has(object, 'a.b');
 * // => true
 *
 * _.has(object, ['a', 'b']);
 * // => true
 *
 * _.has(other, 'a');
 * // => false
 */
function has$d(object, path) {
  return object != null && hasPath$1(object, path, baseHas);
}

var lodash_has = has$d;

/**
 * lodash 4.0.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * Checks if `value` is `null` or `undefined`.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
 * @example
 *
 * _.isNil(null);
 * // => true
 *
 * _.isNil(void 0);
 * // => true
 *
 * _.isNil(NaN);
 * // => false
 */
function isNil$1e(value) {
  return value == null;
}

var lodash_isnil = isNil$1e;

var lodash_isempty = {exports: {}};

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
lodash_isempty.exports;

(function (module, exports) {
	/** Used as references for various `Number` constants. */
	var MAX_SAFE_INTEGER = 9007199254740991;

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]',
	    funcTag = '[object Function]',
	    genTag = '[object GeneratorFunction]',
	    mapTag = '[object Map]',
	    objectTag = '[object Object]',
	    promiseTag = '[object Promise]',
	    setTag = '[object Set]',
	    weakMapTag = '[object WeakMap]';

	var dataViewTag = '[object DataView]';

	/**
	 * Used to match `RegExp`
	 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
	 */
	var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

	/** Used to detect host constructors (Safari). */
	var reIsHostCtor = /^\[object .+?Constructor\]$/;

	/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	/** Detect free variable `exports`. */
	var freeExports = exports && !exports.nodeType && exports;

	/** Detect free variable `module`. */
	var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

	/** Detect the popular CommonJS extension `module.exports`. */
	var moduleExports = freeModule && freeModule.exports === freeExports;

	/**
	 * Gets the value at `key` of `object`.
	 *
	 * @private
	 * @param {Object} [object] The object to query.
	 * @param {string} key The key of the property to get.
	 * @returns {*} Returns the property value.
	 */
	function getValue(object, key) {
	  return object == null ? undefined : object[key];
	}

	/**
	 * Checks if `value` is a host object in IE < 9.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
	 */
	function isHostObject(value) {
	  // Many host objects are `Object` objects that can coerce to strings
	  // despite having improperly defined `toString` methods.
	  var result = false;
	  if (value != null && typeof value.toString != 'function') {
	    try {
	      result = !!(value + '');
	    } catch (e) {}
	  }
	  return result;
	}

	/**
	 * Creates a unary function that invokes `func` with its argument transformed.
	 *
	 * @private
	 * @param {Function} func The function to wrap.
	 * @param {Function} transform The argument transform.
	 * @returns {Function} Returns the new function.
	 */
	function overArg(func, transform) {
	  return function(arg) {
	    return func(transform(arg));
	  };
	}

	/** Used for built-in method references. */
	var funcProto = Function.prototype,
	    objectProto = Object.prototype;

	/** Used to detect overreaching core-js shims. */
	var coreJsData = root['__core-js_shared__'];

	/** Used to detect methods masquerading as native. */
	var maskSrcKey = (function() {
	  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
	  return uid ? ('Symbol(src)_1.' + uid) : '';
	}());

	/** Used to resolve the decompiled source of functions. */
	var funcToString = funcProto.toString;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var objectToString = objectProto.toString;

	/** Used to detect if a method is native. */
	var reIsNative = RegExp('^' +
	  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
	  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
	);

	/** Built-in value references. */
	var Buffer = moduleExports ? root.Buffer : undefined,
	    propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/* Built-in method references for those with the same name as other `lodash` methods. */
	var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
	    nativeKeys = overArg(Object.keys, Object);

	/* Built-in method references that are verified to be native. */
	var DataView = getNative(root, 'DataView'),
	    Map = getNative(root, 'Map'),
	    Promise = getNative(root, 'Promise'),
	    Set = getNative(root, 'Set'),
	    WeakMap = getNative(root, 'WeakMap');

	/** Detect if properties shadowing those on `Object.prototype` are non-enumerable. */
	var nonEnumShadows = !propertyIsEnumerable.call({ 'valueOf': 1 }, 'valueOf');

	/** Used to detect maps, sets, and weakmaps. */
	var dataViewCtorString = toSource(DataView),
	    mapCtorString = toSource(Map),
	    promiseCtorString = toSource(Promise),
	    setCtorString = toSource(Set),
	    weakMapCtorString = toSource(WeakMap);

	/**
	 * The base implementation of `getTag`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  return objectToString.call(value);
	}

	/**
	 * The base implementation of `_.isNative` without bad shim checks.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a native function,
	 *  else `false`.
	 */
	function baseIsNative(value) {
	  if (!isObject(value) || isMasked(value)) {
	    return false;
	  }
	  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
	  return pattern.test(toSource(value));
	}

	/**
	 * Gets the native function at `key` of `object`.
	 *
	 * @private
	 * @param {Object} object The object to query.
	 * @param {string} key The key of the method to get.
	 * @returns {*} Returns the function if it's native, else `undefined`.
	 */
	function getNative(object, key) {
	  var value = getValue(object, key);
	  return baseIsNative(value) ? value : undefined;
	}

	/**
	 * Gets the `toStringTag` of `value`.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	var getTag = baseGetTag;

	// Fallback for data views, maps, sets, and weak maps in IE 11,
	// for data views in Edge < 14, and promises in Node.js.
	if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
	    (Map && getTag(new Map) != mapTag) ||
	    (Promise && getTag(Promise.resolve()) != promiseTag) ||
	    (Set && getTag(new Set) != setTag) ||
	    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
	  getTag = function(value) {
	    var result = objectToString.call(value),
	        Ctor = result == objectTag ? value.constructor : undefined,
	        ctorString = Ctor ? toSource(Ctor) : undefined;

	    if (ctorString) {
	      switch (ctorString) {
	        case dataViewCtorString: return dataViewTag;
	        case mapCtorString: return mapTag;
	        case promiseCtorString: return promiseTag;
	        case setCtorString: return setTag;
	        case weakMapCtorString: return weakMapTag;
	      }
	    }
	    return result;
	  };
	}

	/**
	 * Checks if `func` has its source masked.
	 *
	 * @private
	 * @param {Function} func The function to check.
	 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
	 */
	function isMasked(func) {
	  return !!maskSrcKey && (maskSrcKey in func);
	}

	/**
	 * Checks if `value` is likely a prototype object.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
	 */
	function isPrototype(value) {
	  var Ctor = value && value.constructor,
	      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

	  return value === proto;
	}

	/**
	 * Converts `func` to its source code.
	 *
	 * @private
	 * @param {Function} func The function to process.
	 * @returns {string} Returns the source code.
	 */
	function toSource(func) {
	  if (func != null) {
	    try {
	      return funcToString.call(func);
	    } catch (e) {}
	    try {
	      return (func + '');
	    } catch (e) {}
	  }
	  return '';
	}

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	function isArguments(value) {
	  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
	  return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
	    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
	}

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	/**
	 * Checks if `value` is array-like. A value is considered array-like if it's
	 * not a function and has a `value.length` that's an integer greater than or
	 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
	 * @example
	 *
	 * _.isArrayLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLike(document.body.children);
	 * // => true
	 *
	 * _.isArrayLike('abc');
	 * // => true
	 *
	 * _.isArrayLike(_.noop);
	 * // => false
	 */
	function isArrayLike(value) {
	  return value != null && isLength(value.length) && !isFunction(value);
	}

	/**
	 * This method is like `_.isArrayLike` except that it also checks if `value`
	 * is an object.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array-like object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArrayLikeObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isArrayLikeObject(document.body.children);
	 * // => true
	 *
	 * _.isArrayLikeObject('abc');
	 * // => false
	 *
	 * _.isArrayLikeObject(_.noop);
	 * // => false
	 */
	function isArrayLikeObject(value) {
	  return isObjectLike(value) && isArrayLike(value);
	}

	/**
	 * Checks if `value` is a buffer.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.3.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
	 * @example
	 *
	 * _.isBuffer(new Buffer(2));
	 * // => true
	 *
	 * _.isBuffer(new Uint8Array(2));
	 * // => false
	 */
	var isBuffer = nativeIsBuffer || stubFalse;

	/**
	 * Checks if `value` is an empty object, collection, map, or set.
	 *
	 * Objects are considered empty if they have no own enumerable string keyed
	 * properties.
	 *
	 * Array-like values such as `arguments` objects, arrays, buffers, strings, or
	 * jQuery-like collections are considered empty if they have a `length` of `0`.
	 * Similarly, maps and sets are considered empty if they have a `size` of `0`.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is empty, else `false`.
	 * @example
	 *
	 * _.isEmpty(null);
	 * // => true
	 *
	 * _.isEmpty(true);
	 * // => true
	 *
	 * _.isEmpty(1);
	 * // => true
	 *
	 * _.isEmpty([1, 2, 3]);
	 * // => false
	 *
	 * _.isEmpty({ 'a': 1 });
	 * // => false
	 */
	function isEmpty(value) {
	  if (isArrayLike(value) &&
	      (isArray(value) || typeof value == 'string' ||
	        typeof value.splice == 'function' || isBuffer(value) || isArguments(value))) {
	    return !value.length;
	  }
	  var tag = getTag(value);
	  if (tag == mapTag || tag == setTag) {
	    return !value.size;
	  }
	  if (nonEnumShadows || isPrototype(value)) {
	    return !nativeKeys(value).length;
	  }
	  for (var key in value) {
	    if (hasOwnProperty.call(value, key)) {
	      return false;
	    }
	  }
	  return true;
	}

	/**
	 * Checks if `value` is classified as a `Function` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
	 * @example
	 *
	 * _.isFunction(_);
	 * // => true
	 *
	 * _.isFunction(/abc/);
	 * // => false
	 */
	function isFunction(value) {
	  // The use of `Object#toString` avoids issues with the `typeof` operator
	  // in Safari 8-9 which returns 'object' for typed array and other constructors.
	  var tag = isObject(value) ? objectToString.call(value) : '';
	  return tag == funcTag || tag == genTag;
	}

	/**
	 * Checks if `value` is a valid array-like length.
	 *
	 * **Note:** This method is loosely based on
	 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
	 * @example
	 *
	 * _.isLength(3);
	 * // => true
	 *
	 * _.isLength(Number.MIN_VALUE);
	 * // => false
	 *
	 * _.isLength(Infinity);
	 * // => false
	 *
	 * _.isLength('3');
	 * // => false
	 */
	function isLength(value) {
	  return typeof value == 'number' &&
	    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
	}

	/**
	 * Checks if `value` is the
	 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
	 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
	 * @example
	 *
	 * _.isObject({});
	 * // => true
	 *
	 * _.isObject([1, 2, 3]);
	 * // => true
	 *
	 * _.isObject(_.noop);
	 * // => true
	 *
	 * _.isObject(null);
	 * // => false
	 */
	function isObject(value) {
	  var type = typeof value;
	  return !!value && (type == 'object' || type == 'function');
	}

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return !!value && typeof value == 'object';
	}

	/**
	 * This method returns `false`.
	 *
	 * @static
	 * @memberOf _
	 * @since 4.13.0
	 * @category Util
	 * @returns {boolean} Returns `false`.
	 * @example
	 *
	 * _.times(2, _.stubFalse);
	 * // => [false, false]
	 */
	function stubFalse() {
	  return false;
	}

	module.exports = isEmpty; 
} (lodash_isempty, lodash_isempty.exports));

var lodash_isemptyExports = lodash_isempty.exports;

var util = {};

/**
 * lodash 4.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/** `Object#toString` result references. */
var stringTag = '[object String]';

/** Used for built-in method references. */
var objectProto$2 = Object.prototype;

/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$2 = objectProto$2.toString;

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @type Function
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray$2 = Array.isArray;

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike$2(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString$2(value) {
  return typeof value == 'string' ||
    (!isArray$2(value) && isObjectLike$2(value) && objectToString$2.call(value) == stringTag);
}

var lodash_isstring = isString$2;

/**
 * lodash 3.0.2 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern modularize exports="npm" -o ./`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */

/**
 * Checks if `value` is the [language type](https://es5.github.io/#x8) of `Object`.
 * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(1);
 * // => false
 */
function isObject$6(value) {
  // Avoid a V8 JIT bug in Chrome 19-20.
  // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

var lodash_isobject = isObject$6;

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED$1 = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY$1 = 1 / 0,
    MAX_SAFE_INTEGER$1 = 9007199254740991;

/** `Object#toString` result references. */
var argsTag$1 = '[object Arguments]',
    funcTag$1 = '[object Function]',
    genTag$1 = '[object GeneratorFunction]',
    symbolTag$1 = '[object Symbol]';

/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/,
    reLeadingDot = /^\./,
    rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar$1 = /[\\^$.*+?()[\]{}|]/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor$1 = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint$1 = /^(?:0|[1-9]\d*)$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal$1 = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

/** Detect free variable `self`. */
var freeSelf$1 = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root$1 = freeGlobal$1 || freeSelf$1 || Function('return this')();

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue$1(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject$1(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/** Used for built-in method references. */
var arrayProto$1 = Array.prototype,
    funcProto$1 = Function.prototype,
    objectProto$1 = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData$1 = root$1['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey$1 = (function() {
  var uid = /[^.]+$/.exec(coreJsData$1 && coreJsData$1.keys && coreJsData$1.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString$1 = funcProto$1.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$2 = objectProto$1.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString$1 = objectProto$1.toString;

/** Used to detect if a method is native. */
var reIsNative$1 = RegExp('^' +
  funcToString$1.call(hasOwnProperty$2).replace(reRegExpChar$1, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var Symbol$1 = root$1.Symbol,
    propertyIsEnumerable$1 = objectProto$1.propertyIsEnumerable,
    splice$1 = arrayProto$1.splice;

/* Built-in method references that are verified to be native. */
var Map$1 = getNative$1(root$1, 'Map'),
    nativeCreate$1 = getNative$1(Object, 'create');

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
    symbolToString = symbolProto ? symbolProto.toString : undefined;

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash$1(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear$1() {
  this.__data__ = nativeCreate$1 ? nativeCreate$1(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete$1(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$1) {
    var result = data[key];
    return result === HASH_UNDEFINED$1 ? undefined : result;
  }
  return hasOwnProperty$2.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== undefined : hasOwnProperty$2.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet$1(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate$1 && value === undefined) ? HASH_UNDEFINED$1 : value;
  return this;
}

// Add methods to `Hash`.
Hash$1.prototype.clear = hashClear$1;
Hash$1.prototype['delete'] = hashDelete$1;
Hash$1.prototype.get = hashGet$1;
Hash$1.prototype.has = hashHas$1;
Hash$1.prototype.set = hashSet$1;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache$1(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear$1() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete$1(key) {
  var data = this.__data__,
      index = assocIndexOf$1(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice$1.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet$1(key) {
  var data = this.__data__,
      index = assocIndexOf$1(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet$1(key, value) {
  var data = this.__data__,
      index = assocIndexOf$1(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache$1.prototype.clear = listCacheClear$1;
ListCache$1.prototype['delete'] = listCacheDelete$1;
ListCache$1.prototype.get = listCacheGet$1;
ListCache$1.prototype.has = listCacheHas$1;
ListCache$1.prototype.set = listCacheSet$1;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache$1(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear$1() {
  this.__data__ = {
    'hash': new Hash$1,
    'map': new (Map$1 || ListCache$1),
    'string': new Hash$1
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete$1(key) {
  return getMapData$1(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet$1(key) {
  return getMapData$1(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet$1(key, value) {
  getMapData$1(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache$1.prototype.clear = mapCacheClear$1;
MapCache$1.prototype['delete'] = mapCacheDelete$1;
MapCache$1.prototype.get = mapCacheGet$1;
MapCache$1.prototype.has = mapCacheHas$1;
MapCache$1.prototype.set = mapCacheSet$1;

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf$1(array, key) {
  var length = array.length;
  while (length--) {
    if (eq$1(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.hasIn` without support for deep paths.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {Array|string} key The key to check.
 * @returns {boolean} Returns `true` if `key` exists, else `false`.
 */
function baseHasIn(object, key) {
  return object != null && key in Object(object);
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative$1(value) {
  if (!isObject$5(value) || isMasked$1(value)) {
    return false;
  }
  var pattern = (isFunction$1(value) || isHostObject$1(value)) ? reIsNative$1 : reIsHostCtor$1;
  return pattern.test(toSource$1(value));
}

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (isSymbol$1(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
}

/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value) {
  return isArray$1(value) ? value : stringToPath(value);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData$1(map, key) {
  var data = map.__data__;
  return isKeyable$1(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative$1(object, key) {
  var value = getValue$1(object, key);
  return baseIsNative$1(value) ? value : undefined;
}

/**
 * Checks if `path` exists on `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @param {Function} hasFunc The function to check properties.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 */
function hasPath(object, path, hasFunc) {
  path = isKey(path, object) ? [path] : castPath(path);

  var result,
      index = -1,
      length = path.length;

  while (++index < length) {
    var key = toKey$1(path[index]);
    if (!(result = object != null && hasFunc(object, key))) {
      break;
    }
    object = object[key];
  }
  if (result) {
    return result;
  }
  var length = object ? object.length : 0;
  return !!length && isLength$1(length) && isIndex$1(key, length) &&
    (isArray$1(object) || isArguments$1(object));
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex$1(value, length) {
  length = length == null ? MAX_SAFE_INTEGER$1 : length;
  return !!length &&
    (typeof value == 'number' || reIsUint$1.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (isArray$1(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || isSymbol$1(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable$1(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked$1(func) {
  return !!maskSrcKey$1 && (maskSrcKey$1 in func);
}

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = memoize(function(string) {
  string = index_6bd0eeff_toString(string);

  var result = [];
  if (reLeadingDot.test(string)) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, string) {
    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey$1(value) {
  if (typeof value == 'string' || isSymbol$1(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY$1) ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource$1(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result);
    return result;
  };
  memoized.cache = new (memoize.Cache || MapCache$1);
  return memoized;
}

// Assign cache to `_.memoize`.
memoize.Cache = MapCache$1;

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq$1(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments$1(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject$1(value) && hasOwnProperty$2.call(value, 'callee') &&
    (!propertyIsEnumerable$1.call(value, 'callee') || objectToString$1.call(value) == argsTag$1);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray$1 = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike$1(value) {
  return value != null && isLength$1(value.length) && !isFunction$1(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject$1(value) {
  return isObjectLike$1(value) && isArrayLike$1(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction$1(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject$5(value) ? objectToString$1.call(value) : '';
  return tag == funcTag$1 || tag == genTag$1;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength$1(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject$5(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike$1(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol$1(value) {
  return typeof value == 'symbol' ||
    (isObjectLike$1(value) && objectToString$1.call(value) == symbolTag$1);
}

/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function index_6bd0eeff_toString(value) {
  return value == null ? '' : baseToString(value);
}

/**
 * Checks if `path` is a direct or inherited property of `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path to check.
 * @returns {boolean} Returns `true` if `path` exists, else `false`.
 * @example
 *
 * var object = _.create({ 'a': _.create({ 'b': 2 }) });
 *
 * _.hasIn(object, 'a');
 * // => true
 *
 * _.hasIn(object, 'a.b');
 * // => true
 *
 * _.hasIn(object, ['a', 'b']);
 * // => true
 *
 * _.hasIn(object, 'b');
 * // => false
 */
function hasIn$1(object, path) {
  return object != null && hasPath(object, path, baseHasIn);
}

var lodash_hasin = hasIn$1;

var inspect$2 = {exports: {}};

/* istanbul ignore file */

(function (module, exports) {

	const isString = lodash_isstring,
	    isObject = lodash_isobject;

	/**
	 * Echos the value of a value. Trys to print the value out
	 * in the best way possible given the different types.
	 *
	 * @param {Object} obj The object to print out.
	 * @param {Object} opts Optional options object that alters the output.
	 * @returns {string}
	 */
	function inspect(obj, opts) {
	    /* eslint-disable prefer-rest-params */
	    // default options
	    const ctx = {
	        seen: [],
	        stylize: stylizeNoColor
	    };
	    // legacy...
	    if (arguments.length >= 3) ctx.depth = arguments[2];
	    if (arguments.length >= 4) ctx.colors = arguments[3];
	    if (isBoolean(opts)) {
	        // legacy...
	        ctx.showHidden = opts;
	    } else if (opts) {
	        // got an "options" object
	        exports._extend(ctx, opts);
	    }
	    // set default options
	    if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
	    if (isUndefined(ctx.depth)) ctx.depth = 2;
	    if (isUndefined(ctx.colors)) ctx.colors = false;
	    if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
	    if (ctx.colors) ctx.stylize = stylizeWithColor;
	    return formatValue(ctx, obj, ctx.depth);
	    /* eslint-enable prefer-rest-params */
	}

	module.exports = inspect;

	/* eslint-disable require-jsdoc */

	function stylizeNoColor(str) {
	    return str;
	}

	function stylizeWithColor(str, styleType) {
	    const style = inspect.styles[styleType];

	    if (style) {
	        return `\u001B[${inspect.colors[style][0]}m${str}\u001B[${inspect.colors[style][1]}m`;
	    }
	    return str;
	}

	// eslint-disable-next-line complexity, max-statements
	function formatValue(ctx, value, recurseTimes) {
	    // Provide a hook for user-specified inspect functions.
	    // Check that value is an object with an inspect function on it
	    if (
	        ctx.customInspect &&
	        value &&
	        isFunction(value.inspect) &&
	        // Filter out the util module, it's inspect function is special
	        value.inspect !== exports.inspect &&
	        // Also filter out any prototype objects using the circular check.
	        !(value.constructor && value.constructor.prototype === value)
	    ) {
	        let ret = value.inspect(recurseTimes, ctx);
	        if (!isString(ret)) {
	            ret = formatValue(ctx, ret, recurseTimes);
	        }
	        return ret;
	    }

	    // Primitive types cannot have properties
	    const primitive = formatPrimitive(ctx, value);
	    if (primitive) {
	        return primitive;
	    }

	    // Look up the keys of the object.
	    let keys = Object.keys(value);
	    const visibleKeys = arrayToHash(keys);

	    if (ctx.showHidden) {
	        keys = Object.getOwnPropertyNames(value);
	    }

	    // IE doesn't make error fields non-enumerable
	    // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
	    if (
	        isError(value) &&
	        (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)
	    ) {
	        return formatError(value);
	    }

	    // Some type of object without properties can be shortcutted.
	    if (keys.length === 0) {
	        if (isFunction(value)) {
	            const name = value.name ? `: ${value.name}` : '';
	            return ctx.stylize(`[Function${name}]`, 'special');
	        }
	        if (isRegExp(value)) {
	            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	        }
	        if (isDate(value)) {
	            return ctx.stylize(Date.prototype.toString.call(value), 'date');
	        }
	        if (isError(value)) {
	            return formatError(value);
	        }
	    }

	    let base = '',
	        array = false,
	        braces = ['{', '}'];

	    // Make Array say that they are Array
	    if (isArray(value)) {
	        array = true;
	        braces = ['[', ']'];
	    }

	    // Make functions say that they are functions
	    if (isFunction(value)) {
	        const n = value.name ? `: ${value.name}` : '';
	        base = ` [Function${n}]`;
	    }

	    // Make RegExps say that they are RegExps
	    if (isRegExp(value)) {
	        base = ` ${RegExp.prototype.toString.call(value)}`;
	    }

	    // Make dates with properties first say the date
	    if (isDate(value)) {
	        base = ` ${Date.prototype.toUTCString.call(value)}`;
	    }

	    // Make error with message first say the error
	    if (isError(value)) {
	        base = ` ${formatError(value)}`;
	    }

	    if (keys.length === 0 && (!array || value.length === 0)) {
	        return braces[0] + base + braces[1];
	    }

	    if (recurseTimes < 0) {
	        if (isRegExp(value)) {
	            return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
	        }
	        return ctx.stylize('[Object]', 'special');
	    }

	    ctx.seen.push(value);

	    let output;
	    if (array) {
	        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
	    } else {
	        output = keys.map(key =>
	            formatProperty(ctx, value, recurseTimes, visibleKeys, key, array)
	        );
	    }

	    ctx.seen.pop();

	    return reduceToSingleString(output, base, braces);
	}

	function isArray(ar) {
	    return Array.isArray(ar);
	}

	function isBoolean(arg) {
	    return typeof arg === 'boolean';
	}

	function isNull(arg) {
	    return arg === null;
	}

	function isNumber(arg) {
	    return typeof arg === 'number';
	}

	function isUndefined(arg) {
	    return arg === undefined;
	}

	function isRegExp(re) {
	    return isObject(re) && objectToString(re) === '[object RegExp]';
	}

	function isDate(d) {
	    return isObject(d) && objectToString(d) === '[object Date]';
	}

	function isError(e) {
	    return (
	        isObject(e) &&
	        (objectToString(e) === '[object Error]' || e instanceof Error)
	    );
	}

	function isFunction(arg) {
	    return typeof arg === 'function';
	}

	function arrayToHash(array) {
	    const hash = {};

	    array.forEach(val => {
	        hash[val] = true;
	    });

	    return hash;
	}

	function formatError(value) {
	    return `[${Error.prototype.toString.call(value)}]`;
	}

	// eslint-disable-next-line consistent-return
	function formatPrimitive(ctx, value) {
	    if (isUndefined(value)) return ctx.stylize('undefined', 'undefined');
	    if (isString(value)) {
	        const simple = `'${JSON.stringify(value)
	            .replace(/^"|"$/g, '')
	            .replace(/'/g, "\\'")
	            .replace(/\\"/g, '"')}'`;
	        return ctx.stylize(simple, 'string');
	    }
	    if (isNumber(value)) return ctx.stylize(`${value}`, 'number');
	    if (isBoolean(value)) return ctx.stylize(`${value}`, 'boolean');
	    // For some reason typeof null is "object", so special case here.
	    if (isNull(value)) return ctx.stylize('null', 'null');
	}

	function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
	    const output = [];
	    for (let i = 0, l = value.length; i < l; ++i) {
	        if (hasOwnProperty(value, String(i))) {
	            output.push(
	                formatProperty(
	                    ctx,
	                    value,
	                    recurseTimes,
	                    visibleKeys,
	                    String(i),
	                    true
	                )
	            );
	        } else {
	            output.push('');
	        }
	    }
	    keys.forEach(key => {
	        if (!key.match(/^\d+$/)) {
	            output.push(
	                formatProperty(ctx, value, recurseTimes, visibleKeys, key, true)
	            );
	        }
	    });
	    return output;
	}

	function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
	    let name, str;
	    const desc = Object.getOwnPropertyDescriptor(value, key) || {
	        value: value[key]
	    };
	    if (desc.get) {
	        if (desc.set) {
	            str = ctx.stylize('[Getter/Setter]', 'special');
	        } else {
	            str = ctx.stylize('[Getter]', 'special');
	        }
	    } else if (desc.set) {
	        str = ctx.stylize('[Setter]', 'special');
	    }
	    if (!hasOwnProperty(visibleKeys, key)) {
	        name = `[${key}]`;
	    }
	    if (!str) {
	        if (ctx.seen.indexOf(desc.value) < 0) {
	            if (isNull(recurseTimes)) {
	                str = formatValue(ctx, desc.value, null);
	            } else {
	                str = formatValue(ctx, desc.value, recurseTimes - 1);
	            }
	            if (str.indexOf('\n') > -1) {
	                if (array) {
	                    str = str
	                        .split('\n')
	                        .map(line => `  ${line}`)
	                        .join('\n')
	                        .slice(2);
	                } else {
	                    str = `\n${str
	                        .split('\n')
	                        .map(line => `   ${line}`)
	                        .join('\n')}`;
	                }
	            }
	        } else {
	            str = ctx.stylize('[Circular]', 'special');
	        }
	    }
	    if (isUndefined(name)) {
	        if (array && key.match(/^\d+$/)) {
	            return str;
	        }
	        name = JSON.stringify(`${key}`);
	        if (name.match(/^"([a-zA-Z_]\w*)"$/)) {
	            name = name.slice(1, -1);
	            name = ctx.stylize(name, 'name');
	        } else {
	            name = name
	                .replace(/'/g, "\\'")
	                .replace(/\\"/g, '"')
	                .replace(/(^"|"$)/g, "'");
	            name = ctx.stylize(name, 'string');
	        }
	    }

	    return `${name}: ${str}`;
	}

	function reduceToSingleString(output, base, braces) {
	    const length = output.reduce(
	        (prev, cur) =>
	            // eslint-disable-next-line no-control-regex
	            prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1,
	        0
	    );

	    if (length > 60) {
	        return `${braces[0] + (base === '' ? '' : `${base}\n `)} ${output.join(
	            ',\n  '
	        )} ${braces[1]}`;
	    }

	    return `${braces[0] + base} ${output.join(', ')} ${braces[1]}`;
	}

	function objectToString(o) {
	    return Object.prototype.toString.call(o);
	}

	/* eslint-enable require-jsdoc */ 
} (inspect$2, inspect$2.exports));

var inspectExports = inspect$2.exports;

const isEmpty$8 = lodash_isemptyExports,
    isNil$1d = lodash_isnil,
    isString$1 = lodash_isstring,
    isObject$4 = lodash_isobject,
    hasIn = lodash_hasin,
    has$c = lodash_has;

const inspect$1 = inspectExports;

/**
 * Check if the object is instance of class type
 *
 * @private
 * @param {Object} instance
 * @param {Class} type
 * @throws {TypeError} Object must be an instance of class type
 */
util.checkType = function checkType(instance, type) {
    if (!(instance instanceof type)) {
        if (isNil$1d(instance)) {
            console.warn(
                `Was expecting instance of ${type.name} but got ${instance}!`
            );
        } else
            console.warn(
                `${inspect$1(instance)} is of the type ${typeof instance}`
            );

        throw new TypeError(`Argument must be an instance of ${type.name}`);
    }
};

/**
 * Wrapper for calling constructor with given parameters
 *
 * @private
 * @param {function(new:T, ...*)} Cls The class constructor.
 * @returns {function(...*): T} Wrapper of the class constructor which creates an instance of given Class
 * @template T
 */
util.constructorWrapper = function constructorWrapper(Cls) {
    return (...args) => new Cls(...args);
};

/**
 * Check if the number is in the given range.
 * Returns `true` is number is less than or equal to min, max.
 *
 * @private
 * @param {number} num
 * @param {number} min
 * @param {number} max
 * @returns {boolean} `true` if in range, `false` otherwise
 */
function between(num, min, max) {
    return num >= min && num <= max;
}

/**
 * Finds and returns the first position of first digit in string
 *
 * @private
 * @param {string} str
 * @returns {number} Index of first digit in string.
 * `-1` if digit is not found in string
 */
util.firstDigitPos = function firstDigitPos(str) {
    if (isEmpty$8(str)) return -1;

    const len = str.length;
    for (let idx = 0; idx < len; idx++) {
        // '0'.charCodeAt(0) => 48
        // '9'.charCodeAt(0) => 57
        if (between(str.charCodeAt(idx), 48, 57)) return idx;
    }

    return -1;
};

/**
 * Convert class object to JSON by recursively calling `toJSON` on the class members.
 *
 * @private
 * @param {*} obj
 * @returns {Object} JSON representation of class.
 */
util.recursiveToJSON = function recursiveToJSON(obj) {
    // Strings, numbers, booleans
    if (!isObject$4(obj)) return obj;

    // Each element in array needs to be recursively JSONified
    if (Array.isArray(obj)) return obj.map(x => recursiveToJSON(x));

    // If it is a native object, we'll not get anything different by calling toJSON
    // If it is a custom object, toJSON needs to be called
    // Custom object toJSON might return any datatype
    // So let us handle it recursively
    if (hasIn(obj, 'toJSON') && obj.constructor !== Object) {
        return recursiveToJSON(obj.toJSON());
    }

    // Custom object toJSON or native object might have values which need to be JSONified
    const json = {};
    for (const key of Object.keys(obj)) {
        json[key] = recursiveToJSON(obj[key]);
    }

    return json;
};

/**
 * Helper function for creating function which will log warning and throw error
 * on receiving invalid parameter
 *
 * @private
 * @param {string} refUrl
 * @param {string} paramName
 * @param {*} validValues
 * @returns {function}
 */
util.invalidParam = function invalidParam(refUrl, paramName, validValues) {
    return (paramVal, referenceUrl = refUrl) => {
        referenceUrl && console.log(`See ${referenceUrl}`);
        console.warn(`Got '${paramName}' - '${paramVal}'`);

        const validValuesStr = isString$1(validValues)
            ? validValues
            : inspect$1(validValues);
        throw new Error(
            `The '${paramName}' parameter should be one of ${validValuesStr}`
        );
    };
};

/**
 * Set given default value on object if key is not present.
 *
 * @private
 * @param {Object} obj
 * @param {string} key
 * @param {*} value
 * @returns {boolean} `true` if the given object did not have `key` and `false` otherwise.
 */
util.setDefault = function setDefault(obj, key, value) {
    const itHasNot = !has$c(obj, key);
    if (itHasNot) obj[key] = value;
    return itHasNot;
};

const { recursiveToJSON: recursiveToJSON$e } = util;

/**
 * Base class implementation for all query types.
 *
 * **NOTE:** Instantiating this directly should not be required.
 * However, if you wish to add a custom implementation for whatever reason,
 * this class should be extended and used, as validation against the class
 * type is present in various places.
 *
 * @param {string} queryType
 */
let Query$w = class Query {
    // eslint-disable-next-line require-jsdoc
    constructor(queryType) {
        this.queryType = queryType;

        this._body = {};
        this._queryOpts = this._body[queryType] = {};
    }

    /**
     * Sets the boost value for documents matching the `Query`.
     *
     * @param {number} factor
     * @returns {Query} returns `this` so that calls can be chained.
     */
    boost(factor) {
        this._queryOpts.boost = factor;
        return this;
    }

    /**
     * Sets the query name.
     *
     * @example
     * const boolQry = esb.boolQuery()
     *     .should([
     *         esb.matchQuery('name.first', 'shay').name('first'),
     *         esb.matchQuery('name.last', 'banon').name('last')
     *     ])
     *     .filter(esb.termsQuery('name.last', ['banon', 'kimchy']).name('test'));
     *
     * @param {string} name
     * @returns {Query} returns `this` so that calls can be chained.
     */
    name(name) {
        this._queryOpts._name = name;
        return this;
    }

    /**
     * Build and returns DSL representation of the `Query` class instance.
     *
     * @returns {Object} returns an Object which maps to the elasticsearch query DSL
     */
    getDSL() {
        return this.toJSON();
    }

    /**
     * Override default `toJSON` to return DSL representation for the `query`
     *
     * @override
     * @returns {Object} returns an Object which maps to the elasticsearch query DSL
     */
    toJSON() {
        return recursiveToJSON$e(this._body);
    }
};

var query = Query$w;

const has$b = lodash_has;
const isEmpty$7 = lodash_isemptyExports;

const { checkType: checkType$O, recursiveToJSON: recursiveToJSON$d } = util;

/**
 * Base class implementation for all aggregation types.
 *
 * **NOTE:** Instantiating this directly should not be required.
 * However, if you wish to add a custom implementation for whatever reason,
 * this class should be extended and used, as validation against the class
 * type is present in various places.
 *
 * @param {string} name
 * @param {string} aggType Type of aggregation
 *
 * @throws {Error} if `name` is empty
 * @throws {Error} if `aggType` is empty
 */
let Aggregation$6 = class Aggregation {
    // eslint-disable-next-line require-jsdoc
    constructor(name, aggType) {
        if (isEmpty$7(aggType))
            throw new Error('Aggregation `aggType` cannot be empty');

        this._name = name;
        this.aggType = aggType;

        this._aggs = {};
        this._aggsDef = this._aggs[aggType] = {};
        this._nestedAggs = [];
    }

    // TODO: Investigate case when getter for aggregation will be required

    /**
     * Sets name for aggregation.
     *
     * @param {string} name returns `this` so that calls can be chained.
     * @returns {Aggregation}
     */
    name(name) {
        this._name = name;
        return this;
    }

    /**
     * Sets nested aggregations.
     * This method can be called multiple times in order to set multiple nested aggregations.
     *
     * @param {Aggregation} agg Any valid {@link Aggregation}
     * @returns {Aggregation} returns `this` so that calls can be chained.
     * @throws {TypeError} If `agg` is not an instance of `Aggregation`
     */
    aggregation(agg) {
        checkType$O(agg, Aggregation);

        // Possible to check for Global aggregation?
        // Global aggregation can only be at the top level.

        this._nestedAggs.push(agg);

        return this;
    }

    /**
     * Sets nested aggregation.
     * This method can be called multiple times in order to set multiple nested aggregations.
     *
     * @param {Aggregation} agg Any valid {@link Aggregation}
     * @returns {Aggregation} returns `this` so that calls can be chained.
     */
    agg(agg) {
        return this.aggregation(agg);
    }

    /**
     * Sets multiple nested aggregation items.
     * This method accepts an array to set multiple nested aggregations in one call.
     *
     * @param {Array<Aggregation>} aggs Array of valid {@link Aggregation} items
     * @returns {Aggregation} returns `this` so that calls can be chained.
     * @throws {TypeError} If `aggs` is not an instance of `Array`
     * @throws {TypeError} If `aggs` contains instances not of type `Aggregation`
     */
    aggregations(aggs) {
        checkType$O(aggs, Array);

        aggs.forEach(agg => this.aggregation(agg));

        return this;
    }

    /**
     * Sets multiple nested aggregation items.
     * Alias for method `aggregations`
     *
     * @param {Array<Aggregation>} aggs Array of valid {@link Aggregation} items
     * @returns {Aggregation} returns `this` so that calls can be chained.
     * @throws {TypeError} If `aggs` is not an instance of `Array`
     * @throws {TypeError} If `aggs` contains instances not of type `Aggregation`
     */
    aggs(aggs) {
        return this.aggregations(aggs);
    }

    /**
     * You can associate a piece of metadata with individual aggregations at request time
     * that will be returned in place at response time.
     *
     * @param {Object} meta
     * @returns {Aggregation} returns `this` so that calls can be chained.
     */
    meta(meta) {
        this._aggs.meta = meta;
        return this;
    }

    /**
     * Internal helper function for determining the aggregation name.
     *
     * @returns {string} Aggregation name
     * @private
     */
    _aggsName() {
        if (!isEmpty$7(this._name)) return this._name;

        if (has$b(this._aggsDef, 'field')) {
            return `agg_${this.aggType}_${this._aggsDef.field}`;
        }

        // At this point, it would be difficult to construct a unique
        // aggregation name. Error out.
        throw new Error('Aggregation name could not be determined');
    }

    /**
     * Build and returns DSL representation of the `Aggregation` class instance.
     *
     * @returns {Object} returns an Object which maps to the elasticsearch query DSL
     */
    getDSL() {
        return this.toJSON();
    }

    /**
     * Override default `toJSON` to return DSL representation for the `aggregation` query.
     *
     * @override
     * @returns {Object} returns an Object which maps to the elasticsearch query DSL
     */
    toJSON() {
        const mainAggs = recursiveToJSON$d(this._aggs);

        if (!isEmpty$7(this._nestedAggs)) {
            mainAggs.aggs = Object.assign(
                {},
                ...recursiveToJSON$d(this._nestedAggs)
            );
        }

        return { [this._aggsName()]: mainAggs };
    }
};

var aggregation = Aggregation$6;

const isNil$1c = lodash_isnil;

const isEmpty$6 = lodash_isemptyExports;

/**
 * Base class implementation for all suggester types.
 *
 * **NOTE:** Instantiating this directly should not be required.
 * However, if you wish to add a custom implementation for whatever reason,
 * this class should be extended and used, as validation against the class
 * type is present in various places.
 *
 * @param {string} suggesterType The type of suggester.
 * Can be one of `term`, `phrase`, `completion`
 * @param {string} name The name of the Suggester, an arbitrary identifier
 * @param {string=} field The field to fetch the candidate suggestions from.
 *
 * @throws {Error} if `name` is empty
 * @throws {Error} if `suggesterType` is empty
 */
let Suggester$3 = class Suggester {
    // eslint-disable-next-line require-jsdoc
    constructor(suggesterType, name, field) {
        if (isEmpty$6(suggesterType))
            throw new Error('Suggester `suggesterType` cannot be empty');
        if (isEmpty$6(name)) throw new Error('Suggester `name` cannot be empty');

        this.name = name;
        this.suggesterType = suggesterType;

        this._body = {};
        this._opts = this._body[name] = {};
        this._suggestOpts = this._opts[suggesterType] = {};

        if (!isNil$1c(field)) this._suggestOpts.field = field;
    }

    /**
     * Sets field to fetch the candidate suggestions from. This is a required option
     * that either needs to be set globally or per suggestion.
     *
     * @param {string} field a valid field name
     * @returns {Suggester} returns `this` so that calls can be chained
     */
    field(field) {
        this._suggestOpts.field = field;
        return this;
    }

    /**
     * Sets the number of suggestions to return (defaults to `5`).
     *
     * @param {number} size
     * @returns {Suggester} returns `this` so that calls can be chained.
     */
    size(size) {
        this._suggestOpts.size = size;
        return this;
    }

    /**
     * Override default `toJSON` to return DSL representation for the `suggester`
     *
     * @override
     * @returns {Object} returns an Object which maps to the elasticsearch DSL
     */
    toJSON() {
        return this._body;
    }
};

var suggester = Suggester$3;

var consts = {};

// Used in Fiversified Sampler aggrenation
consts.EXECUTION_HINT_SET = new Set([
    'map',
    'global_ordinals',
    'global_ordinals_hash',
    'global_ordinals_low_cardinality'
]);

// Used in Geo Point Aggregation
// prettier-ignore
consts.UNIT_SET = new Set(
    [
        'in', 'inch',
        'yd', 'yards',
        'ft', 'feet',
        'km', 'kilometers',
        'NM', 'nmi', 'nauticalmiles',
        'mm', 'millimeters',
        'cm', 'centimeters',
        'mi', 'miles',
        'm', 'meters'
    ]
);

consts.MODEL_SET = new Set([
    'simple',
    'linear',
    'ewma',
    'holt',
    'holt_winters'
]);

consts.SORT_MODE_SET = new Set(['min', 'max', 'sum', 'avg', 'median']);

consts.RESCORE_MODE_SET = new Set(['total', 'multiply', 'min', 'max', 'avg']);

consts.REWRITE_METHOD_SET = new Set([
    'constant_score',
    'constant_score_auto',
    'constant_score_filter',
    'scoring_boolean',
    'constant_score_boolean',
    'top_terms_N',
    'top_terms_boost_N',
    'top_terms_blended_freqs_N'
]);

consts.MULTI_MATCH_TYPE = new Set([
    'best_fields',
    'most_fields',
    'cross_fields',
    'phrase',
    'phrase_prefix',
    'bool_prefix'
]);

consts.SCORE_MODE_SET = new Set([
    'multiply',
    'sum',
    'first',
    'min',
    'max',
    'avg'
]);

consts.BOOST_MODE_SET = new Set([
    'multiply',
    'sum',
    'replace',
    'min',
    'max',
    'avg'
]);

consts.FIELD_MODIFIER_SET = new Set([
    'none',
    'log',
    'log1p',
    'log2p',
    'ln',
    'ln1p',
    'ln2p',
    'square',
    'sqrt',
    'reciprocal'
]);

consts.NESTED_SCORE_MODE_SET = new Set(['none', 'sum', 'min', 'max', 'avg']);

consts.GEO_SHAPE_TYPES = new Set([
    'point',
    'linestring',
    'polygon',
    'multipoint',
    'multilinestring',
    'multipolygon',
    'geometrycollection',
    'envelope',
    'circle'
]);

consts.GEO_RELATION_SET = new Set([
    'WITHIN',
    'CONTAINS',
    'DISJOINT',
    'INTERSECTS'
]);

consts.SUGGEST_MODE_SET = new Set(['missing', 'popular', 'always']);

consts.STRING_DISTANCE_SET = new Set([
    'internal',
    'damerau_levenshtein',
    'levenstein',
    'jarowinkler',
    'ngram'
]);

consts.SMOOTHING_MODEL_SET = new Set([
    'stupid_backoff',
    'laplace',
    'linear_interpolation'
]);

const isNil$1b = lodash_isnil;

const Query$v = query;
const { checkType: checkType$N, invalidParam: invalidParam$r, recursiveToJSON: recursiveToJSON$c } = util;
const { RESCORE_MODE_SET } = consts;

const ES_REF_URL$14 =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-rescore.html';

const invalidScoreModeParam$2 = invalidParam$r(
    ES_REF_URL$14,
    'score_mode',
    RESCORE_MODE_SET
);

/**
 * A `rescore` request can help to improve precision by reordering just
 * the top (eg 100 - 500) documents returned by the `query` and `post_filter`
 * phases, using a secondary (usually more costly) algorithm, instead of
 * applying the costly algorithm to all documents in the index.
 *
 * The rescore phase is not executed when sort is used.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-rescore.html)
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .query(esb.matchQuery('message', 'the quick brown').operator('or'))
 *     .rescore(
 *         esb.rescore(
 *             50,
 *             esb.matchPhraseQuery('message', 'the quick brown').slop(2)
 *         )
 *             .queryWeight(0.7)
 *             .rescoreQueryWeight(1.2)
 *     );
 *
 * @example
 * const rescore = esb.rescore(
 *     10,
 *     esb.functionScoreQuery().function(
 *         esb.scriptScoreFunction(
 *             esb.script('inline', 'Math.log10(doc.likes.value + 2)')
 *         )
 *     )
 * ).scoreMode('multiply');
 *
 * @param {number=} windowSize
 * @param {Query=} rescoreQuery
 */
let Rescore$2 = class Rescore {
    // eslint-disable-next-line require-jsdoc
    constructor(windowSize, rescoreQuery) {
        this._body = {};
        this._rescoreOpts = this._body.query = {};

        if (!isNil$1b(windowSize)) this._body.window_size = windowSize;
        if (!isNil$1b(rescoreQuery)) this.rescoreQuery(rescoreQuery);
    }

    /**
     * The number of docs which will be examined on each shard can be controlled
     * by the window_size parameter, which defaults to `from` and `size`.
     *
     * @param {number} windowSize
     * @returns {Rescore} returns `this` so that calls can be chained.
     */
    windowSize(windowSize) {
        this._body.window_size = windowSize;
        return this;
    }

    /**
     * The query to execute on the Top-K results by the `query` and `post_filter` phases.
     *
     * @param {Query} rescoreQuery
     * @returns {Rescore} returns `this` so that calls can be chained.
     * @throws {TypeError} If `rescoreQuery` is not an instance of `Query`
     */
    rescoreQuery(rescoreQuery) {
        checkType$N(rescoreQuery, Query$v);

        this._rescoreOpts.rescore_query = rescoreQuery;
        return this;
    }

    /**
     * Control the relative importance of the original query.
     *
     * @param {number} weight Defaults to 1
     * @returns {Rescore} returns `this` so that calls can be chained.
     */
    queryWeight(weight) {
        this._rescoreOpts.query_weight = weight;
        return this;
    }

    /**
     * Control the relative importance of the rescore query.
     *
     * @param {number} weight Defaults to 1
     * @returns {Rescore} returns `this` so that calls can be chained.
     */
    rescoreQueryWeight(weight) {
        this._rescoreOpts.rescore_query_weight = weight;
        return this;
    }

    /**
     * Controls the way the scores are combined.
     *
     * @param {string} mode Can be one of `total`, `multiply`, `min`, `max`, `avg`.
     * Defaults to `total`.
     * @returns {Rescore} returns `this` so that calls can be chained.
     */
    scoreMode(mode) {
        if (isNil$1b(mode)) invalidScoreModeParam$2(mode);

        const modeLower = mode.toLowerCase();
        if (!RESCORE_MODE_SET.has(modeLower)) {
            invalidScoreModeParam$2(mode);
        }

        this._rescoreOpts.score_mode = modeLower;
        return this;
    }

    /**
     * Override default `toJSON` to return DSL representation for `rescore` request
     *
     * @override
     * @returns {Object} returns an Object which maps to the elasticsearch query DSL
     */
    toJSON() {
        return recursiveToJSON$c(this._body);
    }
};

var rescore$2 = Rescore$2;

const isNil$1a = lodash_isnil;

/**
 * Class supporting the Elasticsearch scripting API.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting-using.html)
 *
 * Note: `inline` script type was deprecated in [elasticsearch v5.0](https://www.elastic.co/guide/en/elasticsearch/reference/5.6/breaking_50_scripting.html).
 * `source` should be used instead. And similarly for `stored` scripts, type
 * `id` must be used instead. `file` scripts were removed as part of the
 * breaking changes in [elasticsearch v6.0](https://www.elastic.co/guide/en/elasticsearch/reference/6.0/breaking_60_scripting_changes.html#_file_scripts_removed)
 *
 * @param {string=} type One of `inline`, `stored`, `file`, `source`, `id`.
 * @param {string=} source Source of the script.
 * This needs to be specified if optional argument `type` is passed.
 *
 * @example
 * const script = esb.script('inline', "doc['my_field'] * multiplier")
 *     .lang('expression')
 *     .params({ multiplier: 2 });
 *
 * // cat "log(_score * 2) + my_modifier" > config/scripts/calculate-score.groovy
 * const script = esb.script()
 *     .lang('groovy')
 *     .file('calculate-score')
 *     .params({ my_modifier: 2 });
 */
let Script$6 = class Script {
    // eslint-disable-next-line require-jsdoc
    constructor(type, source) {
        this._isTypeSet = false;
        this._body = {};

        // NOTE: Script syntax changed in elasticsearch 5.6 to use `id`/`source`
        // instead of `inline`/`source`/`file`. This needs to be handled
        // somehow.
        if (!isNil$1a(type) && !isNil$1a(source)) {
            const typeLower = type.toLowerCase();

            switch (typeLower) {
                case 'inline':
                    this.inline(source);
                    break;

                case 'source':
                    this.source(source);
                    break;

                case 'stored':
                    this.stored(source);
                    break;

                case 'id':
                    this.id(source);
                    break;

                case 'file':
                    this.file(source);
                    break;

                default:
                    throw new Error(
                        '`type` must be one of `inline`, `stored`, `file`'
                    );
            }
        }
    }

    /**
     * Print warning message to console namespaced by class name.
     *
     * @param {string} msg
     * @private
     */
    _warn(msg) {
        console.warn(`[Script] ${msg}`);
    }

    /**
     * Print warning messages to not mix `Script` source
     *
     * @private
     */
    _checkMixedRepr() {
        if (!this._isTypeSet) return;

        this._warn(
            'Script source(`inline`/`source`/`stored`/`id`/`file`) was already specified!'
        );
        this._warn('Overwriting.');

        delete this._body.inline;
        delete this._body.source;
        delete this._body.stored;
        delete this._body.id;
        delete this._body.file;
    }

    /**
     * Sets the type of script to be `inline` and specifies the source of the script.
     *
     * Note: This type was deprecated in elasticsearch v5.0. Use `source`
     * instead if you are using elasticsearch `>= 5.0`.
     *
     * @param {string} scriptCode
     * @returns {Script} returns `this` so that calls can be chained.
     */
    inline(scriptCode) {
        this._checkMixedRepr();

        this._body.inline = scriptCode;
        this._isTypeSet = true;
        return this;
    }

    /**
     * Sets the type of script to be `source` and specifies the source of the script.
     *
     * Note: `source` is an alias for the `inline` type which was deprecated
     * in elasticsearch v5.0. So this type is supported only in versions
     * `>= 5.0`.
     *
     * @param {string} scriptCode
     * @returns {Script} returns `this` so that calls can be chained.
     */
    source(scriptCode) {
        this._checkMixedRepr();

        this._body.source = scriptCode;
        this._isTypeSet = true;
        return this;
    }

    /**
     * Specify the `stored` script by `id` which will be retrieved from cluster state.
     *
     * Note: This type was deprecated in elasticsearch v5.0. Use `id`
     * instead if you are using elasticsearch `>= 5.0`.
     *
     * @param {string} scriptId The unique identifier for the stored script.
     * @returns {Script} returns `this` so that calls can be chained.
     */
    stored(scriptId) {
        this._checkMixedRepr();

        this._body.stored = scriptId;
        this._isTypeSet = true;
        return this;
    }

    /**
     * Specify the stored script to be used by it's `id` which will be retrieved
     * from cluster state.
     *
     * Note: `id` is an alias for the `stored` type which was deprecated in
     * elasticsearch v5.0. So this type is supported only in versions `>= 5.0`.
     *
     * @param {string} scriptId The unique identifier for the stored script.
     * @returns {Script} returns `this` so that calls can be chained.
     */
    id(scriptId) {
        this._checkMixedRepr();

        this._body.id = scriptId;
        this._isTypeSet = true;
        return this;
    }

    /**
     * Specify the `file` script by stored as a file in the scripts folder.
     *
     * Note: File scripts have been removed in elasticsearch 6.0. Instead, use
     * stored scripts.
     *
     * @param {string} fileName The name of the script stored as a file in the scripts folder.
     * For script file `config/scripts/calculate-score.groovy`,
     * `fileName` should be `calculate-score`
     * @returns {Script} returns `this` so that calls can be chained.
     */
    file(fileName) {
        this._checkMixedRepr();

        this._body.file = fileName;
        this._isTypeSet = true;
        return this;
    }

    /**
     * Specifies the language the script is written in. Defaults to `painless` but
     * may be set to any of languages listed in [Scripting](https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-scripting.html).
     * The default language may be changed in the `elasticsearch.yml` config file by setting
     * `script.default_lang` to the appropriate language.
     *
     * For a `file` script,  it should correspond with the script file suffix.
     * `groovy` for `config/scripts/calculate-score.groovy`.
     *
     * Note: The Groovy, JavaScript, and Python scripting languages were
     * deprecated in elasticsearch 5.0 and removed in 6.0. Use painless instead.
     *
     * @param {string} lang The language for the script.
     * @returns {Script} returns `this` so that calls can be chained.
     */
    lang(lang) {
        this._body.lang = lang;
        return this;
    }

    /**
     * Specifies any named parameters that are passed into the script as variables.
     *
     * @param {Object} params Named parameters to be passed to script.
     * @returns {Script} returns `this` so that calls can be chained.
     */
    params(params) {
        this._body.params = params;
        return this;
    }

    /**
     * Override default `toJSON` to return DSL representation for the `script`.
     *
     * @override
     * @returns {Object} returns an Object which maps to the elasticsearch query DSL
     */
    toJSON() {
        // recursiveToJSON doesn't seem to be needed here
        return this._body;
    }
};

var script$2 = Script$6;

const isEmpty$5 = lodash_isemptyExports;
const has$a = lodash_has;
const isNil$19 = lodash_isnil;

const Query$u = query;
const Script$5 = script$2;
const { checkType: checkType$M, invalidParam: invalidParam$q, recursiveToJSON: recursiveToJSON$b } = util;
const { SORT_MODE_SET, UNIT_SET: UNIT_SET$1 } = consts;

const ES_REF_URL$13 =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-sort.html';

const invalidOrderParam$1 = invalidParam$q(ES_REF_URL$13, 'order', "'asc' or 'desc'");
const invalidModeParam$1 = invalidParam$q(ES_REF_URL$13, 'mode', SORT_MODE_SET);
const invalidDistanceTypeParam$2 = invalidParam$q(
    ES_REF_URL$13,
    'distance_type',
    "'plane' or 'arc'"
);
const invalidUnitParam$1 = invalidParam$q(ES_REF_URL$13, 'unit', UNIT_SET$1);

/**
 * Allows creating and configuring sort on specified field.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-sort.html)
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .query(esb.termQuery('user', 'kimchy'))
 *     .sort(esb.sort('post_date', 'asc'))
 *
 * @param {string=} field The field to sort on.
 * If a script is used to specify the sort order, `field` should be omitted.
 * @param {string=} order The `order` option can have the following values.
 * `asc`, `desc` to sort in ascending, descending order respectively.
 */
let Sort$4 = class Sort {
    // eslint-disable-next-line require-jsdoc
    constructor(field, order) {
        this._opts = {};
        this._geoPoint = null;
        this._script = null;

        if (!isNil$19(field)) this._field = field;
        if (!isNil$19(order)) this.order(order);
    }

    /**
     * Set order for sorting. The order defaults to `desc` when sorting on the `_score`,
     * and defaults to `asc` when sorting on anything else.
     *
     * @param {string} order The `order` option can have the following values.
     * `asc`, `desc` to sort in ascending, descending order respectively.
     * @returns {Sort} returns `this` so that calls can be chained.
     */
    order(order) {
        if (isNil$19(order)) invalidOrderParam$1(order);

        const orderLower = order.toLowerCase();
        if (orderLower !== 'asc' && orderLower !== 'desc') {
            invalidOrderParam$1(order);
        }

        this._opts.order = orderLower;
        return this;
    }

    /**
     * Elasticsearch supports sorting by array or multi-valued fields.
     * The `mode` option controls what array value is picked for sorting the
     * document it belongs to.
     *
     * The `mode` option can have the following values:
     *
     * - `min` - Pick the lowest value.
     * - `max` - Pick the highest value.
     * - `sum` - Use the sum of all values as sort value.
     *   Only applicable for number based array fields.
     * - `avg` - Use the average of all values as sort value.
     *   Only applicable for number based array fields.
     * - `median` - Use the median of all values as sort value.
     *   Only applicable for number based array fields.
     *
     * @example
     * const sort = esb.sort('price', 'asc').mode('avg');
     *
     * @param {string} mode One of `avg`, `min`, `max`, `sum` and `median`.
     * @returns {Sort} returns `this` so that calls can be chained.
     */
    mode(mode) {
        if (isNil$19(mode)) invalidModeParam$1(mode);

        const modeLower = mode.toLowerCase();
        if (!SORT_MODE_SET.has(modeLower)) {
            invalidModeParam$1(mode);
        }

        this._opts.mode = modeLower;
        return this;
    }

    /**
     * Defines on which nested object to sort. The actual sort field must be a direct
     * field inside this nested object. When sorting by nested field, this field
     * is mandatory.
     *
     * Note: This method has been deprecated in elasticsearch 6.1. From 6.1 and
     * later, use `nested` method instead.
     *
     * @example
     * const sort = esb.sort('offer.price', 'asc')
     *     .nestedPath('offer')
     *     .nestedFilter(esb.termQuery('offer.color', 'blue'));
     *
     * @param {string} path Nested object to sort on
     * @returns {Sort} returns `this` so that calls can be chained.
     */
    nestedPath(path) {
        this._opts.nested_path = path;
        return this;
    }

    /**
     * A filter that the inner objects inside the nested path should match with in order
     * for its field values to be taken into account by sorting. By default no
     * `nested_filter` is active.
     *
     * Note: This method has been deprecated in elasticsearch 6.1. From 6.1 and
     * later, use `nested` method instead.
     *
     * @example
     * const sort = esb.sort('offer.price', 'asc')
     *     .nestedPath('offer')
     *     .nestedFilter(esb.termQuery('offer.color', 'blue'));
     *
     * @param {Query} filterQuery Filter query
     * @returns {Sort} returns `this` so that calls can be chained.
     * @throws {TypeError} If filter query is not an instance of `Query`
     */
    nestedFilter(filterQuery) {
        checkType$M(filterQuery, Query$u);

        this._opts.nested_filter = filterQuery;
        return this;
    }

    /**
     * Defines on which nested object to sort and the filter that the inner objects inside
     * the nested path should match with in order for its field values to be taken into
     * account by sorting
     *
     * Note: This method is incompatible with elasticsearch 6.0 and older.
     * Use it only with elasticsearch 6.1 and later.
     *
     * @example
     * const sort = esb.sort('offer.price', 'asc')
     *     .nested({
     *          path: 'offer',
     *          filter: esb.termQuery('offer.color', 'blue')
     *      });
     *
     * @param {Object} nested Nested config that contains path and filter
     * @param {string} nested.path Nested object to sort on
     * @param {Query} nested.filter Filter query
     * @returns {Sort} returns `this` so that calls can be chained.
     * @throws {TypeError} If filter query is not an instance of `Query`
     */
    nested(nested) {
        const { filter } = nested;
        if (!isNil$19(filter)) checkType$M(filter, Query$u);

        this._opts.nested = nested;
        return this;
    }

    /**
     * The missing parameter specifies how docs which are missing the field should
     * be treated: The missing value can be set to `_last`, `_first`, or a custom value
     * (that will be used for missing docs as the sort value). The default is `_last`.
     *
     * @example
     * const sort = esb.sort('price').missing('_last');
     *
     * @param {string|number} value
     * @returns {Sort} returns `this` so that calls can be chained.
     */
    missing(value) {
        this._opts.missing = value;
        return this;
    }

    /**
     * By default, the search request will fail if there is no mapping associated with
     * a field. The `unmapped_type` option allows to ignore fields that have no mapping
     * and not sort by them. The value of this parameter is used to determine what sort
     * values to emit.
     *
     * @example
     * const sort = esb.sort('price').unmappedType('long');
     *
     * @param {string} type
     * @returns {Sort} returns `this` so that calls can be chained.
     */
    unmappedType(type) {
        this._opts.unmapped_type = type;
        return this;
    }

    /**
     * Sorts documents by distance of the geo point field from reference point.
     * If multiple reference points are specified, the final distance for a
     * document will then be `min`/`max`/`avg` (defined via `mode`) distance of all
     * points contained in the document to all points given in the sort request.
     *
     * @example
     * const sort = esb.sort('pin.location', 'asc')
     *     .geoDistance([-70, 40])
     *     .unit('km')
     *     .mode('min')
     *     .distanceType('arc');
     *
     * @param {GeoPoint|Object|Array|string} geoPoint Reference point or array of
     * points to calculate distance from. Can be expressed using the `GeoPoint` class,
     * `Object` with `lat`, `lon` keys, as a string either `lat,lon` or geohash
     * or as Array with GeoJSON format `[lon, lat]`
     * @returns {Sort} returns `this` so that calls can be chained.
     */
    geoDistance(geoPoint) {
        this._geoPoint = geoPoint;
        return this;
    }

    /**
     * Sets the distance calculation mode, `arc` or `plane`.
     * The `arc` calculation is the more accurate.
     * The `plane` is the faster but least accurate.
     *
     * @param {string} type
     * @returns {Sort} returns `this` so that calls can be chained
     * @throws {Error} If `type` is neither `plane` nor `arc`.
     */
    distanceType(type) {
        if (isNil$19(type)) invalidDistanceTypeParam$2(type);

        const typeLower = type.toLowerCase();
        if (typeLower !== 'plane' && typeLower !== 'arc') {
            invalidDistanceTypeParam$2(type);
        }

        this._opts.distance_type = typeLower;
        return this;
    }

    /**
     * Sets the distance unit.  Valid values are:
     * mi (miles), in (inches), yd (yards),
     * km (kilometers), cm (centimeters), mm (millimeters),
     * ft(feet), NM(nauticalmiles)
     *
     * @param {string} unit Distance unit, default is `m`(meters).
     * @returns {Sort} returns `this` so that calls can be chained
     * @throws {Error} If Unit is outside the accepted set.
     */
    unit(unit) {
        if (!UNIT_SET$1.has(unit)) {
            invalidUnitParam$1(unit);
        }

        this._opts.unit = unit;
        return this;
    }

    /**
     * Sorts based on custom script. When sorting on a field, scores are not computed.
     *
     * @example
     * const sort = esb.sort()
     *    .type('number')
     *    .script(
     *        esb.script('inline', "doc['field_name'].value * params.factor")
     *            .lang('painless')
     *            .params({ factor: 1.1 })
     *    )
     *    .order('asc');
     *
     * @param {Script} script
     * @returns {Sort} returns `this` so that calls can be chained
     * @throws {TypeError} If `script` is not an instance of `Script`
     */
    script(script) {
        checkType$M(script, Script$5);

        this._script = script;
        return this;
    }

    /**
     * Sets the data type for field generated by script.
     *
     * @param {string} type
     * @returns {Sort} returns `this` so that calls can be chained
     */
    type(type) {
        this._opts.type = type;
        return this;
    }

    /**
     * Reverse the sort order. Valid during sort types: field, geo distance, and script.
     *
     * @param {boolean} reverse If sort should be in reverse order.
     * @returns {Sort} returns `this` so that calls can be chained
     */
    reverse(reverse) {
        this._opts.reverse = reverse;
        return this;
    }

    /**
     * Override default `toJSON` to return DSL representation for `sort` parameter.
     *
     * @override
     * @returns {Object|string} returns an Object which maps to the elasticsearch query DSL
     */
    toJSON() {
        const geoPointIsNil = isNil$19(this._geoPoint);
        const scriptIsNil = isNil$19(this._script);

        if (geoPointIsNil && scriptIsNil) {
            if (isEmpty$5(this._opts)) return this._field;

            if (
                Object.keys(this._opts).length === 1 &&
                has$a(this._opts, 'order')
            ) {
                return { [this._field]: this._opts.order };
            }
        }

        let repr;

        // Should I pick only the accepted properties here?
        if (!geoPointIsNil) {
            repr = {
                _geo_distance: Object.assign(
                    { [this._field]: this._geoPoint },
                    this._opts
                )
            };
        } else if (!scriptIsNil) {
            repr = {
                _script: Object.assign({ script: this._script }, this._opts)
            };
        } else {
            repr = { [this._field]: this._opts };
        }

        return recursiveToJSON$b(repr);
    }
};

var sort$2 = Sort$4;

const has$9 = lodash_has,
    isEmpty$4 = lodash_isemptyExports,
    isNil$18 = lodash_isnil,
    isString = lodash_isstring;

const Query$t = query;
const { checkType: checkType$L, invalidParam: invalidParam$p, recursiveToJSON: recursiveToJSON$a } = util;

const ES_REF_URL$12 =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-highlighting.html';

const invalidEncoderParam = invalidParam$p(
    ES_REF_URL$12,
    'encoder',
    "'default' or 'html'"
);
const invalidTypeParam$3 = invalidParam$p(
    ES_REF_URL$12,
    'type',
    "'plain', 'postings' or 'fvh'"
);
const invalidFragmenterParam = invalidParam$p(
    ES_REF_URL$12,
    'fragmenter',
    "'simple' or 'span'"
);

/**
 * Allows to highlight search results on one or more fields. In order to
 * perform highlighting, the actual content of the field is required. If the
 * field in question is stored (has store set to yes in the mapping), it will
 * be used, otherwise, the actual _source will be loaded and the relevant
 * field will be extracted from it.
 *
 * If no term_vector information is provided (by setting it to
 * `with_positions_offsets` in the mapping), then the plain highlighter will be
 * used. If it is provided, then the fast vector highlighter will be used.
 * When term vectors are available, highlighting will be performed faster at
 * the cost of bigger index size.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-highlighting.html)
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .query(esb.matchAllQuery())
 *     .highlight(esb.highlight('content'));
 *
 * @example
 * const highlight = esb.highlight()
 *     .numberOfFragments(3)
 *     .fragmentSize(150)
 *     .fields(['_all', 'bio.title', 'bio.author', 'bio.content'])
 *     .preTags('<em>', '_all')
 *     .postTags('</em>', '_all')
 *     .numberOfFragments(0, 'bio.title')
 *     .numberOfFragments(0, 'bio.author')
 *     .numberOfFragments(5, 'bio.content')
 *     .scoreOrder('bio.content');
 *
 * highlight.toJSON()
 * {
 *     "number_of_fragments" : 3,
 *     "fragment_size" : 150,
 *     "fields" : {
 *         "_all" : { "pre_tags" : ["<em>"], "post_tags" : ["</em>"] },
 *         "bio.title" : { "number_of_fragments" : 0 },
 *         "bio.author" : { "number_of_fragments" : 0 },
 *         "bio.content" : { "number_of_fragments" : 5, "order" : "score" }
 *     }
 *  }
 *
 * @param {string|Array=} fields An optional field or array of fields to highlight.
 */
let Highlight$4 = class Highlight {
    // eslint-disable-next-line require-jsdoc
    constructor(fields) {
        this._fields = {};
        this._highlight = { fields: this._fields };

        // Does this smell?
        if (isNil$18(fields)) return;

        if (isString(fields)) this.field(fields);
        else this.fields(fields);
    }

    /**
     * Private function to set field option
     *
     * @param {string|null} field
     * @param {string} option
     * @param {string} val
     * @private
     */
    _setFieldOption(field, option, val) {
        if (isNil$18(field)) {
            this._highlight[option] = val;
            return;
        }

        this.field(field);
        this._fields[field][option] = val;
    }

    /**
     * Allows you to set a field that will be highlighted. The field is
     * added to the current list of fields.
     *
     * @param {string} field A field name.
     * @returns {Highlight} returns `this` so that calls can be chained
     */
    field(field) {
        if (!isNil$18(field) && !has$9(this._fields, field)) {
            this._fields[field] = {};
        }

        return this;
    }

    /**
     * Allows you to set the fields that will be highlighted. All fields are
     * added to the current list of fields.
     *
     * @param {Array<string>} fields Array of field names.
     * @returns {Highlight} returns `this` so that calls can be chained
     * @throws {TypeError} If `fields` is not an instance of Array
     */
    fields(fields) {
        checkType$L(fields, Array);

        fields.forEach(field => this.field(field));
        return this;
    }

    /**
     * Sets the pre tags for highlighted fragments. You can apply the
     * tags to a specific field by passing the optional field name parameter.
     *
     * @example
     * const highlight = esb.highlight('_all')
     *     .preTags('<tag1>')
     *     .postTags('</tag1>');
     *
     * @example
     * const highlight = esb.highlight('_all')
     *     .preTags(['<tag1>', '<tag2>'])
     *     .postTags(['</tag1>', '</tag2>']);
     *
     * @param {string|Array} tags
     * @param {string=} field
     * @returns {Highlight} returns `this` so that calls can be chained
     */
    preTags(tags, field) {
        this._setFieldOption(field, 'pre_tags', isString(tags) ? [tags] : tags);
        return this;
    }

    /**
     * Sets the post tags for highlighted fragments. You can apply the
     * tags to a specific field by passing the optional field name parameter.
     *
     * @example
     * const highlight = esb.highlight('_all')
     *     .preTags('<tag1>')
     *     .postTags('</tag1>');
     *
     * @example
     * const highlight = esb.highlight('_all')
     *     .preTags(['<tag1>', '<tag2>'])
     *     .postTags(['</tag1>', '</tag2>']);
     *
     * @param {string|Array} tags
     * @param {string=} field
     * @returns {Highlight} returns `this` so that calls can be chained
     */
    postTags(tags, field) {
        this._setFieldOption(
            field,
            'post_tags',
            isString(tags) ? [tags] : tags
        );
        return this;
    }

    /**
     * Sets the styled schema to be used for the tags.
     *
     * styled - 10 `<em>` pre tags with css class of hltN, where N is 1-10
     *
     * @example
     * const highlight = esb.highlight('content').styledTagsSchema();
     *
     * @returns {Highlight} returns `this` so that calls can be chained
     */
    styledTagsSchema() {
        // This is a special case as it does not map directly to elasticsearch DSL
        // This is written this way for ease of use
        this._highlight.tags_schema = 'styled';
        return this;
    }

    /**
     * Sets the order of highlight fragments to be sorted by score. You can apply the
     * score order to a specific field by passing the optional field name parameter.
     *
     * @example
     * const highlight = esb.highlight('content').scoreOrder()
     *
     * @param {string=} field An optional field name
     * @returns {Highlight} returns `this` so that calls can be chained
     */
    scoreOrder(field) {
        // This is a special case as it does not map directly to elasticsearch DSL
        // It is written this way for ease of use
        this._setFieldOption(field, 'order', 'score');
        return this;
    }

    /**
     * Sets the size of each highlight fragment in characters. You can apply the
     * option to a specific field by passing the optional field name parameter.
     *
     * @example
     * const highlight = esb.highlight('content')
     *     .fragmentSize(150, 'content')
     *     .numberOfFragments(3, 'content');
     *
     * @param {number} size The fragment size in characters. Defaults to 100.
     * @param {string=} field An optional field name
     * @returns {Highlight} returns `this` so that calls can be chained
     */
    fragmentSize(size, field) {
        this._setFieldOption(field, 'fragment_size', size);
        return this;
    }
    /**
     * Sets the maximum number of fragments to return. You can apply the
     * option to a specific field by passing the optional field name parameter.
     *
     * @example
     * const highlight = esb.highlight('content')
     *     .fragmentSize(150, 'content')
     *     .numberOfFragments(3, 'content');
     *
     * @example
     * const highlight = esb.highlight(['_all', 'bio.title'])
     *     .numberOfFragments(0, 'bio.title');
     *
     * @param {number} count The maximum number of fragments to return
     * @param {string=} field An optional field name
     * @returns {Highlight} returns `this` so that calls can be chained
     */
    numberOfFragments(count, field) {
        this._setFieldOption(field, 'number_of_fragments', count);
        return this;
    }

    /**
     * If `no_match_size` is set, in the case where there is no matching fragment
     * to highlight, a snippet of text, with the specified length, from the beginning
     * of the field will be returned.
     *
     * The actual length may be shorter than specified as it tries to break on a word boundary.
     *
     * Default is `0`.
     *
     * @example
     * const highlight = esb.highlight('content')
     *     .fragmentSize(150, 'content')
     *     .numberOfFragments(3, 'content')
     *     .noMatchSize(150, 'content');
     *
     * @param {number} size
     * @param {string} field
     * @returns {Highlight} returns `this` so that calls can be chained
     */
    noMatchSize(size, field) {
        this._setFieldOption(field, 'no_match_size', size);
        return this;
    }

    /**
     * Highlight against a query other than the search query.
     * Useful if you use a rescore query because those
     * are not taken into account by highlighting by default.
     *
     * @example
     * const highlight = esb.highlight('content')
     *     .fragmentSize(150, 'content')
     *     .numberOfFragments(3, 'content')
     *     .highlightQuery(
     *         esb.boolQuery()
     *             .must(esb.matchQuery('content', 'foo bar'))
     *             .should(
     *                 esb.matchPhraseQuery('content', 'foo bar').slop(1).boost(10)
     *             )
     *             .minimumShouldMatch(0),
     *         'content'
     *     );
     *
     * @param {Query} query
     * @param {string=} field An optional field name
     * @returns {Highlight} returns `this` so that calls can be chained
     * @throws {TypeError} If `query` is not an instance of `Query`
     */
    highlightQuery(query, field) {
        checkType$L(query, Query$t);

        this._setFieldOption(field, 'highlight_query', query);
        return this;
    }

    /**
     * Combine matches on multiple fields to highlight a single field.
     * Useful for multifields that analyze the same string in different ways.
     * Sets the highlight type to Fast Vector Highlighter(`fvh`).
     *
     * @example
     * const highlight = esb.highlight('content')
     *     .scoreOrder('content')
     *     .matchedFields(['content', 'content.plain'], 'content');
     *
     * highlight.toJSON();
     * {
     *     "order": "score",
     *     "fields": {
     *         "content": {
     *             "matched_fields": ["content", "content.plain"],
     *             "type" : "fvh"
     *         }
     *     }
     * }
     *
     * @param {Array<string>} fields
     * @param {string} field Field name
     * @returns {Highlight} returns `this` so that calls can be chained
     * @throws {Error} field parameter should be valid field name
     * @throws {TypeError} If `fields` is not an instance of Array
     */
    matchedFields(fields, field) {
        checkType$L(fields, Array);
        if (isEmpty$4(field)) {
            throw new Error(
                '`matched_fields` requires field name to be passed'
            );
        }

        this.type('fvh', field);
        this._setFieldOption(field, 'matched_fields', fields);
        return this;
    }

    /**
     * The fast vector highlighter has a phrase_limit parameter that prevents
     * it from analyzing too many phrases and eating tons of memory. It defaults
     * to 256 so only the first 256 matching phrases in the document scored
     * considered. You can raise the limit with the phrase_limit parameter.
     *
     * If using `matched_fields`, `phrase_limit` phrases per matched field
     * are considered.
     *
     * @param {number} limit Defaults to 256.
     * @returns {Highlight} returns `this` so that calls can be chained
     */
    phraseLimit(limit) {
        this._highlight.phrase_limit = limit;
        return this;
    }

    /**
     * Can be used to define how highlighted text will be encoded.
     *
     * @param {string} encoder It can be either default (no encoding)
     * or `html` (will escape `html`, if you use html highlighting tags)
     * @returns {Highlight} returns `this` so that calls can be chained
     * @throws {Error} Encoder can be either `default` or `html`
     */
    encoder(encoder) {
        if (isNil$18(encoder)) invalidEncoderParam(encoder);

        const encoderLower = encoder.toLowerCase();
        if (encoderLower !== 'default' && encoderLower !== 'html') {
            invalidEncoderParam(encoder);
        }

        this._highlight.encoder = encoderLower;
        return this;
    }

    /**
     * By default only fields that hold a query match will be highlighted.
     * This can be set to false to highlight the field regardless of whether
     * the query matched specifically on them. You can apply the
     * option to a specific field by passing the optional field name parameter.
     *
     * @example
     * const highlight = esb.highlight('_all')
     *     .preTags('<em>', '_all')
     *     .postTags('</em>', '_all')
     *     .requireFieldMatch(false);
     *
     * @param {boolean} requireFieldMatch
     * @param {string=} field An optional field name
     * @returns {Highlight} returns `this` so that calls can be chained
     */
    requireFieldMatch(requireFieldMatch, field) {
        this._setFieldOption(field, 'require_field_match', requireFieldMatch);
        return this;
    }

    /**
     * Allows to control how far to look for boundary characters, and defaults to 20.
     * You can apply the option to a specific field by passing the optional field name parameter.
     *
     * @param {number} count The max characters to scan.
     * @param {string=} field An optional field name
     * @returns {Highlight} returns `this` so that calls can be chained
     */
    boundaryMaxScan(count, field) {
        this._setFieldOption(field, 'boundary_max_scan', count);
        return this;
    }

    /**
     * Defines what constitutes a boundary for highlighting.
     * It is a single string with each boundary character defined in it.
     * It defaults to `.,!? \t\n`. You can apply the
     * option to a specific field by passing the optional field name parameter.
     *
     * @param {string} charStr
     * @param {string=} field An optional field name
     * @returns {Highlight} returns `this` so that calls can be chained
     */
    boundaryChars(charStr, field) {
        this._setFieldOption(field, 'boundary_chars', charStr);
        return this;
    }

    /**
     * Allows to force a specific highlighter type.
     * This is useful for instance when needing to use
     * the plain highlighter on a field that has term_vectors enabled.
     * You can apply the option to a specific field by passing the optional
     * field name parameter.
     *
     * Note: The `postings` highlighter has been removed in elasticsearch 6.0.
     * The `unified` highlighter outputs the same highlighting when
     * `index_options` is set to `offsets`.
     *
     * @example
     * const highlight = esb.highlight('content').type('plain', 'content');
     *
     * @param {string} type The allowed values are: `plain`, `postings` and `fvh`.
     * @param {string=} field An optional field name
     * @returns {Highlight} returns `this` so that calls can be chained
     * @throws {Error} Type can be one of `plain`, `postings` or `fvh`.
     */
    type(type, field) {
        if (isNil$18(type)) invalidTypeParam$3(type);

        const typeLower = type.toLowerCase();
        if (
            typeLower !== 'plain' &&
            typeLower !== 'postings' &&
            typeLower !== 'fvh'
        ) {
            invalidTypeParam$3(type);
        }

        this._setFieldOption(field, 'type', typeLower);
        return this;
    }

    /**
     * Forces the highlighting to highlight fields based on the source
     * even if fields are stored separately. Defaults to false.
     *
     * @example
     * const highlight = esb.highlight('content').forceSource(true, 'content');
     *
     * @param {boolean} forceSource
     * @param {string=} field An optional field name
     * @returns {Highlight} returns `this` so that calls can be chained
     */
    forceSource(forceSource, field) {
        this._setFieldOption(field, 'force_source', forceSource);
        return this;
    }

    /**
     * Sets the fragmenter type. You can apply the
     * option to a specific field by passing the optional field name parameter.
     * Valid values for order are:
     *  - `simple` - breaks text up into same-size fragments with no concerns
     *      over spotting sentence boundaries.
     *  - `span` - breaks text up into same-size fragments but does not split
     *      up Spans.
     *
     * @example
     * const highlight = esb.highlight('message')
     *     .fragmentSize(15, 'message')
     *     .numberOfFragments(3, 'message')
     *     .fragmenter('simple', 'message');
     *
     * @param {string} fragmenter The fragmenter.
     * @param {string=} field An optional field name
     * @returns {Highlight} returns `this` so that calls can be chained
     * @throws {Error} Fragmenter can be either `simple` or `span`
     */
    fragmenter(fragmenter, field) {
        if (isNil$18(fragmenter)) invalidFragmenterParam(fragmenter);

        const fragmenterLower = fragmenter.toLowerCase();
        if (fragmenterLower !== 'simple' && fragmenterLower !== 'span') {
            invalidFragmenterParam(fragmenter);
        }

        this._setFieldOption(field, 'fragmenter', fragmenterLower);
        return this;
    }

    // TODO: Support Explicit field order
    // https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-highlighting.html#explicit-field-order

    /**
     * Override default `toJSON` to return DSL representation for the `highlight` request
     *
     * @override
     * @returns {Object} returns an Object which maps to the elasticsearch query DSL
     */
    toJSON() {
        return recursiveToJSON$a(this._highlight);
    }
};

var highlight$2 = Highlight$4;

const isNil$17 = lodash_isnil;

const Sort$3 = sort$2;
const Highlight$3 = highlight$2;

const { checkType: checkType$K, setDefault: setDefault$a, recursiveToJSON: recursiveToJSON$9 } = util;

/**
 * Inner hits returns per search hit in the search response additional
 * nested hits that caused a search hit to match in a different scope.
 * Inner hits can be used by defining an `inner_hits` definition on a
 * `nested`, `has_child` or `has_parent` query and filter.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-inner-hits.html)
 *
 * @example
 * const reqBody = esb.requestBodySearch().query(
 *     esb.nestedQuery(
 *         esb.matchQuery('comments.message', '[actual query]')
 *     ).innerHits(
 *         esb.innerHits().source(false).storedFields(['comments.text'])
 *     )
 * );
 *
 * @param {string=} name The name to be used for the particular inner hit definition
 * in the response. Useful when multiple inner hits have been defined in a single
 * search request. The default depends in which query the inner hit is defined.
 */
let InnerHits$3 = class InnerHits {
    // eslint-disable-next-line require-jsdoc
    constructor(name) {
        // Maybe accept some optional parameter?
        this._body = {};

        if (!isNil$17(name)) this._body.name = name;
    }

    /**
     * The name to be used for the particular inner hit definition
     * in the response. Useful when multiple inner hits have been defined in a single
     * search request. The default depends in which query the inner hit is defined.
     *
     * @param {number} name
     * @returns {InnerHits} returns `this` so that calls can be chained.
     */
    name(name) {
        this._body.name = name;
        return this;
    }

    /**
     * The offset from where the first hit to fetch for each `inner_hits` in the returned
     * regular search hits.
     *
     * @param {number} from
     * @returns {InnerHits} returns `this` so that calls can be chained.
     */
    from(from) {
        this._body.from = from;
        return this;
    }

    /**
     * The maximum number of hits to return per inner_hits.
     * By default the top three matching hits are returned.
     *
     * @param {number} size Defaults to 10.
     * @returns {InnerHits} returns `this` so that calls can be chained.
     */
    size(size) {
        this._body.size = size;
        return this;
    }

    /**
     * How the inner hits should be sorted per inner_hits.
     * By default the hits are sorted by the score.
     *
     * @param {Sort} sort
     * @returns {InnerHits} returns `this` so that calls can be chained.
     * @throws {TypeError} If parameter `sort` is not an instance of `Sort`.
     */
    sort(sort) {
        checkType$K(sort, Sort$3);
        setDefault$a(this._body, 'sort', []);

        this._body.sort.push(sort);
        return this;
    }

    /**
     * Allows to add multiple sort on specific fields. Each sort can be reversed as well.
     * The sort is defined on a per field level, with special field name for _score to
     * sort by score, and _doc to sort by index order.
     *
     * @param {Array<Sort>} sorts Array of sort
     * @returns {InnerHits} returns `this` so that calls can be chained.
     * @throws {TypeError} If any item in parameter `sorts` is not an instance of `Sort`.
     */
    sorts(sorts) {
        sorts.forEach(sort => this.sort(sort));
        return this;
    }

    /**
     * Allows to highlight search results on one or more fields. The implementation
     * uses either the lucene `plain` highlighter, the fast vector highlighter (`fvh`)
     * or `postings` highlighter.
     *
     * Note: The `postings` highlighter has been removed in elasticsearch 6.0.
     * The `unified` highlighter outputs the same highlighting when
     * `index_options` is set to `offsets`.
     *
     * @param {Highlight} highlight
     * @returns {InnerHits} returns `this` so that calls can be chained
     */
    highlight(highlight) {
        checkType$K(highlight, Highlight$3);

        this._body.highlight = highlight;
        return this;
    }

    /**
     * Enables explanation for each hit on how its score was computed.
     *
     * @param {boolean} enable
     * @returns {InnerHits} returns `this` so that calls can be chained
     */
    explain(enable) {
        this._body.explain = enable;
        return this;
    }

    /**
     * Allows to control how the `_source` field is returned with every hit.
     * You can turn off `_source` retrieval by passing `false`.
     * It also accepts one(string) or more wildcard(array) patterns to control
     * what parts of the `_source` should be returned
     * An object can also be used to specify the wildcard patterns for `includes` and `excludes`.
     *
     * @param {boolean|string|Array|Object} source
     * @returns {InnerHits} returns `this` so that calls can be chained
     */
    source(source) {
        this._body._source = source;
        return this;
    }

    /**
     * Include specific stored fields
     *
     * @param {Array|string} fields
     * @returns {InnerHits} returns `this` so that calls can be chained
     */
    storedFields(fields) {
        this._body.stored_fields = fields;
        return this;
    }

    /**
     * Computes a document property dynamically based on the supplied `Script`.
     *
     * @param {string} scriptFieldName
     * @param {string|Script} script string or instance of `Script`
     * @returns {InnerHits} returns `this` so that calls can be chained
     */
    scriptField(scriptFieldName, script) {
        setDefault$a(this._body, 'script_fields', {});

        this._body.script_fields[scriptFieldName] = { script };
        return this;
    }

    /**
     * Sets given dynamic document properties to be computed using supplied `Script`s.
     *
     * Object should have `scriptFieldName` as key and `script` as the value.
     *
     * @param {Object} scriptFields Object with `scriptFieldName` as key and `script` as the value.
     * @returns {InnerHits} returns `this` so that calls can be chained
     */
    scriptFields(scriptFields) {
        checkType$K(scriptFields, Object);

        Object.keys(scriptFields).forEach(scriptFieldName =>
            this.scriptField(scriptFieldName, scriptFields[scriptFieldName])
        );

        return this;
    }

    /**
     * Allows to return the doc value representation of a field for each hit.
     * Doc value fields can work on fields that are not stored.
     *
     * @param {Array<string>} fields
     * @returns {InnerHits} returns `this` so that calls can be chained
     */
    docvalueFields(fields) {
        this._body.docvalue_fields = fields;
        return this;
    }

    /**
     * Returns a version for each search hit.
     *
     * @param {boolean} enable
     * @returns {InnerHits} returns `this` so that calls can be chained.
     */
    version(enable) {
        this._body.version = enable;
        return this;
    }

    /**
     * Override default `toJSON` to return DSL representation for the inner hits request
     *
     * @override
     * @returns {Object} returns an Object which maps to the elasticsearch query DSL
     */
    toJSON() {
        return recursiveToJSON$9(this._body);
    }
};

var innerHits$2 = InnerHits$3;

const has$8 = lodash_has,
    isNil$16 = lodash_isnil,
    isEmpty$3 = lodash_isemptyExports;

const Query$s = query,
    Aggregation$5 = aggregation,
    Suggester$2 = suggester,
    Rescore$1 = rescore$2,
    Sort$2 = sort$2,
    Highlight$2 = highlight$2,
    InnerHits$2 = innerHits$2;

const { checkType: checkType$J, setDefault: setDefault$9, recursiveToJSON: recursiveToJSON$8 } = util;

/**
 * Helper function to call `recursiveToJSON` on elements of array and assign to object.
 *
 * @private
 *
 * @param {Array} arr
 * @returns {Object}
 */
function recMerge(arr) {
    return Object.assign({}, ...recursiveToJSON$8(arr));
}

/**
 * The `RequestBodySearch` object provides methods generating an elasticsearch
 * search request body. The search request can be executed with a search DSL,
 * which includes the Query DSL, within its body.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-request-body.html)
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .query(esb.termQuery('user', 'kimchy'))
 *     .from(0)
 *     .size(10);
 *
 * reqBody.toJSON();
 * {
 *   "query": { "term": { "user": "kimchy" } },
 *   "from": 0,
 *   "size": 10
 * }
 *
 * @example
 * // Query and aggregation
 * const reqBody = esb.requestBodySearch()
 *     .query(esb.matchQuery('business_type', 'shop'))
 *     .agg(
 *         esb.geoBoundsAggregation('viewport', 'location').wrapLongitude(true)
 *     );
 *
 * @example
 * // Query, aggregation with nested
 * const reqBody = esb.requestBodySearch()
 *     .query(esb.matchQuery('crime', 'burglary'))
 *     .agg(
 *         esb.termsAggregation('towns', 'town').agg(
 *             esb.geoCentroidAggregation('centroid', 'location')
 *         )
 *     );
 */
let RequestBodySearch$1 = class RequestBodySearch {
    // eslint-disable-next-line require-jsdoc
    constructor() {
        // Maybe accept some optional parameter?
        this._body = {};
        this._aggs = [];
        this._suggests = [];
        this._suggestText = null;
    }

    /**
     * Define query on the search request body using the Query DSL.
     *
     * @param {Query} query
     * @returns {RequestBodySearch} returns `this` so that calls can be chained.
     */
    query(query) {
        checkType$J(query, Query$s);

        this._body.query = query;
        return this;
    }

    /**
     * Sets aggregation on the request body.
     * Alias for method `aggregation`
     *
     * @param {Aggregation} agg Any valid `Aggregation`
     * @returns {RequestBodySearch} returns `this` so that calls can be chained.
     * @throws {TypeError} If `agg` is not an instance of `Aggregation`
     */
    agg(agg) {
        return this.aggregation(agg);
    }

    /**
     * Sets aggregation on the request body.
     *
     * @param {Aggregation} agg Any valid `Aggregation`
     * @returns {RequestBodySearch} returns `this` so that calls can be chained.
     * @throws {TypeError} If `agg` is not an instance of `Aggregation`
     */
    aggregation(agg) {
        checkType$J(agg, Aggregation$5);

        this._aggs.push(agg);
        return this;
    }

    /**
     * Sets multiple nested aggregation items.
     * Alias for method `aggregations`
     *
     * @param {Array<Aggregation>} aggs Array of valid {@link Aggregation} items
     * @returns {Aggregation} returns `this` so that calls can be chained.
     * @throws {TypeError} If `aggs` is not an instance of `Array`
     * @throws {TypeError} If `aggs` contains instances not of type `Aggregation`
     */
    aggs(aggs) {
        return this.aggregations(aggs);
    }

    /**
     * Sets multiple nested aggregation items.
     * This method accepts an array to set multiple nested aggregations in one call.
     *
     * @param {Array<Aggregation>} aggs Array of valid {@link Aggregation} items
     * @returns {Aggregation} returns `this` so that calls can be chained.
     * @throws {TypeError} If `aggs` is not an instance of `Array`
     * @throws {TypeError} If `aggs` contains instances not of type `Aggregation`
     */
    aggregations(aggs) {
        checkType$J(aggs, Array);

        aggs.forEach(agg => this.aggregation(agg));

        return this;
    }

    /**
     * Sets suggester on the request body.
     *
     * @example
     * const req = esb.requestBodySearch()
     *     .query(esb.matchQuery('message', 'trying out elasticsearch'))
     *     .suggest(
     *         esb.termSuggester(
     *             'my-suggestion',
     *             'message',
     *             'tring out Elasticsearch'
     *         )
     *     );
     *
     * @param {Suggester} suggest Any valid `Suggester`
     * @returns {RequestBodySearch} returns `this` so that calls can be chained.
     * @throws {TypeError} If `suggest` is not an instance of `Suggester`
     */
    suggest(suggest) {
        checkType$J(suggest, Suggester$2);

        this._suggests.push(suggest);
        return this;
    }

    /**
     * Sets the global suggest text to avoid repetition for multiple suggestions.
     *
     * @example
     * const req = esb.requestBodySearch()
     *     .suggestText('tring out elasticsearch')
     *     .suggest(esb.termSuggester('my-suggest-1', 'message'))
     *     .suggest(esb.termSuggester('my-suggest-2', 'user'));
     *
     * @param {string} txt Global suggest text
     * @returns {RequestBodySearch} returns `this` so that calls can be chained.
     */
    suggestText(txt) {
        this._suggestText = txt;
        return this;
    }

    /**
     * Sets a search timeout, bounding the search request to be executed within
     * the specified time value and bail with the hits accumulated up to that
     * point when expired.
     *
     * @param {string} timeout Duration can be specified using
     * [time units](https://www.elastic.co/guide/en/elasticsearch/reference/current/common-options.html#time-units)
     * Defaults to no timeout.
     * @returns {RequestBodySearch} returns `this` so that calls can be chained.
     */
    timeout(timeout) {
        this._body.timeout = timeout;
        return this;
    }

    /**
     * To retrieve hits from a certain offset.
     *
     * @param {number} from Defaults to 0.
     * @returns {RequestBodySearch} returns `this` so that calls can be chained.
     */
    from(from) {
        this._body.from = from;
        return this;
    }

    /**
     * The number of hits to return. If you do not care about getting some hits back
     * but only about the number of matches and/or aggregations, setting the value
     * to 0 will help performance.
     *
     * @param {number} size Defaults to 10.
     * @returns {RequestBodySearch} returns `this` so that calls can be chained.
     */
    size(size) {
        this._body.size = size;
        return this;
    }

    /**
     * The maximum number of documents to collect for each shard, upon reaching which
     * the query execution will terminate early. If set, the response will have a
     * boolean field `terminated_early` to indicate whether the query execution has
     * actually terminated early.
     *
     * @param {number} numberOfDocs Maximum number of documents to collect for each shard.
     * Defaults to no limit.
     * @returns {RequestBodySearch} returns `this` so that calls can be chained.
     */
    terminateAfter(numberOfDocs) {
        this._body.terminate_after = numberOfDocs;
        return this;
    }

    /**
     * Allows to add sort on specific field. The sort can be reversed as well.
     * The sort is defined on a per field level, with special field name for `_score` to
     * sort by score, and `_doc` to sort by index order.
     *
     * @example
     * const reqBody = esb.requestBodySearch()
     *     .query(esb.termQuery('user', 'kimchy'))
     *     .sort(esb.sort('post_date', 'asc'))
     *     .sort(esb.sort('user'))
     *     .sorts([
     *         esb.sort('name', 'desc'),
     *         esb.sort('age', 'desc'),
     *         esb.sort('_score')
     *     ]);
     *
     * @param {Sort} sort
     * @returns {RequestBodySearch} returns `this` so that calls can be chained.
     * @throws {TypeError} If parameter `sort` is not an instance of `Sort`.
     */
    sort(sort) {
        checkType$J(sort, Sort$2);
        setDefault$9(this._body, 'sort', []);

        this._body.sort.push(sort);
        return this;
    }

    /**
     * Allows to add multiple sort on specific fields. Each sort can be reversed as well.
     * The sort is defined on a per field level, with special field name for _score to
     * sort by score, and _doc to sort by index order.
     *
     * @example
     * const reqBody = esb.requestBodySearch()
     *     .query(esb.termQuery('user', 'kimchy'))
     *     .sort(esb.sort('post_date', 'asc'))
     *     .sort(esb.sort('user'))
     *     .sorts([
     *         esb.sort('name', 'desc'),
     *         esb.sort('age', 'desc'),
     *         esb.sort('_score')
     *     ]);
     *
     * @param {Array<Sort>} sorts Arry of sort
     * @returns {RequestBodySearch} returns `this` so that calls can be chained.
     * @throws {TypeError} If any item in parameter `sorts` is not an instance of `Sort`.
     */
    sorts(sorts) {
        sorts.forEach(sort => this.sort(sort));
        return this;
    }

    /**
     * When sorting on a field, scores are not computed. By setting `track_scores` to true,
     * scores will still be computed and tracked.
     *
     * @example
     * const reqBody = esb.requestBodySearch()
     *     .trackScores(true)
     *     .sorts([
     *         esb.sort('post_date', 'desc'),
     *         esb.sort('name', 'desc'),
     *         esb.sort('age', 'desc')
     *     ])
     *     .query(esb.termQuery('user', 'kimchy'));

     *
     * @param {boolean} enable
     * @returns {RequestBodySearch} returns `this` so that calls can be chained
     */
    trackScores(enable) {
        this._body.track_scores = enable;
        return this;
    }

    /**
     * The `track_total_hits` parameter allows you to control how the total number of hits
     * should be tracked. Passing `false` can increase performance in some situations.
     * (Added in elasticsearch@7)
     *
     * Pass `true`, `false`, or the upper limit (default: `10000`) of hits you want tracked.
     *
     * @param {boolean|number} enableOrLimit
     * @returns {RequestBodySearch} returns `this` so that calls can be chained
     */
    trackTotalHits(enableOrLimit) {
        this._body.track_total_hits = enableOrLimit;
        return this;
    }

    /**
     * Allows to control how the `_source` field is returned with every hit.
     * You can turn off `_source` retrieval by passing `false`.
     * It also accepts one(string) or more wildcard(array) patterns to control
     * what parts of the `_source` should be returned
     * An object can also be used to specify the wildcard patterns for `includes` and `excludes`.
     *
     * @example
     * // To disable `_source` retrieval set to `false`:
     * const reqBody = esb.requestBodySearch()
     *     .query(esb.termQuery('user', 'kimchy'))
     *     .source(false);
     *
     * @example
     * // The `_source` also accepts one or more wildcard patterns to control what
     * // parts of the `_source` should be returned:
     * const reqBody = esb.requestBodySearch()
     *     .query(esb.termQuery('user', 'kimchy'))
     *     .source('obj.*');
     *
     * // OR
     * const reqBody = esb.requestBodySearch()
     *     .query(esb.termQuery('user', 'kimchy'))
     *     .source([ 'obj1.*', 'obj2.*' ]);
     *
     * @example
     * // For complete control, you can specify both `includes` and `excludes` patterns:
     * const reqBody = esb.requestBodySearch()
     *     .query(esb.termQuery('user', 'kimchy'))
     *     .source({
     *         'includes': [ 'obj1.*', 'obj2.*' ],
     *         'excludes': [ '*.description' ]
     *     });
     *
     * @param {boolean|string|Array|Object} source
     * @returns {RequestBodySearch} returns `this` so that calls can be chained
     */
    source(source) {
        this._body._source = source;
        return this;
    }

    /**
     * The `stored_fields` parameter is about fields that are explicitly marked as stored in the mapping.
     * Selectively load specific stored fields for each document represented by a search hit
     * using array of stored fields.
     * An empty array will cause only the `_id` and `_type` for each hit to be returned.
     * To disable the stored fields (and metadata fields) entirely use: `_none_`
     *
     * @example
     * // Selectively load specific stored fields for each document
     * // represented by a search hit
     * const reqBody = esb.requestBodySearch()
     *     .query(esb.termQuery('user', 'kimchy'))
     *     .storedFields(['user', 'postDate']);
     *
     * @example
     * // Return only the `_id` and `_type` to be returned:
     * const reqBody = esb.requestBodySearch()
     *     .query(esb.termQuery('user', 'kimchy'))
     *     .storedFields([]);
     *
     * @example
     * // Disable the stored fields (and metadata fields) entirely
     * const reqBody = esb.requestBodySearch()
     *     .query(esb.termQuery('user', 'kimchy'))
     *     .storedFields('_none_');
     *
     * @param {Array|string} fields
     * @returns {RequestBodySearch} returns `this` so that calls can be chained
     */
    storedFields(fields) {
        this._body.stored_fields = fields;
        return this;
    }

    /**
     * Computes a document property dynamically based on the supplied `Script`.
     *
     * @example
     * const reqBody = esb.requestBodySearch()
     *     .query(esb.matchAllQuery())
     *     .scriptField(
     *         'test1',
     *         esb.script('inline', "doc['my_field_name'].value * 2").lang('painless')
     *     )
     *     .scriptField(
     *         'test2',
     *         esb.script('inline', "doc['my_field_name'].value * factor")
     *             .lang('painless')
     *             .params({ factor: 2.0 })
     *     );
     *
     * @example
     * // Script fields can also access the actual `_source` document and extract
     * // specific elements to be returned from it by using `params['_source']`.
     * const reqBody = esb.requestBodySearch()
     *     .query(esb.matchAllQuery())
     *     .scriptField('test1', "params['_source']['message']");
     *
     * @param {string} scriptFieldName
     * @param {string|Script} script string or instance of `Script`
     * @returns {RequestBodySearch} returns `this` so that calls can be chained
     */
    scriptField(scriptFieldName, script) {
        setDefault$9(this._body, 'script_fields', {});

        this._body.script_fields[scriptFieldName] = { script };
        return this;
    }

    /**
     * Sets given dynamic document properties to be computed using supplied `Script`s.
     *
     * Object should have `scriptFieldName` as key and `script` as the value.
     *
     * @example
     * const reqBody = esb.requestBodySearch()
     *     .query(esb.matchAllQuery())
     *     .scriptFields({
     *         test1: esb
     *             .script('inline', "doc['my_field_name'].value * 2")
     *             .lang('painless'),
     *         test2: esb
     *             .script('inline', "doc['my_field_name'].value * factor")
     *             .lang('painless')
     *             .params({ factor: 2.0 })
     *     });
     *
     * @example
     * // Script fields can also access the actual `_source` document and extract
     * // specific elements to be returned from it by using `params['_source']`.
     * const reqBody = esb.requestBodySearch()
     *     .query(esb.matchAllQuery())
     *     .scriptFields({ test1: "params['_source']['message']" });
     * @param {Object} scriptFields Object with `scriptFieldName` as key and `script` as the value.
     * @returns {TopHitsAggregation} returns `this` so that calls can be chained
     */
    scriptFields(scriptFields) {
        checkType$J(scriptFields, Object);

        Object.keys(scriptFields).forEach(scriptFieldName =>
            this.scriptField(scriptFieldName, scriptFields[scriptFieldName])
        );

        return this;
    }

    /**
     * Allows to return the doc value representation of a field for each hit.
     * Doc value fields can work on fields that are not stored.
     *
     * @example
     * const reqBody = esb.requestBodySearch()
     *     .query(esb.matchAllQuery())
     *     .docvalueFields(['test1', 'test2']);
     *
     * @param {Array<string>} fields
     * @returns {RequestBodySearch} returns `this` so that calls can be chained
     */
    docvalueFields(fields) {
        this._body.docvalue_fields = fields;
        return this;
    }

    /**
     * The `post_filter` is applied to the search hits at the very end of a search request,
     * after aggregations have already been calculated.
     *
     * @example
     * const reqBody = esb.requestBodySearch()
     *     .query(esb.boolQuery().filter(esb.termQuery('brand', 'gucci')))
     *     .agg(esb.termsAggregation('colors', 'color'))
     *     .agg(
     *         esb.filterAggregation(
     *             'color_red',
     *             esb.termQuery('color', 'red')
     *         ).agg(esb.termsAggregation('models', 'model'))
     *     )
     *     .postFilter(esb.termQuery('color', 'red'));
     *
     * @param {Query} filterQuery The filter to be applied after aggregation.
     * @returns {RequestBodySearch} returns `this` so that calls can be chained
     */
    postFilter(filterQuery) {
        checkType$J(filterQuery, Query$s);

        this._body.post_filter = filterQuery;
        return this;
    }

    /**
     * Allows to highlight search results on one or more fields. The implementation
     * uses either the lucene `plain` highlighter, the fast vector highlighter (`fvh`)
     * or `postings` highlighter.
     *
     * Note: The `postings` highlighter has been removed in elasticsearch 6.0.
     * The `unified` highlighter outputs the same highlighting when
     * `index_options` is set to `offsets`.
     *
     * @example
     * const reqBody = esb.requestBodySearch()
     *     .query(esb.matchAllQuery())
     *     .highlight(esb.highlight('content'));
     *
     * @example
     * const reqBody = esb.requestBodySearch()
     *     .query(
     *         esb.percolateQuery('query', 'doctype').document({
     *             message: 'The quick brown fox jumps over the lazy dog'
     *         })
     *     )
     *     .highlight(esb.highlight('message'));
     *
     * @param {Highlight} highlight
     * @returns {RequestBodySearch} returns `this` so that calls can be chained
     */
    highlight(highlight) {
        checkType$J(highlight, Highlight$2);

        this._body.highlight = highlight;
        return this;
    }

    /**
     * Rescoring can help to improve precision by reordering just the top (eg 100 - 500)
     * documents returned by the `query` and `post_filter` phases, using a secondary
     * (usually more costly) algorithm, instead of applying the costly algorithm to
     * all documents in the index.
     *
     * @example
     * const reqBody = esb.requestBodySearch()
     *     .query(esb.matchQuery('message', 'the quick brown').operator('or'))
     *     .rescore(
     *         esb.rescore(
     *             50,
     *             esb.matchPhraseQuery('message', 'the quick brown').slop(2)
     *         )
     *             .queryWeight(0.7)
     *             .rescoreQueryWeight(1.2)
     *     );
     *
     * @example
     * const reqBody = esb.requestBodySearch()
     *     .query(esb.matchQuery('message', 'the quick brown').operator('or'))
     *     .rescore(
     *         esb.rescore(
     *             100,
     *             esb.matchPhraseQuery('message', 'the quick brown').slop(2)
     *         )
     *             .queryWeight(0.7)
     *             .rescoreQueryWeight(1.2)
     *     )
     *     .rescore(
     *         esb.rescore(
     *             10,
     *             esb.functionScoreQuery().function(
     *                 esb.scriptScoreFunction(
     *                     esb.script('inline', 'Math.log10(doc.likes.value + 2)')
     *                 )
     *             )
     *         ).scoreMode('multiply')
     *     );
     *
     * @param {Rescore} rescore
     * @returns {RequestBodySearch} returns `this` so that calls can be chained
     * @throws {TypeError} If `query` is not an instance of `Rescore`
     */
    rescore(rescore) {
        checkType$J(rescore, Rescore$1);

        if (has$8(this._body, 'rescore')) {
            if (!Array.isArray(this._body.rescore)) {
                this._body.rescore = [this._body.rescore];
            }

            this._body.rescore.push(rescore);
        } else this._body.rescore = rescore;

        return this;
    }

    // TODO: Scroll related changes
    // Maybe only slice needs to be supported.

    /**
     * Enables explanation for each hit on how its score was computed.
     *
     * @example
     * const reqBody = esb.requestBodySearch()
     *     .query(esb.termQuery('user', 'kimchy'))
     *     .explain(true);
     *
     * @param {boolean} enable
     * @returns {RequestBodySearch} returns `this` so that calls can be chained
     */
    explain(enable) {
        this._body.explain = enable;
        return this;
    }

    /**
     * Returns a version for each search hit.
     *
     * @example
     * const reqBody = esb.requestBodySearch()
     *     .query(esb.termQuery('user', 'kimchy'))
     *     .version(true);
     *
     * @param {boolean} enable
     * @returns {RequestBodySearch} returns `this` so that calls can be chained.
     */
    version(enable) {
        this._body.version = enable;
        return this;
    }

    /**
     * Allows to configure different boost level per index when searching across
     * more than one indices. This is very handy when hits coming from one index
     * matter more than hits coming from another index.
     *
     * Alias for method `indicesBoost`.
     *
     * @example
     * const reqBody = esb.requestBodySearch()
     *     .indexBoost('alias1', 1.4)
     *     .indexBoost('index*', 1.3);
     *
     * @param {string} index Index windcard expression or alias
     * @param {number} boost
     * @returns {RequestBodySearch} returns `this` so that calls can be chained.
     */
    indexBoost(index, boost) {
        return this.indicesBoost(index, boost);
    }

    /**
     * Allows to configure different boost level per index when searching across
     * more than one indices. This is very handy when hits coming from one index
     * matter more than hits coming from another index.
     *
     * @example
     * const reqBody = esb.requestBodySearch()
     *     .indicesBoost('alias1', 1.4)
     *     .indicesBoost('index*', 1.3);
     *
     * @param {string} index Index windcard expression or alias
     * @param {number} boost
     * @returns {RequestBodySearch} returns `this` so that calls can be chained.
     */
    indicesBoost(index, boost) {
        setDefault$9(this._body, 'indices_boost', []);

        this._body.indices_boost.push({
            [index]: boost
        });
        return this;
    }

    /**
     * Exclude documents which have a `_score` less than the minimum specified in `min_score`.
     *
     * @example
     * const reqBody = esb.requestBodySearch()
     *     .query(esb.termQuery('user', 'kimchy'))
     *     .minScore(0.5);
     *
     * @param {number} score
     * @returns {RequestBodySearch} returns `this` so that calls can be chained.
     */
    minScore(score) {
        this._body.min_score = score;
        return this;
    }

    /**
     * Allows to collapse search results based on field values. The collapsing
     * is done by selecting only the top sorted document per collapse key.
     *
     * The field used for collapsing must be a single valued `keyword` or `numeric`
     * field with `doc_values` activated
     *
     * @example
     * const reqBody = esb.requestBodySearch()
     *     .query(esb.matchQuery('message', 'elasticsearch'))
     *     .collapse('user')
     *     .sort(esb.sort('likes'))
     *     .from(10);
     *
     * @example
     * // Expand each collapsed top hits with the `inner_hits` option:
     * const reqBody = esb.requestBodySearch()
     *     .query(esb.matchQuery('message', 'elasticsearch'))
     *     .collapse(
     *         'user',
     *         esb.innerHits('last_tweets')
     *             .size(5)
     *             .sort(esb.sort('date', 'asc')),
     *         4
     *     )
     *     .sort(esb.sort('likes'))
     *     .from(10);
     *
     * @param {string} field
     * @param {InnerHits=} innerHits Allows to expand each collapsed top hits.
     * @param {number=} maxConcurrentGroupRequests The number of concurrent
     * requests allowed to retrieve the inner_hits' per group
     * @returns {RequestBodySearch} returns `this` so that calls can be chained.
     * @throws {TypeError} If `innerHits` is not an instance of `InnerHits`
     */
    collapse(field, innerHits, maxConcurrentGroupRequests) {
        const collapse = (this._body.collapse = { field });

        if (!isNil$16(innerHits)) {
            checkType$J(innerHits, InnerHits$2);

            collapse.inner_hits = innerHits;
            collapse.max_concurrent_group_searches = maxConcurrentGroupRequests;
        }

        return this;
    }

    /**
     * Allows to use the results from the previous page to help the retrieval
     * of the next page. The `search_after` parameter provides a live cursor.
     *
     * The parameter `from` must be set to `0` (or `-1`) when `search_after` is used.
     *
     * @example
     * const reqBody = esb.requestBodySearch()
     *     .size(10)
     *     .query(esb.matchQuery('message', 'elasticsearch'))
     *     .searchAfter(1463538857, 'tweet#654323')
     *     .sorts([esb.sort('date', 'asc'), esb.sort('_uid', 'desc')]);
     *
     * @param {Array<*>} values The `sort values` of the last document to retrieve
     * the next page of results
     * @returns {RequestBodySearch} returns `this` so that calls can be chained.
     */
    searchAfter(values) {
        this._body.search_after = values;
        return this;
    }

    /**
     * Override default `toJSON` to return DSL representation for the request body search
     *
     * @override
     * @returns {Object} returns an Object which maps to the elasticsearch query DSL
     */
    toJSON() {
        const dsl = recursiveToJSON$8(this._body);

        if (!isEmpty$3(this._aggs)) dsl.aggs = recMerge(this._aggs);

        if (!isEmpty$3(this._suggests) || !isNil$16(this._suggestText)) {
            dsl.suggest = recMerge(this._suggests);

            if (!isNil$16(this._suggestText)) {
                dsl.suggest.text = this._suggestText;
            }
        }

        return dsl;
    }
};

var requestBodySearch = RequestBodySearch$1;

const isObject$3 = lodash_isobject;
const isNil$15 = lodash_isnil;

const { checkType: checkType$I } = util;

/**
 * A `GeoPoint` object that can be used in queries and filters that
 * take a `GeoPoint`.  `GeoPoint` supports various input formats.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-point.html)
 */
let GeoPoint$5 = class GeoPoint {
    // eslint-disable-next-line require-jsdoc
    constructor() {
        // Take optional parameter and call appropriate method?
        // Will have to check for string, object and array.
        // this will be set depending on subsequent method called
        this._point = null;
    }

    /**
     * Print warning message to console namespaced by class name.
     *
     * @param {string} msg
     * @private
     */
    _warn(msg) {
        console.warn(`[GeoPoint] ${msg}`);
    }

    /**
     * Print warning messages to not mix Geo Point representations
     * @private
     */
    _warnMixedRepr() {
        this._warn('Do not mix with other representation!');
        this._warn('Overwriting.');
    }

    /**
     * Check the instance for object representation of Geo Point.
     * If representation is null, new object is initialised.
     * If it is not null, warning is logged and point is overwritten.
     * @private
     */
    _checkObjRepr() {
        if (isNil$15(this._point)) this._point = {};
        else if (!isObject$3(this._point)) {
            this._warnMixedRepr();
            this._point = {};
        }
    }

    /**
     * Sets the latitude for the object representation.
     *
     * @param {number} lat Latitude
     * @returns {GeoPoint} returns `this` so that calls can be chained
     */
    lat(lat) {
        this._checkObjRepr();

        this._point.lat = lat;
        return this;
    }

    /**
     * Sets the longitude for the object representation.
     *
     * @param {number} lon Longitude
     * @returns {GeoPoint} returns `this` so that calls can be chained
     */
    lon(lon) {
        this._checkObjRepr();

        this._point.lon = lon;
        return this;
    }

    /**
     * Sets the Geo Point value expressed as an object,
     * with `lat` and `lon` keys.
     *
     * @param {Object} point
     * @returns {GeoPoint} returns `this` so that calls can be chained
     * @throws {TypeError} If `point` is not an instance of object
     */
    object(point) {
        checkType$I(point, Object);

        !isNil$15(this._point) && this._warnMixedRepr();

        this._point = point;
        return this; // This doesn't make much sense. What else are you gonna call?
    }

    /**
     * Sets the Geo Point value expressed as an array
     * with the format: `[ lon, lat ]`.
     *
     * @param {Array<number>} point Array in format `[ lon, lat ]`(`GeoJson` standard)
     * @returns {GeoPoint} returns `this` so that calls can be chained
     * @throws {TypeError} If `point` is not an instance of Array
     */
    array(point) {
        checkType$I(point, Array);

        !isNil$15(this._point) && this._warnMixedRepr();

        this._point = point;
        return this; // This doesn't make much sense. What else are you gonna call?
    }

    /**
     * Sets Geo-point expressed as a string with the format: `"lat,lon"`
     * or as a geo hash
     *
     * @param {string} point
     * @returns {GeoPoint} returns `this` so that calls can be chained
     */
    string(point) {
        !isNil$15(this._point) && this._warnMixedRepr();

        this._point = point;
        return this;
    }

    /**
     * Override default `toJSON` to return DSL representation for the `GeoPoint`
     *
     * @override
     * @returns {Object} returns an Object which maps to the elasticsearch query DSL
     */
    toJSON() {
        return this._point;
    }
};

var geoPoint$2 = GeoPoint$5;

const isNil$14 = lodash_isnil;
const has$7 = lodash_has;

const { checkType: checkType$H, invalidParam: invalidParam$o } = util;
const { GEO_SHAPE_TYPES } = consts;

const ES_REF_URL$11 =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-shape.html';

const invalidTypeParam$2 = invalidParam$o(ES_REF_URL$11, 'type', GEO_SHAPE_TYPES);

/**
 * Shape object that can be used in queries and filters that
 * take a Shape. Shape uses the GeoJSON format.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-shape.html)
 *
 * @example
 * // Pass options using method
 * const shape = esb.geoShape()
 *     .type('linestring')
 *     .coordinates([[-77.03653, 38.897676], [-77.009051, 38.889939]]);
 *
 * @example
 * // Pass parameters using contructor
 * const shape = esb.geoShape('multipoint', [[102.0, 2.0], [103.0, 2.0]])
 *
 * @param {string=} type A valid shape type.
 * Can be one of `point`, `linestring`, `polygon`, `multipoint`, `multilinestring`,
 * `multipolygon`, `geometrycollection`, `envelope` and `circle`
 * @param {Array=} coords A valid coordinat definition for the given shape.
 */
let GeoShape$2 = class GeoShape {
    // eslint-disable-next-line require-jsdoc
    constructor(type, coords) {
        this._body = {};

        if (!isNil$14(type)) this.type(type);
        if (!isNil$14(coords)) this.coordinates(coords);
    }

    /**
     * Sets the GeoJSON format type used to represent shape.
     *
     * @example
     * const shape = esb.geoShape()
     *     .type('envelope')
     *     .coordinates([[-45.0, 45.0], [45.0, -45.0]])
     *
     * @param {string} type A valid shape type.
     * Can be one of `point`, `linestring`, `polygon`, `multipoint`, `multilinestring`,
     * `multipolygon`, `geometrycollection`, `envelope`, `circle`
     * @returns {GeoShape} returns `this` so that calls can be chained.
     */
    type(type) {
        if (isNil$14(type)) invalidTypeParam$2(type);

        const typeLower = type.toLowerCase();
        if (!GEO_SHAPE_TYPES.has(typeLower)) invalidTypeParam$2(type);

        this._body.type = typeLower;
        return this;
    }

    /**
     * Sets the coordinates for the shape definition. Note, the coordinates
     * are not validated in this api. Please see [GeoJSON](http://geojson.org/geojson-spec.html#geometry-objects)
     * and [ElasticSearch documentation](https://www.elastic.co/guide/en/elasticsearch/reference/current/geo-shape.html#input-structure) for correct coordinate definitions.
     *
     * @example
     * const shape = esb.geoShape()
     *     .type('point')
     *     .coordinates([-77.03653, 38.897676])
     *
     * @param {Array<Array<number>>|Array<number>} coords
     * @returns {GeoShape} returns `this` so that calls can be chained.
     */
    coordinates(coords) {
        checkType$H(coords, Array);

        this._body.coordinates = coords;
        return this;
    }

    /**
     * Sets the radius for parsing a circle `GeoShape`.
     *
     * @example
     * const shape = esb.geoShape()
     *     .type('circle')
     *     .coordinates([-45.0, 45.0])
     *     .radius('100m')
     *
     * @param {string|number} radius The radius for shape circle.
     * @returns {GeoShape} returns `this` so that calls can be chained.
     */
    radius(radius) {
        // Should this have a validation for circle shape type?
        this._body.radius = radius;
        return this;
    }

    /**
     * Override default `toJSON` to return DSL representation of the geo shape
     * class instance.
     *
     * @override
     * @returns {Object} returns an Object which maps to the elasticsearch query DSL
     */
    toJSON() {
        if (!has$7(this._body, 'type') || !has$7(this._body, 'coordinates')) {
            throw new Error(
                'For all types, both the inner `type` and `coordinates` fields are required.'
            );
        }
        return this._body;
    }
};

var geoShape$2 = GeoShape$2;

const isNil$13 = lodash_isnil;

/**
 * A shape which has already been indexed in another index and/or index
 * type. This is particularly useful for when you have a pre-defined list of
 * shapes which are useful to your application and you want to reference this
 * using a logical name (for example 'New Zealand') rather than having to
 * provide their coordinates each time.
 *
 * @example
 * const shape = esb.indexedShape('DEU', 'countries')
 *     .index('shapes')
 *     .path('location');
 *
 * const shape = esb.indexedShape()
 *     .id('DEU')
 *     .type('countries')
 *     .index('shapes')
 *     .path('location');
 *
 * @param {string=} id The document id of the shape.
 * @param {string=} type The name of the type where the shape is indexed.
 */
let IndexedShape$2 = class IndexedShape {
    // eslint-disable-next-line require-jsdoc
    constructor(id, type) {
        this._body = {};

        if (!isNil$13(id)) this._body.id = id;
        if (!isNil$13(type)) this._body.type = type;
    }

    /**
     * Sets the ID of the document that containing the pre-indexed shape.
     *
     * @param {string} id The document id of the shape.
     * @returns {IndexedShape} returns `this` so that calls can be chained.
     */
    id(id) {
        this._body.id = id;
        return this;
    }

    /**
     * Sets the index type where the pre-indexed shape is.
     *
     * @param {string} type The name of the type where the shape is indexed.
     * @returns {IndexedShape} returns `this` so that calls can be chained.
     */
    type(type) {
        this._body.type = type;
        return this;
    }

    /**
     * Sets the name of the index where the pre-indexed shape is. Defaults to `shapes`.
     *
     * @param {string} index A valid index name
     * @returns {IndexedShape} returns `this` so that calls can be chained.
     */
    index(index) {
        this._body.index = index;
        return this;
    }

    /**
     * Sets the field specified as path containing the pre-indexed shape.
     * Defaults to `shape`.
     *
     * @param {string} path field name.
     * @returns {IndexedShape} returns `this` so that calls can be chained.
     */
    path(path) {
        this._body.path = path;
        return this;
    }

    /**
     * Override default `toJSON` to return DSL representation of the geo shape
     * class instance.
     *
     * @override
     * @returns {Object} returns an Object which maps to the elasticsearch query DSL
     */
    toJSON() {
        return this._body;
    }
};

var indexedShape$2 = IndexedShape$2;

const isNil$12 = lodash_isnil;

const { recursiveToJSON: recursiveToJSON$7 } = util;

/**
 * Class supporting the Elasticsearch search template API.
 *
 * The `/_search/template` endpoint allows to use the mustache language to
 * pre render search requests, before they are executed and fill existing
 * templates with template parameters.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html)
 *
 * @param {string=} type One of `inline`, `id`, `file`. `id` is also
 * aliased as `indexed`
 * @param {string|Object=} source Source of the search template.
 * This needs to be specified if optional argument `type` is passed.
 *
 * @example
 * const templ = esb.searchTemplate('inline', {
 *     query: esb.matchQuery('{{my_field}}', '{{my_value}}'),
 *     size: '{{my_size}}'
 * }).params({
 *     my_field: 'message',
 *     my_value: 'some message',
 *     my_size: 5
 * });
 *
 * @example
 * const templ = new esb.SearchTemplate(
 *     'inline',
 *     '{ "query": { "terms": {{#toJson}}statuses{{/toJson}} }}'
 * ).params({
 *     statuses: {
 *         status: ['pending', 'published']
 *     }
 * });
 *
 * @example
 * const templ = new esb.SearchTemplate(
 *     'inline',
 *     '{ "query": { "bool": { "must": {{#toJson}}clauses{{/toJson}} } } }'
 * ).params({
 *     clauses: [
 *         esb.termQuery('user', 'boo'),
 *         esb.termQuery('user', 'bar'),
 *         esb.termQuery('user', 'baz')
 *     ]
 * });
 */
let SearchTemplate$1 = class SearchTemplate {
    // eslint-disable-next-line require-jsdoc
    constructor(type, source) {
        this._isTypeSet = false;
        this._body = {};

        if (!isNil$12(type) && !isNil$12(source)) {
            const typeLower = type.toLowerCase();

            if (
                typeLower !== 'inline' &&
                typeLower !== 'id' &&
                typeLower !== 'indexed' && // alias for id
                typeLower !== 'file'
            ) {
                throw new Error(
                    '`type` must be one of `inline`, `id`, `indexed`, `file`'
                );
            }

            this[typeLower](source);
        }
    }

    /**
     * Print warning message to console namespaced by class name.
     *
     * @param {string} msg
     * @private
     */
    _warn(msg) {
        console.warn(`[SearchTemplate] ${msg}`);
    }

    /**
     * Print warning messages to not mix `SearchTemplate` source
     *
     * @private
     */
    _checkMixedRepr() {
        if (this._isTypeSet) {
            this._warn(
                'Search template source(`inline`/`id`/`file`) was already specified!'
            );
            this._warn('Overwriting.');

            delete this._body.file;
            delete this._body.id;
            delete this._body.file;
        }
    }

    /**
     * Helper method to set the type and source
     *
     * @param {string} type
     * @param {*} source
     * @returns {SearchTemplate} returns `this` so that calls can be chained.
     * @private
     */
    _setSource(type, source) {
        this._checkMixedRepr();

        this._body[type] = source;
        this._isTypeSet = true;
        return this;
    }

    /**
     * Sets the type of search template to be `inline` and specifies the
     * template with `query` and other optional fields such as `size`.
     *
     * @param {string|Object} templ Either an object or a string.
     * @returns {SearchTemplate} returns `this` so that calls can be chained.
     */
    inline(templ) {
        return this._setSource('inline', templ);
    }

    /**
     * Specify the indexed search template by `templateName` which will be
     * retrieved from cluster state.
     *
     * @param {string} templId The unique identifier for the indexed template.
     * @returns {SearchTemplate} returns `this` so that calls can be chained.
     */
    id(templId) {
        return this._setSource('id', templId);
    }

    /**
     * Specify the indexed search template by `templateName` which will be
     * retrieved from cluster state.
     *
     * Alias for `SearchTemplate.id`
     *
     * @param {string} templId The unique identifier for the indexed template.
     * @returns {SearchTemplate} returns `this` so that calls can be chained.
     */
    indexed(templId) {
        return this.id(templId);
    }

    /**
     * Specify the search template by filename stored in the scripts folder,
     * with `mustache` extension.
     *
     * @example
     * // `templId` - Name of the query template in config/scripts/, i.e.,
     * // storedTemplate.mustache.
     * const templ = new esb.SearchTemplate('file', 'storedTemplate').params({
     *     query_string: 'search for these words'
     * });
     *
     * @param {string} fileName The name of the search template stored as a file
     * in the scripts folder.
     * For file `config/scripts/storedTemplate.mustache`,
     * `fileName` should be `storedTemplate`
     * @returns {SearchTemplate} returns `this` so that calls can be chained.
     */
    file(fileName) {
        return this._setSource('file', fileName);
    }

    /**
     * Specifies any named parameters that are used to render the search template.
     *
     * @param {Object} params Named parameters to be used for rendering.
     * @returns {SearchTemplate} returns `this` so that calls can be chained.
     */
    params(params) {
        this._body.params = params;
        return this;
    }

    /**
     * Override default `toJSON` to return DSL representation for the Search Template.
     *
     * @override
     * @returns {Object} returns an Object which maps to the elasticsearch query DSL
     */
    toJSON() {
        return recursiveToJSON$7(this._body);
    }
};

var searchTemplate$2 = SearchTemplate$1;

// Base classes

core.RequestBodySearch = requestBodySearch;

core.Aggregation = aggregation;

core.Query = query;

core.Suggester = suggester;

core.Script = script$2;

core.Highlight = highlight$2;

core.GeoPoint = geoPoint$2;

core.GeoShape = geoShape$2;

core.IndexedShape = indexedShape$2;

core.Sort = sort$2;

core.Rescore = rescore$2;

core.InnerHits = innerHits$2;

core.SearchTemplate = searchTemplate$2;

core.consts = consts;

core.util = util;

var queries = {};

const { Query: Query$r } = core;

/**
 * The most simple query, which matches all documents, giving them all a `_score` of `1.0`.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-all-query.html)
 *
 * @example
 * const qry = esb.matchAllQuery().boost(1.2);
 *
 * @extends Query
 */
let MatchAllQuery$2 = class MatchAllQuery extends Query$r {
    // eslint-disable-next-line require-jsdoc
    constructor() {
        super('match_all');
    }
};

var matchAllQuery$2 = MatchAllQuery$2;

const { Query: Query$q } = core;

/**
 * The inverse of the `match_all` query, which matches no documents.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-all-query.html)
 *
 * @example
 * const qry = esb.matchNoneQuery();
 *
 * @extends Query
 */
let MatchNoneQuery$1 = class MatchNoneQuery extends Query$q {
    // eslint-disable-next-line require-jsdoc
    constructor() {
        super('match_none');
    }
};

var matchNoneQuery$2 = MatchNoneQuery$1;

var fullTextQueries = {};

const isNil$11 = lodash_isnil;

const { Query: Query$p } = core;

/**
 * The `FullTextQueryBase` provides support for common options used across
 * various full text query implementations.
 *
 * **NOTE:** Instantiating this directly should not be required.
 * However, if you wish to add a custom implementation for whatever reason,
 * this class could be extended.
 *
 * @param {string} queryType
 * @param {string=} queryString The query string
 *
 * @extends Query
 */
let FullTextQueryBase$3 = class FullTextQueryBase extends Query$p {
    /*
        Common options:
        analyzer - applicable on all
        minimum_should_match - applicable on all except Match Phrase and Match Phrase Prefix
        query - applicable on all
    */

    // eslint-disable-next-line require-jsdoc
    constructor(queryType, queryString) {
        super(queryType);

        if (!isNil$11(queryString)) this._queryOpts.query = queryString;
    }

    /**
     * Set the analyzer to control which analyzer will perform the analysis process on the text
     *
     * @example
     * const qry = esb.matchPhraseQuery('message', 'this is a test')
     *     .analyzer('my_analyzer');
     *
     * @example
     * const qry = esb.multiMatchQuery(['first', 'last', '*.edge'], 'Jon')
     *     .type('cross_fields')
     *     .analyzer('standard');
     *
     * @param {string} analyzer
     * @returns {FullTextQueryBase} returns `this` so that calls can be chained.
     */
    analyzer(analyzer) {
        this._queryOpts.analyzer = analyzer;
        return this;
    }

    /**
     * Sets the value controlling how many "should" clauses in the resulting boolean
     * query should match. It can be an absolute value (2), a percentage (30%)
     * or a combination of both. For Common Terms Query when specifying different
     * `minimum_should_match` for low and high frequency terms, an object with the
     * keys `low_freq` and `high_freq` can be used.
     *
     * @example
     * const qry = esb.commonTermsQuery('body', 'nelly the elephant as a cartoon')
     *     .minimumShouldMatch(2)
     *     .cutoffFrequency(0.001);
     *
     * @param {string|number|Object} minimumShouldMatch
     * Note: Object notation can only be used with Common Terms Query.
     * @returns {FullTextQueryBase} returns `this` so that calls can be chained.
     */
    minimumShouldMatch(minimumShouldMatch) {
        this._queryOpts.minimum_should_match = minimumShouldMatch;
        return this;
    }

    /**
     * Sets the query string.
     *
     * @example
     * const qry = esb.queryStringQuery()
     *     .query('city.\\*:(this AND that OR thus)')
     *     .useDisMax(true);
     *
     * @param {string} queryString
     * @returns {FullTextQueryBase} returns `this` so that calls can be chained.
     */
    query(queryString) {
        this._queryOpts.query = queryString;
        return this;
    }
};

var fullTextQueryBase = FullTextQueryBase$3;

const has$6 = lodash_has;
const isNil$10 = lodash_isnil;

const FullTextQueryBase$2 = fullTextQueryBase;

/**
 * The `MonoFieldQueryBase` provides support for common options used across
 * various full text query implementations with single search field.
 *
 * **NOTE:** Instantiating this directly should not be required.
 * However, if you wish to add a custom implementation for whatever reason,
 * this class could be extended.
 *
 * @param {string} queryType
 * @param {string=} field The document field to query against
 * @param {string=} queryString The query string
 *
 * @extends FullTextQueryBase
 */
let MonoFieldQueryBase$4 = class MonoFieldQueryBase extends FullTextQueryBase$2 {
    // eslint-disable-next-line require-jsdoc
    constructor(queryType, field, queryString) {
        super(queryType, queryString);

        if (!isNil$10(field)) this._field = field;
    }

    /**
     * Sets the field to search on.
     *
     * @param {string} field
     * @returns {MonoFieldQueryBase} returns `this` so that calls can be chained.
     */
    field(field) {
        this._field = field;
        return this;
    }

    /**
     * Override default `toJSON` to return DSL representation of the Full text query
     * class instance.
     *
     * @override
     * @returns {Object} returns an Object which maps to the elasticsearch query DSL
     */
    toJSON() {
        // recursiveToJSON doesn't seem to be required here.

        // Revisit this.. Smells a little bit
        if (!has$6(this._queryOpts, 'query')) {
            throw new Error('Query string is required for full text query!');
        }

        const queryOptKeys = Object.keys(this._queryOpts);
        const qryOpts =
            queryOptKeys.length === 1 ? this._queryOpts.query : this._queryOpts;

        const repr = {
            [this.queryType]: {
                [this._field]: qryOpts
            }
        };
        return repr;
    }
};

var monoFieldQueryBase = MonoFieldQueryBase$4;

const MonoFieldQueryBase$3 = monoFieldQueryBase;

/**
 * The `MatchPhraseQueryBase` provides support for common options used across
 * various bucket match phrase query implementations.
 *
 * **NOTE:** Instantiating this directly should not be required.
 * However, if you wish to add a custom implementation for whatever reason,
 * this class could be extended.
 *
 * @param {string} queryType
 * @param {string} refUrl
 * @param {string=} field The document field to query against
 * @param {string=} queryString The query string
 *
 * @extends MonoFieldQueryBase
 */
let MatchPhraseQueryBase$2 = class MatchPhraseQueryBase extends MonoFieldQueryBase$3 {
    // eslint-disable-next-line require-jsdoc
    constructor(queryType, refUrl, field, queryString) {
        super(queryType, field, queryString);

        this._refUrl = refUrl;
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on `MatchPhraseQueryBase`
     */
    minimumShouldMatch() {
        console.log(`Please refer ${this._refUrl}`);
        throw new Error(
            `minimumShouldMatch is not supported in ${this.constructor.name}`
        );
    }

    /**
     * Configures the `slop`(default is 0) for matching terms in any order.
     * Transposed terms have a slop of 2.
     *
     * @param {number} slop A positive integer value, defaults is 0.
     * @returns {MatchPhraseQueryBase} returns `this` so that calls can be chained.
     */
    slop(slop) {
        this._queryOpts.slop = slop;
        return this;
    }
};

var matchPhraseQueryBase = MatchPhraseQueryBase$2;

const isNil$$ = lodash_isnil;

const {
    util: { checkType: checkType$G, setDefault: setDefault$8, invalidParam: invalidParam$n }
} = core;
const FullTextQueryBase$1 = fullTextQueryBase;

const invalidOperatorParam$2 = invalidParam$n('', 'operator', "'AND' or 'OR'");

/**
 * The `QueryStringQueryBase` provides support for common options used across
 * full text query implementations `QueryStringQuery` and `SimpleQueryStringQuery`.
 * A query that uses a query parser in order to parse its content.
 *
 * **NOTE:** Instantiating this directly should not be required.
 * However, if you wish to add a custom implementation for whatever reason,
 * this class could be extended.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html)
 *
 * @param {string} queryType
 * @param {string} refUrl
 * @param {string=} queryString The actual query to be parsed.
 *
 * @extends FullTextQueryBase
 */
let QueryStringQueryBase$2 = class QueryStringQueryBase extends FullTextQueryBase$1 {
    // eslint-disable-next-line require-jsdoc
    constructor(queryType, refUrl, queryString) {
        super(queryType, queryString);

        this._refUrl = refUrl;
    }

    /**
     * Appends given field to the list of fields to search against.
     * Fields can be specified with wildcards.
     *
     * Individual fields can be boosted with the caret (^) notation.
     * Example - `"subject^3"`
     *
     * @example
     * const qry = esb.queryStringQuery('this AND that OR thus')
     *     .field('city.*')
     *     .useDisMax(true);
     *
     * @example
     * const qry = esb.simpleQueryStringQuery('foo bar -baz').field('content');
     *
     * @param {string} field One of the fields to be queried
     * @returns {QueryStringQueryBase} returns `this` so that calls can be chained.
     */
    field(field) {
        setDefault$8(this._queryOpts, 'fields', []);

        this._queryOpts.fields.push(field);
        return this;
    }

    /**
     * Appends given fields to the list of fields to search against.
     * Fields can be specified with wildcards.
     *
     * Individual fields can be boosted with the caret (^) notation.
     * Example - `[ "subject^3", "message" ]`
     *
     * @example
     * const qry = esb.queryStringQuery('this AND that')
     *     .fields(['content', 'name'])
     *
     * @example
     * const qry = esb.simpleQueryStringQuery('foo bar baz')
     *     .fields(['content', 'name.*^5']);
     *
     * @param {Array<string>} fields The fields to be queried
     * @returns {QueryStringQueryBase} returns `this` so that calls can be chained.
     */
    fields(fields) {
        checkType$G(fields, Array);
        setDefault$8(this._queryOpts, 'fields', []);

        this._queryOpts.fields = this._queryOpts.fields.concat(fields);
        return this;
    }

    /**
     * The default operator used if no explicit operator is specified.
     * For example, with a default operator of `OR`, the query `capital of Hungary`
     * is translated to `capital OR of OR Hungary`, and with default operator of AND,
     * the same query is translated to `capital AND of AND Hungary`.
     * The default value is OR.
     *
     * @param {string} operator Can be `AND`/`OR`. Default is `OR`.
     * @returns {QueryStringQueryBase} returns `this` so that calls can be chained.
     */
    defaultOperator(operator) {
        if (isNil$$(operator)) invalidOperatorParam$2(operator, this._refUrl);

        const operatorUpper = operator.toUpperCase();
        if (operatorUpper !== 'AND' && operatorUpper !== 'OR') {
            invalidOperatorParam$2(operator, this._refUrl);
        }

        this._queryOpts.default_operator = operatorUpper;
        return this;
    }

    /**
     * By default, wildcards terms in a query string are not analyzed.
     * By setting this value to `true`, a best effort will be made to analyze those as well.
     *
     * @param {boolean} enable
     * @returns {QueryStringQueryBase} returns `this` so that calls can be chained.
     */
    analyzeWildcard(enable) {
        this._queryOpts.analyze_wildcard = enable;
        return this;
    }

    /**
     * Sets the `lenient` parameter which allows to ignore exceptions caused
     * by data-type mismatches such as trying to query a numeric field with a
     * text query string when set to `true`.
     *
     * @param {boolean} enable Defaules to `false`
     * @returns {QueryStringQueryBase} returns `this` so that calls can be chained.
     */
    lenient(enable) {
        this._queryOpts.lenient = enable;
        return this;
    }

    /**
     * A suffix to append to fields for quoted parts of the query string.
     * This allows to use a field that has a different analysis chain for exact matching.
     *
     * @param {string} suffix
     * @returns {QueryStringQueryBase} returns `this` so that calls can be chained.
     */
    quoteFieldSuffix(suffix) {
        this._queryOpts.quote_field_suffix = suffix;
        return this;
    }

    /**
     * Perform the query on all fields detected in the mapping that can be queried.
     * Will be used by default when the `_all` field is disabled and
     * no `default_field` is specified (either in the index settings or
     * in the request body) and no `fields` are specified.
     * @param {boolean} enable
     * @returns {QueryStringQueryBase} returns `this` so that calls can be chained.
     */
    allFields(enable) {
        this._queryOpts.all_fields = enable;
        return this;
    }
};

var queryStringQueryBase = QueryStringQueryBase$2;

var helper = {};

const { inspect } = inspectExports;

const {
    util: { firstDigitPos },
    consts: { REWRITE_METHOD_SET }
} = core;

/**
 * Validate the rewrite method.
 *
 * @private
 * @param {string} method
 * @param {string} paramName
 * @param {string} refUrl
 * @throws {Error} If the given rewrite method is not valid.
 */
helper.validateRewiteMethod = function validateRewiteMethod(
    method,
    paramName,
    refUrl
) {
    // NOTE: This does not check for lower case comparison.
    if (!REWRITE_METHOD_SET.has(method)) {
        const rewriteMethodName = `${method.substring(
            0,
            firstDigitPos(method)
        )}N`;
        if (!REWRITE_METHOD_SET.has(rewriteMethodName)) {
            console.log(`See ${refUrl}`);
            console.warn(`Got '${paramName}' - ${method}`);
            throw new Error(
                `The '${paramName}' parameter should belong to ${inspect(
                    REWRITE_METHOD_SET
                )}`
            );
        }
    }
};

const isNil$_ = lodash_isnil;

const {
    util: { invalidParam: invalidParam$m }
} = core;
const MonoFieldQueryBase$2 = monoFieldQueryBase;
const { validateRewiteMethod: validateRewiteMethod$5 } = helper;

const ES_REF_URL$10 =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html';

const invalidOperatorParam$1 = invalidParam$m(
    ES_REF_URL$10,
    'operator',
    "'and' or 'or'"
);
const invalidZeroTermsQueryParam = invalidParam$m(
    ES_REF_URL$10,
    'zero_terms_query',
    "'all' or 'none'"
);

/**
 * `match` query accepts text/numerics/dates, analyzes them, and constructs a query.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html)
 *
 * @param {string=} field The document field to query against
 * @param {string=} queryString The query string
 *
 * @example
 * const matchQry = esb.matchQuery('message', 'to be or not to be');
 *
 * @example
 * // Providing additional parameters:
 * const qry = esb.matchQuery('message', 'this is a test').operator('and');
 *
 * @extends MonoFieldQueryBase
 */
let MatchQuery$1 = class MatchQuery extends MonoFieldQueryBase$2 {
    // NOTE: Did not add methods for `slop`, `phrase_slop` and `type`.
    // These are deprecated.

    // eslint-disable-next-line require-jsdoc
    constructor(field, queryString) {
        super('match', field, queryString);
    }

    /**
     * The operator to be used in the boolean query which is constructed
     * by analyzing the text provided. The `operator` flag can be set to `or` or
     * `and` to control the boolean clauses (defaults to `or`).
     *
     * @param {string} operator Can be `and`/`or`. Default is `or`.
     * @returns {MatchQuery} returns `this` so that calls can be chained.
     */
    operator(operator) {
        if (isNil$_(operator)) invalidOperatorParam$1(operator);

        const operatorLower = operator.toLowerCase();
        if (operatorLower !== 'and' && operatorLower !== 'or') {
            invalidOperatorParam$1(operator);
        }

        this._queryOpts.operator = operatorLower;
        return this;
    }

    /**
     * Sets the `lenient` parameter which allows to ignore exceptions caused
     * by data-type mismatches such as trying to query a numeric field with a
     * text query string when set to `true`.
     *
     * @param {boolean} enable Defaules to `false`
     * @returns {MatchQuery} returns `this` so that calls can be chained.
     */
    lenient(enable) {
        this._queryOpts.lenient = enable;
        return this;
    }

    /**
     * Sets the `fuzziness` parameter which is interpreted as a Levenshtein Edit Distance
     * the number of one character changes that need to be made to one string to make it
     * the same as another string.
     *
     * @param {number|string} factor Can be specified either as a number, or the maximum
     * number of edits, or as `AUTO` which generates an edit distance based on the length
     * of the term.
     * @returns {MatchQuery} returns `this` so that calls can be chained.
     */
    fuzziness(factor) {
        this._queryOpts.fuzziness = factor;
        return this;
    }

    /**
     * Sets the prefix length for a fuzzy prefix `MatchQuery`
     *
     * @param {number} len
     * @returns {MatchQuery} returns `this` so that calls can be chained.
     */
    prefixLength(len) {
        this._queryOpts.prefix_length = len;
        return this;
    }

    /**
     * Sets the max expansions for a fuzzy prefix `MatchQuery`
     *
     * @param {number} limit
     * @returns {MatchQuery} returns `this` so that calls can be chained.
     */
    maxExpansions(limit) {
        this._queryOpts.max_expansions = limit;
        return this;
    }

    /**
     * Sets the rewrite method. Valid values are:
     * - `constant_score` - tries to pick the best constant-score rewrite
     *  method based on term and document counts from the query.
     *  Synonyms - `constant_score_auto`, `constant_score_filter`
     *
     * - `scoring_boolean` - translates each term into boolean should and
     *  keeps the scores as computed by the query
     *
     * - `constant_score_boolean` - same as `scoring_boolean`, expect no scores
     *  are computed.
     *
     * - `constant_score_filter` - first creates a private Filter, by visiting
     *  each term in sequence and marking all docs for that term
     *
     * - `top_terms_boost_N` - first translates each term into boolean should
     *  and scores are only computed as the boost using the top N
     *  scoring terms. Replace N with an integer value.
     *
     * - `top_terms_N` - first translates each term into boolean should
     *  and keeps the scores as computed by the query. Only the top N
     *  scoring terms are used. Replace N with an integer value.
     *
     * Default is `constant_score`.
     *
     * Note: The deprecated multi term rewrite parameters `constant_score_auto`,
     * `constant_score_filter` (synonyms for `constant_score`) have been removed
     * in elasticsearch 6.0.
     *
     * This is an advanced option, use with care.
     *
     * @param {string} method The rewrite method as a string.
     * @returns {MatchQuery} returns `this` so that calls can be chained.
     * @throws {Error} If the given `rewrite` method is not valid.
     */
    rewrite(method) {
        validateRewiteMethod$5(method, 'rewrite', ES_REF_URL$10);

        this._queryOpts.rewrite = method;
        return this;
    }

    /**
     * Sets the fuzzy rewrite method. Valid values are:
     * - `constant_score` - tries to pick the best constant-score rewrite
     *  method based on term and document counts from the query.
     *  Synonyms - `constant_score_auto`, `constant_score_filter`
     *
     * - `scoring_boolean` - translates each term into boolean should and
     *  keeps the scores as computed by the query
     *
     * - `constant_score_boolean` - same as `scoring_boolean`, expect no scores
     *  are computed.
     *
     * - `constant_score_filter` - first creates a private Filter, by visiting
     *  each term in sequence and marking all docs for that term
     *
     * - `top_terms_boost_N` - first translates each term into boolean should
     *  and scores are only computed as the boost using the top N
     *  scoring terms. Replace N with an integer value.
     *
     * - `top_terms_N` - first translates each term into boolean should
     *  and keeps the scores as computed by the query. Only the top N
     *  scoring terms are used. Replace N with an integer value.
     *
     * Default is `constant_score`.
     *
     * This is an advanced option, use with care.
     *
     * Note: The deprecated multi term rewrite parameters `constant_score_auto`,
     * `constant_score_filter` (synonyms for `constant_score`) have been removed
     * in elasticsearch 6.0.
     *
     * @param {string} method The rewrite method as a string.
     * @returns {MatchQuery} returns `this` so that calls can be chained.
     * @throws {Error} If the given `fuzzy_rewrite` method is not valid.
     */
    fuzzyRewrite(method) {
        validateRewiteMethod$5(method, 'fuzzy_rewrite', ES_REF_URL$10);

        this._queryOpts.fuzzy_rewrite = method;
        return this;
    }

    /**
     * Fuzzy transpositions (`ab`  `ba`) are allowed by default but can be disabled
     * by setting `fuzzy_transpositions` to false.
     * @param {boolean} enable
     * @returns {MatchQuery} returns `this` so that calls can be chained.
     */
    fuzzyTranspositions(enable) {
        this._queryOpts.fuzzy_transpositions = enable;
        return this;
    }

    /**
     * If the analyzer used removes all tokens in a query like a `stop` filter does,
     * the default behavior is to match no documents at all. In order to change that
     * the `zero_terms_query` option can be used, which accepts `none` (default) and `all`
     * which corresponds to a `match_all` query.
     *
     * @example
     * const qry = esb.matchQuery('message', 'to be or not to be')
     *     .operator('and')
     *     .zeroTermsQuery('all');
     *
     * @param {string} behavior A no match action, `all` or `none`. Default is `none`.
     * @returns {MatchQuery} returns `this` so that calls can be chained.
     */
    zeroTermsQuery(behavior) {
        if (isNil$_(behavior)) invalidZeroTermsQueryParam(behavior);

        const behaviorLower = behavior.toLowerCase();
        if (behaviorLower !== 'all' && behaviorLower !== 'none') {
            invalidZeroTermsQueryParam(behavior);
        }

        this._queryOpts.zero_terms_query = behaviorLower;
        return this;
    }

    /**
     * Allows specifying an absolute or relative document frequency where high frequency
     * terms are moved into an optional subquery and are only scored if one of the
     * low frequency (below the cutoff) terms in the case of an `or` operator or
     * all of the low frequency terms in the case of an `and` operator match.
     *
     * @example
     * const qry = esb.matchQuery('message', 'to be or not to be')
     *     .cutoffFrequency(0.001);
     *
     * @param {number} frequency It can either be relative to the total number of documents
     * if in the range `[0..1)` or absolute if greater or equal to `1.0`.
     * @returns {MatchQuery} returns `this` so that calls can be chained.
     */
    cutoffFrequency(frequency) {
        this._queryOpts.cutoff_frequency = frequency;
        return this;
    }
};

var matchQuery$2 = MatchQuery$1;

const MatchPhraseQueryBase$1 = matchPhraseQueryBase;

const ES_REF_URL$$ =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html';

/**
 * The `match_phrase` query analyzes the text and creates a `phrase` query out of
 * the analyzed text.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html)
 *
 * @example
 * const qry = esb.matchPhraseQuery('message', 'to be or not to be');
 *
 * @param {string=} field The document field to query against
 * @param {string=} queryString The query string
 *
 * @extends MatchPhraseQueryBase
 */
let MatchPhraseQuery$1 = class MatchPhraseQuery extends MatchPhraseQueryBase$1 {
    // eslint-disable-next-line require-jsdoc
    constructor(field, queryString) {
        super('match_phrase', ES_REF_URL$$, field, queryString);
    }
};

var matchPhraseQuery$2 = MatchPhraseQuery$1;

const MatchPhraseQueryBase = matchPhraseQueryBase;

const ES_REF_URL$_ =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html';

/**
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html)
 *
 * @example
 * const qry = esb.matchPhrasePrefixQuery('message', 'quick brown f');
 *
 * @param {string=} field The document field to query against
 * @param {string=} queryString The query string
 *
 * @extends MatchPhraseQueryBase
 */
let MatchPhrasePrefixQuery$1 = class MatchPhrasePrefixQuery extends MatchPhraseQueryBase {
    // eslint-disable-next-line require-jsdoc
    constructor(field, queryString) {
        super('match_phrase_prefix', ES_REF_URL$_, field, queryString);
    }

    /**
     * Control to how many prefixes the last term will be expanded.
     *
     * @example
     * const qry = esb.matchPhrasePrefixQuery('message', 'quick brown f')
     *     .maxExpansions(10);
     *
     * @param {number} limit Defaults to 50.
     * @returns {MatchPhrasePrefixQuery} returns `this` so that calls can be chained.
     */
    maxExpansions(limit) {
        this._queryOpts.max_expansions = limit;
        return this;
    }
};

var matchPhrasePrefixQuery$2 = MatchPhrasePrefixQuery$1;

const isNil$Z = lodash_isnil;

const {
    util: { checkType: checkType$F, invalidParam: invalidParam$l },
    consts: { MULTI_MATCH_TYPE }
} = core;
const FullTextQueryBase = fullTextQueryBase;
const { validateRewiteMethod: validateRewiteMethod$4 } = helper;

const ES_REF_URL$Z =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html';

const invalidTypeParam$1 = invalidParam$l(ES_REF_URL$Z, 'type', MULTI_MATCH_TYPE);
const invalidOperatorParam = invalidParam$l(
    ES_REF_URL$Z,
    'operator',
    "'and' or 'or'"
);
const invalidBehaviorParam = invalidParam$l(
    ES_REF_URL$Z,
    'behavior',
    "'all' or 'none'"
);

/**
 * A `MultiMatchQuery` query builds further on top of the
 * `MultiMatchQuery` by allowing multiple fields to be specified.
 * The idea here is to allow to more easily build a concise match type query
 * over multiple fields instead of using a relatively more expressive query
 * by using multiple match queries within a bool query.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-match-query.html)
 *
 * @example
 * const qry = esb.multiMatchQuery(['subject', 'message'], 'this is a test');
 *
 * @param {Array<string>|string=} fields The fields to be queried
 * @param {string=} queryString The query string
 *
 * @extends FullTextQueryBase
 */
let MultiMatchQuery$2 = class MultiMatchQuery extends FullTextQueryBase {
    // Extremely similar to match query.
    // mixins are one way to go about it.
    // repeating code for now

    // eslint-disable-next-line require-jsdoc
    constructor(fields, queryString) {
        super('multi_match', queryString);

        // This field is required
        // Avoid checking for key in `this.field`
        this._queryOpts.fields = [];

        if (!isNil$Z(fields)) {
            if (Array.isArray(fields)) this.fields(fields);
            else this.field(fields);
        }
    }

    /**
     * Appends given field to the list of fields to search against.
     * Fields can be specified with wildcards.
     * Individual fields can be boosted with the caret (^) notation.
     * Example - `"subject^3"`
     *
     * @param {string} field One of the fields to be queried
     * @returns {MultiMatchQuery} returns `this` so that calls can be chained.
     */
    field(field) {
        this._queryOpts.fields.push(field);
        return this;
    }

    /**
     * Appends given fields to the list of fields to search against.
     * Fields can be specified with wildcards.
     * Individual fields can be boosted with the caret (^) notation.
     *
     * @example
     * // Boost individual fields with caret `^` notation
     * const qry = esb.multiMatchQuery(['subject^3', 'message'], 'this is a test');
     *
     * @example
     * // Specify fields with wildcards
     * const qry = esb.multiMatchQuery(['title', '*_name'], 'Will Smith');
     *
     * @param {Array<string>} fields The fields to be queried
     * @returns {MultiMatchQuery} returns `this` so that calls can be chained.
     */
    fields(fields) {
        checkType$F(fields, Array);

        this._queryOpts.fields = this._queryOpts.fields.concat(fields);
        return this;
    }

    /**
     * Sets the type of multi match query. Valid values are:
     * - `best_fields` - (default) Finds documents which match any field,
     * but uses the `_score` from the best field.
     *
     * - `most_fields` - Finds documents which match any field and combines
     * the `_score` from each field.
     *
     * - `cross_fields` - Treats fields with the same `analyzer` as though
     * they were one big field. Looks for each word in *any* field
     *
     * - `phrase` - Runs a `match_phrase` query on each field and combines
     * the `_score` from each field.
     *
     * - `phrase_prefix` - Runs a `match_phrase_prefix` query on each field
     * and combines the `_score` from each field.
     *
     * - `bool_prefix` - (added in v7.2) Creates a match_bool_prefix query on each field and
     * combines the _score from each field.
     *
     * @example
     * // Find the single best matching field
     * const qry = esb.multiMatchQuery(['subject', 'message'], 'brown fox')
     *     .type('best_fields')
     *     .tieBreaker(0.3);
     *
     * @example
     * // Query multiple fields analyzed differently for the same text
     * const qry = esb.multiMatchQuery(
     *     ['title', 'title.original', 'title.shingles'],
     *     'quick brown fox'
     * ).type('most_fields');
     *
     * @example
     * // Run a `match_phrase_prefix` query on multiple fields
     * const qry = esb.multiMatchQuery(
     *     ['subject', 'message'],
     *     'quick brown f'
     * ).type('phrase_prefix');
     *
     * @example
     * // All terms must be present in at least one field for document to match
     * const qry = esb.multiMatchQuery(['first_name', 'last_name'], 'Will Smith')
     *     .type('cross_fields')
     *     .operator('and');
     *
     * @param {string} type Can be one of `best_fields`, `most_fields`,
     * `cross_fields`, `phrase`, `phrase_prefix` and `bool_prefix`. Default is
     * `best_fields`.
     * @returns {MultiMatchQuery} returns `this` so that calls can be chained.
     */
    type(type) {
        if (isNil$Z(type)) invalidTypeParam$1(type);

        const typeLower = type.toLowerCase();
        if (!MULTI_MATCH_TYPE.has(typeLower)) invalidTypeParam$1(type);

        this._queryOpts.type = typeLower;
        return this;
    }

    /**
     * The tie breaker value. The tie breaker capability allows results
     * that include the same term in multiple fields to be judged better than
     * results that include this term in only the best of those multiple
     * fields, without confusing this with the better case of two different
     * terms in the multiple fields. Default: `0.0`.
     *
     * @param {number} factor
     * @returns {MultiMatchQuery} returns `this` so that calls can be chained.
     */
    tieBreaker(factor) {
        this._queryOpts.tie_breaker = factor;
        return this;
    }

    /**
     * The operator to be used in the boolean query which is constructed
     * by analyzing the text provided. The `operator` flag can be set to `or` or
     * `and` to control the boolean clauses (defaults to `or`).
     *
     * @param {string} operator Can be `and`/`or`. Default is `or`.
     * @returns {MultiMatchQuery} returns `this` so that calls can be chained.
     */
    operator(operator) {
        if (isNil$Z(operator)) invalidOperatorParam(operator);

        const operatorLower = operator.toLowerCase();
        if (operatorLower !== 'and' && operatorLower !== 'or') {
            invalidOperatorParam(operator);
        }

        this._queryOpts.operator = operatorLower;
        return this;
    }

    /**
     * Sets the `lenient` parameter which allows to ignore exceptions caused
     * by data-type mismatches such as trying to query a numeric field with a
     * text query string when set to `true`.
     *
     * @param {boolean} enable Defaules to `false`
     * @returns {MultiMatchQuery} returns `this` so that calls can be chained.
     */
    lenient(enable) {
        this._queryOpts.lenient = enable;
        return this;
    }

    // phrase_slop is a synonym for slop.
    // haven't added method for it..

    /**
     * Configures the `slop`(default is 0) for matching terms in any order.
     * Transposed terms have a slop of 2.
     *
     * @param {number} slop A positive integer value, defaults is 0.
     * @returns {MultiMatchQuery} returns `this` so that calls can be chained.
     */
    slop(slop) {
        this._queryOpts.slop = slop;
        return this;
    }

    /**
     * Sets the `fuzziness` parameter which is interpreted as a Levenshtein Edit Distance
     * the number of one character changes that need to be made to one string to make it
     * the same as another string.
     *
     * The `fuzziness` parameter cannot be used with the `phrase`, `phrase_prefix`
     * or `cross_fields` type.
     *
     * @param {number|string} factor Can be specified either as a number, or the maximum
     * number of edits, or as `AUTO` which generates an edit distance based on the length
     * of the term.
     * @returns {MultiMatchQuery} returns `this` so that calls can be chained.
     */
    fuzziness(factor) {
        this._queryOpts.fuzziness = factor;
        return this;
    }

    /**
     * Sets the prefix length for a fuzzy prefix `MultiMatchQuery`
     *
     * @param {number} len
     * @returns {MultiMatchQuery} returns `this` so that calls can be chained.
     */
    prefixLength(len) {
        this._queryOpts.prefix_length = len;
        return this;
    }

    /**
     * Sets the max expansions for a fuzzy prefix `MultiMatchQuery`
     *
     * @param {number} limit
     * @returns {MultiMatchQuery} returns `this` so that calls can be chained.
     */
    maxExpansions(limit) {
        this._queryOpts.max_expansions = limit;
        return this;
    }

    /**
     * Sets the rewrite method. Valid values are:
     * - `constant_score` - tries to pick the best constant-score rewrite
     *  method based on term and document counts from the query.
     *  Synonyms - `constant_score_auto`, `constant_score_filter`
     *
     * - `scoring_boolean` - translates each term into boolean should and
     *  keeps the scores as computed by the query
     *
     * - `constant_score_boolean` - same as `scoring_boolean`, expect no scores
     *  are computed.
     *
     * - `constant_score_filter` - first creates a private Filter, by visiting
     *  each term in sequence and marking all docs for that term
     *
     * - `top_terms_boost_N` - first translates each term into boolean should
     *  and scores are only computed as the boost using the top N
     *  scoring terms. Replace N with an integer value.
     *
     * - `top_terms_N` - first translates each term into boolean should
     *  and keeps the scores as computed by the query. Only the top N
     *  scoring terms are used. Replace N with an integer value.
     *
     * Default is `constant_score`.
     *
     * This is an advanced option, use with care.
     *
     * Note: The deprecated multi term rewrite parameters `constant_score_auto`,
     * `constant_score_filter` (synonyms for `constant_score`) have been removed
     * in elasticsearch 6.0.
     *
     * @param {string} method The rewrite method as a string.
     * @returns {MultiMatchQuery} returns `this` so that calls can be chained.
     * @throws {Error} If the given `rewrite` method is not valid.
     */
    rewrite(method) {
        validateRewiteMethod$4(method, 'rewrite', ES_REF_URL$Z);

        this._queryOpts.rewrite = method;
        return this;
    }

    /**
     * Sets the fuzzy rewrite method. Valid values are:
     * - `constant_score` - tries to pick the best constant-score rewrite
     *  method based on term and document counts from the query.
     *  Synonyms - `constant_score_auto`, `constant_score_filter`
     *
     * - `scoring_boolean` - translates each term into boolean should and
     *  keeps the scores as computed by the query
     *
     * - `constant_score_boolean` - same as `scoring_boolean`, expect no scores
     *  are computed.
     *
     * - `constant_score_filter` - first creates a private Filter, by visiting
     *  each term in sequence and marking all docs for that term
     *
     * - `top_terms_boost_N` - first translates each term into boolean should
     *  and scores are only computed as the boost using the top N
     *  scoring terms. Replace N with an integer value.
     *
     * - `top_terms_N` - first translates each term into boolean should
     *  and keeps the scores as computed by the query. Only the top N
     *  scoring terms are used. Replace N with an integer value.
     *
     * Default is `constant_score`.
     *
     * This is an advanced option, use with care.
     *
     * Note: The deprecated multi term rewrite parameters `constant_score_auto`,
     * `constant_score_filter` (synonyms for `constant_score`) have been removed
     * in elasticsearch 6.0.
     *
     * @param {string} method The rewrite method as a string.
     * @returns {MultiMatchQuery} returns `this` so that calls can be chained.
     * @throws {Error} If the given `fuzzy_rewrite` method is not valid.
     */
    fuzzyRewrite(method) {
        validateRewiteMethod$4(method, 'fuzzy_rewrite', ES_REF_URL$Z);

        this._queryOpts.fuzzy_rewrite = method;
        return this;
    }

    /**
     * If the analyzer used removes all tokens in a query like a `stop` filter does,
     * the default behavior is to match no documents at all. In order to change that
     * the `zero_terms_query` option can be used, which accepts `none` (default) and `all`
     * which corresponds to a `match_all` query.
     *
     * @param {string} behavior A no match action, `all` or `none`. Default is `none`.
     * @returns {MultiMatchQuery} returns `this` so that calls can be chained.
     */
    zeroTermsQuery(behavior) {
        if (isNil$Z(behavior)) invalidBehaviorParam(behavior);

        const behaviorLower = behavior.toLowerCase();
        if (behaviorLower !== 'all' && behaviorLower !== 'none') {
            invalidBehaviorParam(behavior);
        }

        this._queryOpts.zero_terms_query = behavior;
        return this;
    }

    /**
     * Allows specifying an absolute or relative document frequency where high frequency
     * terms are moved into an optional subquery and are only scored if one of the
     * low frequency (below the cutoff) terms in the case of an `or` operator or
     * all of the low frequency terms in the case of an `and` operator match.
     *
     * @param {number} frequency It can either be relative to the total number of documents
     * if in the range `[0..1)` or absolute if greater or equal to `1.0`.
     * @returns {MultiMatchQuery} returns `this` so that calls can be chained.
     */
    cutoffFrequency(frequency) {
        this._queryOpts.cutoff_frequency = frequency;
        return this;
    }
};

var multiMatchQuery$2 = MultiMatchQuery$2;

const isNil$Y = lodash_isnil;
const isObject$2 = lodash_isobject;

const {
    util: { invalidParam: invalidParam$k, setDefault: setDefault$7 }
} = core;

const MonoFieldQueryBase$1 = monoFieldQueryBase;

const ES_REF_URL$Y =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-common-terms-query.html';

const invalidLowFreqOpParam = invalidParam$k(
    ES_REF_URL$Y,
    'low_freq_operator',
    "'and' or 'or'"
);
const invalidHighFreqOpParam = invalidParam$k(
    ES_REF_URL$Y,
    'high_freq_operator',
    "'and' or 'or'"
);

/**
 * The `common` terms query is a modern alternative to stopwords which
 * improves the precision and recall of search results (by taking
 * stopwords into account), without sacrificing performance.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-common-terms-query.html)
 *
 * @example
 * const qry = esb.commonTermsQuery('body','this is bonsai cool')
 *     .cutoffFrequency(0.001);
 *
 * @param {string=} field The document field to query against
 * @param {string=} queryString The query string
 *
 * @extends MonoFieldQueryBase
 */
let CommonTermsQuery$1 = class CommonTermsQuery extends MonoFieldQueryBase$1 {
    // eslint-disable-next-line require-jsdoc
    constructor(field, queryString) {
        super('common', field, queryString);
    }

    /**
     * Print warning message to console namespaced by class name.
     *
     * @param {string} msg
     * @private
     */
    _warn(msg) {
        console.warn(`[CommonTermsQuery] ${msg}`);
    }

    /**
     * Print warning messages to not mix Geo Point representations
     * @private
     */
    _warnMixedRepr() {
        this._warn('Do not mix with other representation!');
        this._warn('Overwriting.');
    }

    /**
     * Check the instance for object representation of Geo Point.
     * If representation is null, new object is initialised.
     * If it is not null, warning is logged and point is overwritten.
     * @private
     */
    _checkMinMatchRepr() {
        if (
            !setDefault$7(this._queryOpts, 'minimum_should_match', {}) &&
            !isObject$2(this._queryOpts.minimum_should_match)
        ) {
            this._warnMixedRepr();
            this._queryOpts.minimum_should_match = {};
        }
    }

    /**
     * Allows specifying an absolute or relative document frequency where high frequency
     * terms are moved into an optional subquery and are only scored if one of the
     * low frequency (below the cutoff) terms in the case of an `or` operator or
     * all of the low frequency terms in the case of an `and` operator match.
     *
     * @param {number} frequency It can either be relative to the total number of documents
     * if in the range `[0..1)` or absolute if greater or equal to `1.0`.
     * @returns {CommonTermsQuery} returns `this` so that calls can be chained.
     */
    cutoffFrequency(frequency) {
        this._queryOpts.cutoff_frequency = frequency;
        return this;
    }

    /**
     * The operator to be used on low frequency terms in the boolean query
     * which is constructed by analyzing the text provided. The `operator` flag
     * can be set to `or` or `and` to control the boolean clauses (defaults to `or`).
     *
     * @example
     * const qry = esb.commonTermsQuery('body', 'nelly the elephant as a cartoon')
     *     .lowFreqOperator('and')
     *     .cutoffFrequency(0.001);
     *
     * @param {string} operator Can be `and`/`or`. Default is `or`.
     * @returns {CommonTermsQuery} returns `this` so that calls can be chained.
     */
    lowFreqOperator(operator) {
        if (isNil$Y(operator)) invalidLowFreqOpParam(operator);

        const operatorLower = operator.toLowerCase();
        if (operatorLower !== 'and' && operatorLower !== 'or') {
            invalidLowFreqOpParam(operator);
        }

        this._queryOpts.low_freq_operator = operatorLower;
        return this;
    }

    /**
     * The operator to be used on high frequency terms in the boolean query
     * which is constructed by analyzing the text provided. The `operator` flag
     * can be set to `or` or `and` to control the boolean clauses (defaults to `or`).
     *
     * @param {string} operator Can be `and`/`or`. Default is `or`.
     * @returns {CommonTermsQuery} returns `this` so that calls can be chained.
     */
    highFreqOperator(operator) {
        if (isNil$Y(operator)) invalidHighFreqOpParam(operator);

        const operatorLower = operator.toLowerCase();
        if (operatorLower !== 'and' && operatorLower !== 'or') {
            invalidHighFreqOpParam(operator);
        }

        this._queryOpts.high_freq_operator = operatorLower;
        return this;
    }

    /**
     * Sets the value controlling how many "should" clauses in the resulting boolean
     * query should match for low frequency terms. It can be an absolute value (2),
     * a percentage (30%) or a combination of both.
     *
     * @example
     * const qry = esb.commonTermsQuery('body', 'nelly the elephant as a cartoon')
     *     .lowFreq(2)
     *     .highFreq(3)
     *     .cutoffFrequency(0.001);
     *
     * @param {string|number} lowFreqMinMatch
     * @returns {CommonTermsQuery} returns `this` so that calls can be chained.
     */
    lowFreq(lowFreqMinMatch) {
        this._checkMinMatchRepr();

        this._queryOpts.minimum_should_match.low_freq = lowFreqMinMatch;
        return this;
    }

    /**
     * Sets the value controlling how many "should" clauses in the resulting boolean
     * query should match for high frequency terms. It can be an absolute value (2),
     * a percentage (30%) or a combination of both.
     *
     * @example
     * const qry = esb.commonTermsQuery('body', 'nelly the elephant as a cartoon')
     *     .lowFreq(2)
     *     .highFreq(3)
     *     .cutoffFrequency(0.001);
     *
     * @param {string|number} highFreqMinMatch
     * @returns {CommonTermsQuery} returns `this` so that calls can be chained.
     */
    highFreq(highFreqMinMatch) {
        this._checkMinMatchRepr();

        this._queryOpts.minimum_should_match.high_freq = highFreqMinMatch;
        return this;
    }

    /**
     * Enables or disables similarity coordinate scoring of documents
     * commoning the `CommonTermsQuery`. Default: `false`.
     *
     * **NOTE**: This has been removed in elasticsearch 6.0. If provided,
     * it will be ignored and a deprecation warning will be issued.
     *
     * @param {boolean} enable
     * @returns {CommonTermsQuery} returns `this` so that calls can be chained.
     */
    disableCoord(enable) {
        this._queryOpts.disable_coord = enable;
        return this;
    }
};

var commonTermsQuery$2 = CommonTermsQuery$1;

const QueryStringQueryBase$1 = queryStringQueryBase;
const { validateRewiteMethod: validateRewiteMethod$3 } = helper;

const ES_REF_URL$X =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html';

/**
 * A query that uses a query parser in order to parse its content.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-query-string-query.html)
 *
 * @example
 * const qry = esb.queryStringQuery('this AND that OR thus')
 *     .defaultField('content');
 *
 * @param {string=} queryString The actual query to be parsed.
 *
 * @extends QueryStringQueryBase
 */
let QueryStringQuery$1 = class QueryStringQuery extends QueryStringQueryBase$1 {
    // eslint-disable-next-line require-jsdoc
    constructor(queryString) {
        super('query_string', ES_REF_URL$X, queryString);
    }

    /**
     * The default field for query terms if no prefix field is specified.
     * Defaults to the `index.query.default_field` index settings, which
     * in turn defaults to `_all`.
     *
     * @param {string} field
     * @returns {QueryStringQuery} returns `this` so that calls can be chained.
     */
    defaultField(field) {
        this._queryOpts.default_field = field;
        return this;
    }

    /**
     * When set, `*` or `?` are allowed as the first character. Defaults to `true`.
     *
     * @param {boolean} enable
     * @returns {QueryStringQuery} returns `this` so that calls can be chained.
     */
    allowLeadingWildcard(enable) {
        this._queryOpts.allow_leading_wildcard = enable;
        return this;
    }

    /**
     * Set to true to enable position increments in result queries. Defaults to true.
     *
     * @param {boolean} enable
     * @returns {QueryStringQuery} returns `this` so that calls can be chained.
     */
    enablePositionIncrements(enable) {
        this._queryOpts.enable_position_increments = enable;
        return this;
    }

    /**
     * Controls the number of terms fuzzy queries will expand to. Defaults to `50`.
     *
     * @param {number} limit
     * @returns {QueryStringQuery} returns `this` so that calls can be chained.
     */
    fuzzyMaxExpansions(limit) {
        this._queryOpts.fuzzy_max_expansions = limit;
        return this;
    }

    /**
     * Sets the `fuzziness` parameter which is interpreted as a Levenshtein Edit Distance
     * the number of one character changes that need to be made to one string to make it
     * the same as another string. Defaults to `AUTO`.
     *
     * @param {number|string} factor Can be specified either as a number, or the maximum
     * number of edits, or as `AUTO` which generates an edit distance based on the length
     * of the term. Defaults to `AUTO`.
     * @returns {QueryStringQuery} returns `this` so that calls can be chained.
     */
    fuzziness(factor) {
        this._queryOpts.fuzziness = factor;
        return this;
    }

    /**
     * Set the prefix length for fuzzy queries. Default is `0`.
     *
     * @param {number} len
     * @returns {QueryStringQuery} returns `this` so that calls can be chained.
     */
    fuzzyPrefixLength(len) {
        this._queryOpts.fuzzy_prefix_length = len;
        return this;
    }

    /**
     * Sets the rewrite method. Valid values are:
     * - `constant_score` - tries to pick the best constant-score rewrite
     *  method based on term and document counts from the query.
     *  Synonyms - `constant_score_auto`, `constant_score_filter`
     *
     * - `scoring_boolean` - translates each term into boolean should and
     *  keeps the scores as computed by the query
     *
     * - `constant_score_boolean` - same as `scoring_boolean`, expect no scores
     *  are computed.
     *
     * - `constant_score_filter` - first creates a private Filter, by visiting
     *  each term in sequence and marking all docs for that term
     *
     * - `top_terms_boost_N` - first translates each term into boolean should
     *  and scores are only computed as the boost using the top N
     *  scoring terms. Replace N with an integer value.
     *
     * - `top_terms_N` - first translates each term into boolean should
     *  and keeps the scores as computed by the query. Only the top N
     *  scoring terms are used. Replace N with an integer value.
     *
     * Default is `constant_score`.
     *
     * This is an advanced option, use with care.
     *
     * Note: The deprecated multi term rewrite parameters `constant_score_auto`,
     * `constant_score_filter` (synonyms for `constant_score`) have been removed
     * in elasticsearch 6.0.
     *
     * @param {string} method The rewrite method as a string.
     * @returns {QueryStringQuery} returns `this` so that calls can be chained.
     * @throws {Error} If the given `rewrite` method is not valid.
     */
    rewrite(method) {
        validateRewiteMethod$3(method, 'rewrite', ES_REF_URL$X);

        this._queryOpts.rewrite = method;
        return this;
    }

    /**
     * Sets the fuzzy rewrite method. Valid values are:
     * - `constant_score` - tries to pick the best constant-score rewrite
     *  method based on term and document counts from the query.
     *  Synonyms - `constant_score_auto`, `constant_score_filter`
     *
     * - `scoring_boolean` - translates each term into boolean should and
     *  keeps the scores as computed by the query
     *
     * - `constant_score_boolean` - same as `scoring_boolean`, expect no scores
     *  are computed.
     *
     * - `constant_score_filter` - first creates a private Filter, by visiting
     *  each term in sequence and marking all docs for that term
     *
     * - `top_terms_boost_N` - first translates each term into boolean should
     *  and scores are only computed as the boost using the top N
     *  scoring terms. Replace N with an integer value.
     *
     * - `top_terms_N` - first translates each term into boolean should
     *  and keeps the scores as computed by the query. Only the top N
     *  scoring terms are used. Replace N with an integer value.
     *
     * Default is `constant_score`.
     *
     * This is an advanced option, use with care.
     *
     * Note: The deprecated multi term rewrite parameters `constant_score_auto`,
     * `constant_score_filter` (synonyms for `constant_score`) have been removed
     * in elasticsearch 6.0.
     *
     * @param {string} method The rewrite method as a string.
     * @returns {QueryStringQuery} returns `this` so that calls can be chained.
     * @throws {Error} If the given `fuzzy_rewrite` method is not valid.
     */
    fuzzyRewrite(method) {
        validateRewiteMethod$3(method, 'fuzzy_rewrite', ES_REF_URL$X);

        this._queryOpts.fuzzy_rewrite = method;
        return this;
    }

    /**
     * Sets the default slop for phrases. If zero, then exact phrase matches are required.
     * Default value is 0.
     *
     * @param {number} slop A positive integer value, defaults is 0.
     * @returns {QueryStringQuery} returns `this` so that calls can be chained.
     */
    phraseSlop(slop) {
        this._queryOpts.phrase_slop = slop;
        return this;
    }

    /**
     * Auto generate phrase queries. Defaults to `false`.
     *
     * Note: This parameter has been removed in elasticsearch 6.0. If provided,
     * it will be ignored and issue a deprecation warning.
     *
     * @param {boolean} enable
     * @returns {QueryStringQuery} returns `this` so that calls can be chained.
     */
    autoGeneratePhraseQueries(enable) {
        this._queryOpts.auto_generate_phrase_queries = enable;
        return this;
    }

    /**
     * Limit on how many automaton states regexp queries are allowed to create.
     * This protects against too-difficult (e.g. exponentially hard) regexps.
     * Defaults to 10000.
     *
     * @param {number} limit
     * @returns {QueryStringQuery} returns `this` so that calls can be chained.
     */
    maxDeterminizedStates(limit) {
        this._queryOpts.max_determinized_states = limit;
        return this;
    }

    /**
     * Time Zone to be applied to any range query related to dates.
     *
     * @param {string} zone
     * @returns {QueryStringQuery} returns `this` so that calls can be chained.
     */
    timeZone(zone) {
        this._queryOpts.time_zone = zone;
        return this;
    }

    /**
     * Whether query text should be split on whitespace prior to analysis.
     * Instead the queryparser would parse around only real operators.
     * Default is `false`. It is not allowed to set this option to `false`
     * if `auto_generate_phrase_queries` is already set to `true`.
     *
     * Note: This parameter has been removed in elasticsearch 6.0. If provided,
     * it will be ignored and issue a deprecation warning. The `query_string`
     * query now splits on operator only.
     *
     * @param {string} enable
     * @returns {QueryStringQuery} returns `this` so that calls can be chained.
     */
    splitOnWhitespace(enable) {
        this._queryOpts.split_on_whitespace = enable;
        return this;
    }

    /**
     * Should the queries be combined using `dis_max` (set it to `true`),
     * or a bool query (set it to `false`). Defaults to `true`.
     *
     * Note: This parameter has been removed in elasticsearch 6.0. If provided,
     * it will be ignored and issue a deprecation warning. The `tie_breaker`
     * parameter must be used instead.
     *
     * @example
     * const qry = esb.queryStringQuery('this AND that OR thus')
     *     .fields(['content', 'name^5'])
     *     .useDisMax(true);
     *
     * @param {boolean} enable
     * @returns {QueryStringQuery} returns `this` so that calls can be chained.
     */
    useDisMax(enable) {
        this._queryOpts.use_dis_max = enable;
        return this;
    }

    /**
     * When using `dis_max`, the disjunction max tie breaker. Defaults to `0`.
     *
     * @param {number} factor
     * @returns {QueryStringQuery} returns `this` so that calls can be chained.
     */
    tieBreaker(factor) {
        this._queryOpts.tie_breaker = factor;
        return this;
    }

    /**
     * Sets the quote analyzer name used to analyze the `query`
     * when in quoted text.
     *
     * @param {string} analyzer A valid analyzer name.
     * @returns {QueryStringQuery} returns `this` so that calls can be chained.
     */
    quoteAnalyzer(analyzer) {
        this._queryOpts.quote_analyzer = analyzer;
        return this;
    }

    /**
     * If they query string should be escaped or not.
     *
     * @param {boolean} enable
     * @returns {QueryStringQuery} returns `this` so that calls can be chained.
     */
    escape(enable) {
        this._queryOpts.escape = enable;
        return this;
    }
};

var queryStringQuery$2 = QueryStringQuery$1;

const QueryStringQueryBase = queryStringQueryBase;

const ES_REF_URL$W =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-simple-query-string-query.html';

/**
 * A query that uses the `SimpleQueryParser` to parse its context.
 * Unlike the regular `query_string` query, the `simple_query_string` query
 * will never throw an exception, and discards invalid parts of the query.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-simple-query-string-query.html)
 *
 * @example
 * const qry = esb.simpleQueryStringQuery(
 *     '"fried eggs" +(eggplant | potato) -frittata'
 * )
 *     .analyzer('snowball')
 *     .fields(['body^5', '_all'])
 *     .defaultOperator('and');
 *
 * @param {string=} queryString The query string
 *
 * @extends QueryStringQueryBase
 */
let SimpleQueryStringQuery$1 = class SimpleQueryStringQuery extends QueryStringQueryBase {
    // eslint-disable-next-line require-jsdoc
    constructor(queryString) {
        super('simple_query_string', ES_REF_URL$W, queryString);
    }

    /**
     * `simple_query_string` support multiple flags to specify which parsing features
     * should be enabled. It is specified as a `|`-delimited string.
     *
     * @example
     * const qry = esb.simpleQueryStringQuery('foo | bar + baz*')
     *     .flags('OR|AND|PREFIX');
     *
     * @param {string} flags `|` delimited string. The available flags are: `ALL`, `NONE`,
     * `AND`, `OR`, `NOT`, `PREFIX`, `PHRASE`, `PRECEDENCE`, `ESCAPE`, `WHITESPACE`,
     * `FUZZY`, `NEAR`, and `SLOP`.
     * @returns {SimpleQueryStringQuery} returns `this` so that calls can be chained.
     */
    flags(flags) {
        this._queryOpts.flags = flags;
        return this;
    }
};

var simpleQueryStringQuery$2 = SimpleQueryStringQuery$1;

const MonoFieldQueryBase = monoFieldQueryBase;

let NeuralQuery$2 = class NeuralQuery extends MonoFieldQueryBase {
    // eslint-disable-next-line require-jsdoc
    constructor(field, queryString) {
        const reservedEmbeddingFieldEnding = '_retake_embedding';

        super('neural', `${field}${reservedEmbeddingFieldEnding}`, {
            query_text: queryString
        });
    }
};

var neuralQuery$2 = NeuralQuery$2;

fullTextQueries.FullTextQueryBase = fullTextQueryBase;
fullTextQueries.MatchPhraseQueryBase = matchPhraseQueryBase;
fullTextQueries.MonoFieldQueryBase = monoFieldQueryBase;
fullTextQueries.QueryStringQueryBase = queryStringQueryBase;

fullTextQueries.MatchQuery = matchQuery$2;
fullTextQueries.MatchPhraseQuery = matchPhraseQuery$2;
fullTextQueries.MatchPhrasePrefixQuery = matchPhrasePrefixQuery$2;
fullTextQueries.MultiMatchQuery = multiMatchQuery$2;
fullTextQueries.CommonTermsQuery = commonTermsQuery$2;
fullTextQueries.QueryStringQuery = queryStringQuery$2;
fullTextQueries.SimpleQueryStringQuery = simpleQueryStringQuery$2;
fullTextQueries.NeuralQuery = neuralQuery$2;

var termLevelQueries = {};

const has$5 = lodash_has;
const isNil$X = lodash_isnil;

const { Query: Query$o } = core;

/**
 * The `ValueTermQueryBase` provides support for common options used across
 * various term level query implementations.
 *
 * @param {string} queryType
 * @param {string=} field The document field to query against
 * @param {string=} value The query string
 *
 * @extends Query
 */
let ValueTermQueryBase$2 = class ValueTermQueryBase extends Query$o {
    // eslint-disable-next-line require-jsdoc
    constructor(queryType, field, value) {
        super(queryType);

        if (!isNil$X(field)) this._field = field;
        if (!isNil$X(value)) this._queryOpts.value = value;
    }

    /**
     * Sets the field to search on.
     *
     * @param {string} field
     * @returns {ValueTermQueryBase} returns `this` so that calls can be chained.
     */
    field(field) {
        this._field = field;
        return this;
    }

    /**
     * Sets the query string.
     *
     * @param {string|number|boolean} queryVal
     * @returns {ValueTermQueryBase} returns `this` so that calls can be chained.
     */
    value(queryVal) {
        this._queryOpts.value = queryVal;
        return this;
    }

    /**
     * Override default `toJSON` to return DSL representation of the term level query
     * class instance.
     *
     * @override
     * @returns {Object} returns an Object which maps to the elasticsearch query DSL
     */
    toJSON() {
        // recursiveToJSON doesn't seem to be required here.

        // Revisit this.. Smells a little bit
        if (!has$5(this._queryOpts, 'value')) {
            throw new Error('Value is required for term level query!');
        }

        const qryOpts =
            Object.keys(this._queryOpts).length === 1
                ? this._queryOpts.value
                : this._queryOpts;
        return {
            [this.queryType]: {
                [this._field]: qryOpts
            }
        };
    }

    /**
     * Allows ASCII case insensitive matching of the value with the indexed
     * field values when set to true.
     *
     * NOTE: Only available in Elasticsearch v7.10.0+
     *
     * @param {boolean} value
     * @returns {ValueTermQueryBase} returns `this` so that calls can be chained.
     */
    caseInsensitive(value = true) {
        this._queryOpts.case_insensitive = value;
        return this;
    }
};

var valueTermQueryBase = ValueTermQueryBase$2;

const ValueTermQueryBase$1 = valueTermQueryBase;

/**
 * Interface-like class used to group and identify various implementations of
 * multi term queries:
 *
 * - Wildcard Query
 * - Fuzzy Query
 * - Prefix Query
 * - Range Query
 * - Regexp Query
 *
 * **NOTE:** Instantiating this directly should not be required.
 * However, if you wish to add a custom implementation for whatever reason,
 * this class could be extended.
 *
 * @extends ValueTermQueryBase
 */
let MultiTermQueryBase$6 = class MultiTermQueryBase extends ValueTermQueryBase$1 {};

var multiTermQueryBase = MultiTermQueryBase$6;

const ValueTermQueryBase = valueTermQueryBase;

/**
 * The `term` query finds documents that contain the *exact* term specified
 * in the inverted index.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html)
 *
 * @example
 * const termQry = esb.termQuery('user', 'Kimchy');
 *
 * @param {string=} field
 * @param {string|number|boolean=} queryVal
 *
 * @extends ValueTermQueryBase
 */
let TermQuery$1 = class TermQuery extends ValueTermQueryBase {
    // eslint-disable-next-line require-jsdoc
    constructor(field, queryVal) {
        super('term', field, queryVal);
    }
};

var termQuery$2 = TermQuery$1;

const isNil$W = lodash_isnil;

const {
    util: { checkType: checkType$E }
} = core;

const { Query: Query$n } = core;

/**
 * Filters documents that have fields that match any of the provided terms (**not analyzed**).
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-query.html)
 *
 * @example
 * const qry = esb.constantScoreQuery(
 *     esb.termsQuery('user', ['kimchy', 'elasticsearch'])
 * );
 *
 * @example
 * const qry = esb.termsQuery('user')
 *     .index('users')
 *     .type('user')
 *     .id(2)
 *     .path('followers');
 *
 * @param {string=} field
 * @param {Array|string|number|boolean=} values
 *
 * @extends Query
 */
let TermsQuery$1 = class TermsQuery extends Query$n {
    // TODO: The DSL is a mess. Think about cleaning up some.

    // eslint-disable-next-line require-jsdoc
    constructor(field, values) {
        super('terms');

        // Default assume user is not insane
        this._isTermsLookup = false;
        this._termsLookupOpts = {};
        this._values = [];

        if (!isNil$W(field)) this._field = field;
        if (!isNil$W(values)) {
            if (Array.isArray(values)) this.values(values);
            else this.value(values);
        }
    }

    /**
     * Private helper function to set a terms lookup option.
     *
     * @private
     * @param {string} key
     * @param {string|number|boolean} val
     */
    _setTermsLookupOpt(key, val) {
        this._isTermsLookup = true;
        this._termsLookupOpts[key] = val;
    }

    /**
     * Sets the field to search on.
     *
     * @param {string} field
     * @returns {TermsQuery} returns `this` so that calls can be chained.
     */
    field(field) {
        this._field = field;
        return this;
    }

    /**
     * Append given value to list of values to run Terms Query with.
     *
     * @param {string|number|boolean} value
     * @returns {TermsQuery} returns `this` so that calls can be chained
     */
    value(value) {
        this._values.push(value);
        return this;
    }

    /**
     * Specifies the values to run query for.
     *
     * @param {Array<string|number|boolean>} values Values to run query for.
     * @returns {TermsQuery} returns `this` so that calls can be chained
     * @throws {TypeError} If `values` is not an instance of Array
     */
    values(values) {
        checkType$E(values, Array);

        this._values = this._values.concat(values);
        return this;
    }

    /**
     * Convenience method for setting term lookup options.
     * Valid options are `index`, `type`, `id`, `path`and `routing`
     *
     * @param {Object} lookupOpts An object with any of the keys `index`,
     * `type`, `id`, `path` and `routing`.
     * @returns {TermsQuery} returns `this` so that calls can be chained
     */
    termsLookup(lookupOpts) {
        checkType$E(lookupOpts, Object);

        this._isTermsLookup = true;
        Object.assign(this._termsLookupOpts, lookupOpts);
        return this;
    }

    /**
     * The index to fetch the term values from. Defaults to the current index.
     *
     * Note: The `index` parameter in the terms filter, used to look up terms in
     * a dedicated index is mandatory in elasticsearch 6.0. Previously, the
     * index defaulted to the index the query was executed on. In 6.0, this
     * index must be explicitly set in the request.
     *
     * @param {string} idx The index to fetch the term values from.
     * Defaults to the current index.
     * @returns {TermsQuery} returns `this` so that calls can be chained
     */
    index(idx) {
        this._setTermsLookupOpt('index', idx);
        return this;
    }

    /**
     * The type to fetch the term values from.
     *
     * @param {string} type
     * @returns {TermsQuery} returns `this` so that calls can be chained
     */
    type(type) {
        this._setTermsLookupOpt('type', type);
        return this;
    }

    /**
     * The id of the document to fetch the term values from.
     *
     * @param {string} id
     * @returns {TermsQuery} returns `this` so that calls can be chained
     */
    id(id) {
        this._setTermsLookupOpt('id', id);
        return this;
    }

    /**
     * The field specified as path to fetch the actual values for the `terms` filter.
     *
     * @param {string} path
     * @returns {TermsQuery} returns `this` so that calls can be chained
     */
    path(path) {
        this._setTermsLookupOpt('path', path);
        return this;
    }

    /**
     * A custom routing value to be used when retrieving the external terms doc.
     *
     * @param {string} routing
     * @returns {TermsQuery} returns `this` so that calls can be chained
     */
    routing(routing) {
        this._setTermsLookupOpt('routing', routing);
        return this;
    }

    /**
     * Override default `toJSON` to return DSL representation of the `terms` query
     * class instance.
     *
     * @override
     * @returns {Object} returns an Object which maps to the elasticsearch query DSL
     */
    toJSON() {
        // recursiveToJSON doesn't seem to be required here.
        return {
            [this.queryType]: Object.assign({}, this._queryOpts, {
                [this._field]: this._isTermsLookup
                    ? this._termsLookupOpts
                    : this._values
            })
        };
    }
};

var termsQuery$2 = TermsQuery$1;

const isNil$V = lodash_isnil;

const {
    Query: Query$m,
    util: { checkType: checkType$D }
} = core;

/**
 * Returns any documents that match with at least one or more of the provided
 * terms. The terms are not analyzed and thus must match exactly. The number of
 * terms that must match varies per document and is either controlled by a
 * minimum should match field or computed per document in a minimum should match
 * script.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-set-query.html)
 *
 * NOTE: This query was added in elasticsearch v6.1.
 *
 * @example
 * const qry = esb.termsSetQuery('codes', ['abc', 'def', 'ghi'])
 *     .minimumShouldMatchField('required_matches')
 *
 * @param {string=} field
 * @param {Array<string|number|boolean>|string|number=} terms
 *
 * @extends Query
 */
let TermsSetQuery$1 = class TermsSetQuery extends Query$m {
    // eslint-disable-next-line require-jsdoc
    constructor(field, terms) {
        super('terms_set');

        this._queryOpts.terms = [];

        if (!isNil$V(field)) this._field = field;
        if (!isNil$V(terms)) {
            if (Array.isArray(terms)) this.terms(terms);
            else this.term(terms);
        }
    }

    /**
     * Sets the field to search on.
     *
     * @param {string} field
     * @returns {TermsSetQuery} returns `this` so that calls can be chained.
     */
    field(field) {
        this._field = field;
        return this;
    }

    /**
     * Append given term to set of terms to run Terms Set Query with.
     *
     * @param {string|number|boolean} term
     * @returns {TermsSetQuery} returns `this` so that calls can be chained
     */
    term(term) {
        this._queryOpts.terms.push(term);
        return this;
    }

    /**
     * Specifies the terms to run query for.
     *
     * @param {Array<string|number|boolean>} terms Terms set to run query for.
     * @returns {TermsSetQuery} returns `this` so that calls can be chained
     * @throws {TypeError} If `terms` is not an instance of Array
     */
    terms(terms) {
        checkType$D(terms, Array);

        this._queryOpts.terms = this._queryOpts.terms.concat(terms);
        return this;
    }

    /**
     * Controls the number of terms that must match per document.
     *
     * @param {string} fieldName
     * @returns {TermsSetQuery} returns `this` so that calls can be chained
     */
    minimumShouldMatchField(fieldName) {
        this._queryOpts.minimum_should_match_field = fieldName;
        return this;
    }

    /**
     * Sets the `script` for query. It controls how many terms are required to
     * match in a more dynamic way.
     *
     * The `params.num_terms` parameter is available in the script to indicate
     * the number of terms that have been specified.
     *
     * @example
     * const qry = esb.termsSetQuery('codes', ['abc', 'def', 'ghi'])
     *     .minimumShouldMatchScript({
     *         source: "Math.min(params.num_terms, doc['required_matches'].value)"
     *     })
     *
     * @param {Script|string|Object} script
     * @returns {ScriptQuery} returns `this` so that calls can be chained.
     */
    minimumShouldMatchScript(script) {
        this._queryOpts.minimum_should_match_script = script;
        return this;
    }

    /**
     * Override default `toJSON` to return DSL representation of the term level query
     * class instance.
     *
     * @override
     * @returns {Object} returns an Object which maps to the elasticsearch query DSL
     */
    toJSON() {
        return {
            [this.queryType]: { [this._field]: this._queryOpts }
        };
    }
};

var termsSetQuery$2 = TermsSetQuery$1;

const isNil$U = lodash_isnil;

const {
    util: { invalidParam: invalidParam$j },
    consts: { GEO_RELATION_SET: GEO_RELATION_SET$1 }
} = core;

const MultiTermQueryBase$5 = multiTermQueryBase;

const ES_REF_URL$V =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html';

const invalidRelationParam$1 = invalidParam$j(
    ES_REF_URL$V,
    'relation',
    GEO_RELATION_SET$1
);

/**
 * Matches documents with fields that have terms within a certain range.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html)
 *
 * @param {string=} field
 *
 * @example
 * const qry = esb.rangeQuery('age')
 *     .gte(10)
 *     .lte(20)
 *     .boost(2.0);
 *
 * @example
 * const qry = esb.rangeQuery('date').gte('now-1d/d').lt('now/d');
 *
 * @extends MultiTermQueryBase
 */
let RangeQuery$1 = class RangeQuery extends MultiTermQueryBase$5 {
    // eslint-disable-next-line require-jsdoc
    constructor(field) {
        super('range', field);
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on RangeQuery
     */
    value() {
        console.log(`Please refer ${ES_REF_URL$V}`);
        throw new Error('value is not supported in RangeQuery');
    }

    /**
     * Greater-than or equal to
     *
     * @param {string|number} val
     * @returns {RangeQuery} returns `this` so that calls can be chained.
     */
    gte(val) {
        this._queryOpts.gte = val;
        return this;
    }

    /**
     * Less-than or equal to
     *
     * @param {string|number} val
     * @returns {RangeQuery} returns `this` so that calls can be chained.
     */
    lte(val) {
        this._queryOpts.lte = val;
        return this;
    }

    /**
     * Greater-than
     *
     * @param {string|number} val
     * @returns {RangeQuery} returns `this` so that calls can be chained.
     */
    gt(val) {
        this._queryOpts.gt = val;
        return this;
    }

    /**
     * Less-than
     *
     * @param {string|number} val
     * @returns {RangeQuery} returns `this` so that calls can be chained.
     */
    lt(val) {
        this._queryOpts.lt = val;
        return this;
    }

    /**
     * The lower bound. Defaults to start from the first.
     *
     * @param {string|number} val The lower bound value, type depends on field type
     * @returns {RangeQuery} returns `this` so that calls can be chained.
     */
    from(val) {
        this._queryOpts.from = val;
        return this;
    }

    /**
     * The upper bound. Defaults to unbounded.
     *
     * @param {string|number} val The upper bound value, type depends on field type
     * @returns {RangeQuery} returns `this` so that calls can be chained.
     */
    to(val) {
        this._queryOpts.to = val;
        return this;
    }

    /**
     * Should the first from (if set) be inclusive or not. Defaults to `true`
     *
     * @param {boolean} enable `true` to include, `false` to exclude
     * @returns {RangeQuery} returns `this` so that calls can be chained.
     */
    includeLower(enable) {
        this._queryOpts.include_lower = enable;
        return this;
    }

    /**
     * Should the last to (if set) be inclusive or not. Defaults to `true`.
     *
     * @param {boolean} enable `true` to include, `false` to exclude
     * @returns {RangeQuery} returns `this` so that calls can be chained.
     */
    includeUpper(enable) {
        this._queryOpts.include_upper = enable;
        return this;
    }

    /**
     * Time Zone to be applied to any range query related to dates.
     *
     * @param {string} zone
     * @returns {RangeQuery} returns `this` so that calls can be chained.
     */
    timeZone(zone) {
        this._queryOpts.time_zone = zone;
        return this;
    }

    /**
     * Sets the format expression for parsing the upper and lower bounds.
     * If no format is specified, then it will use the first format specified in the field mapping.
     *
     * @example
     * const qry = esb.rangeQuery('born')
     *     .gte('01/01/2012')
     *     .lte('2013')
     *     .format('dd/MM/yyyy||yyyy');
     *
     * @param {string} fmt Format for parsing upper and lower bounds.
     * @returns {RangeQuery} returns `this` so that calls can be chained
     */
    format(fmt) {
        this._queryOpts.format = fmt;
        return this;
    }

    /**
     * Sets the relationship between Query and indexed data
     * that will be used to determine if a Document should be matched or not.
     *
     * @param {string} relation Can be one of `WITHIN`, `CONTAINS`, `DISJOINT`
     * or `INTERSECTS`(default)
     * @returns {RangeQuery} returns `this` so that calls can be chained
     */
    relation(relation) {
        if (isNil$U(relation)) invalidRelationParam$1(relation);

        const relationUpper = relation.toUpperCase();
        if (!GEO_RELATION_SET$1.has(relationUpper)) {
            invalidRelationParam$1(relation);
        }

        this._queryOpts.relation = relationUpper;
        return this;
    }

    /**
     * Override default `toJSON` to return DSL representation of the `range` query
     * class instance.
     *
     * @override
     * @returns {Object} returns an Object which maps to the elasticsearch query DSL
     */
    toJSON() {
        // recursiveToJSON doesn't seem to be required here.
        return {
            [this.queryType]: {
                [this._field]: this._queryOpts
            }
        };
    }
};

var rangeQuery$2 = RangeQuery$1;

const isNil$T = lodash_isnil;

const { Query: Query$l } = core;

/**
 * Returns documents that have at least one non-`null` value in the original field
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html)
 *
 * @example
 * const qry = esb.existsQuery('user');
 *
 * @example
 * const qry = esb.boolQuery().mustNot(esb.existsQuery('user'));
 *
 * @param {string=} field
 *
 * @extends Query
 */
let ExistsQuery$2 = class ExistsQuery extends Query$l {
    // eslint-disable-next-line require-jsdoc
    constructor(field) {
        super('exists');

        if (!isNil$T(field)) this._queryOpts.field = field;
    }

    /**
     * Sets the field to search on.
     *
     * @param {string} field
     * @returns {ExistsQuery} returns `this` so that calls can be chained.
     */
    field(field) {
        this._queryOpts.field = field;
        return this;
    }
};

var existsQuery$2 = ExistsQuery$2;

const MultiTermQueryBase$4 = multiTermQueryBase;
const { validateRewiteMethod: validateRewiteMethod$2 } = helper;

const ES_REF_URL$U =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html';

/**
 * Matches documents that have fields containing terms with a specified prefix (**not analyzed**).
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html)
 *
 * @example
 * const qry = esb.prefixQuery('user', 'ki').boost(2.0);
 *
 * @param {string=} field
 * @param {string|number=} value
 *
 * @extends MultiTermQueryBase
 */
let PrefixQuery$1 = class PrefixQuery extends MultiTermQueryBase$4 {
    // eslint-disable-next-line require-jsdoc
    constructor(field, value) {
        super('prefix', field, value);
    }

    /**
     * Sets the rewrite method. Valid values are:
     * - `constant_score` - tries to pick the best constant-score rewrite
     *  method based on term and document counts from the query.
     *  Synonyms - `constant_score_auto`, `constant_score_filter`
     *
     * - `scoring_boolean` - translates each term into boolean should and
     *  keeps the scores as computed by the query
     *
     * - `constant_score_boolean` - same as `scoring_boolean`, expect no scores
     *  are computed.
     *
     * - `constant_score_filter` - first creates a private Filter, by visiting
     *  each term in sequence and marking all docs for that term
     *
     * - `top_terms_boost_N` - first translates each term into boolean should
     *  and scores are only computed as the boost using the top N
     *  scoring terms. Replace N with an integer value.
     *
     * - `top_terms_N` - first translates each term into boolean should
     *  and keeps the scores as computed by the query. Only the top N
     *  scoring terms are used. Replace N with an integer value.
     *
     * Default is `constant_score`.
     *
     * This is an advanced option, use with care.
     *
     * Note: The deprecated multi term rewrite parameters `constant_score_auto`,
     * `constant_score_filter` (synonyms for `constant_score`) have been removed
     * in elasticsearch 6.0.
     *
     * @param {string} method The rewrite method as a string.
     * @returns {PrefixQuery} returns `this` so that calls can be chained.
     * @throws {Error} If the given `rewrite` method is not valid.
     */
    rewrite(method) {
        validateRewiteMethod$2(method, 'rewrite', ES_REF_URL$U);

        this._queryOpts.rewrite = method;
        return this;
    }
};

var prefixQuery$2 = PrefixQuery$1;

const MultiTermQueryBase$3 = multiTermQueryBase;
const { validateRewiteMethod: validateRewiteMethod$1 } = helper;

const ES_REF_URL$T =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html';

/**
 * Matches documents that have fields matching a wildcard expression (**not analyzed**).
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html)
 *
 * @example
 * const qry = esb.wildcardQuery('user', 'ki*y').boost(2.0);
 *
 * @param {string=} field
 * @param {string=} value
 *
 * @extends MultiTermQueryBase
 */
let WildcardQuery$1 = class WildcardQuery extends MultiTermQueryBase$3 {
    // eslint-disable-next-line require-jsdoc
    constructor(field, value) {
        super('wildcard', field, value);
    }

    /**
     * Allow case insensitive matching or not (added in 7.10.0).
     * Defaults to false.
     *
     * @example
     * const qry = esb.wildcardQuery('user', 'ki*y')
     *     .caseInsensitive(true);
     *
     * @param {boolean} caseInsensitive
     * @returns {RegexpQuery} returns `this` so that calls can be chained.
     */
    caseInsensitive(caseInsensitive) {
        this._queryOpts.case_insensitive = caseInsensitive;
        return this;
    }

    /**
     * Sets the rewrite method. Valid values are:
     * - `constant_score` - tries to pick the best constant-score rewrite
     *  method based on term and document counts from the query.
     *  Synonyms - `constant_score_auto`, `constant_score_filter`
     *
     * - `scoring_boolean` - translates each term into boolean should and
     *  keeps the scores as computed by the query
     *
     * - `constant_score_boolean` - same as `scoring_boolean`, expect no scores
     *  are computed.
     *
     * - `constant_score_filter` - first creates a private Filter, by visiting
     *  each term in sequence and marking all docs for that term
     *
     * - `top_terms_boost_N` - first translates each term into boolean should
     *  and scores are only computed as the boost using the top N
     *  scoring terms. Replace N with an integer value.
     *
     * - `top_terms_N` - first translates each term into boolean should
     *  and keeps the scores as computed by the query. Only the top N
     *  scoring terms are used. Replace N with an integer value.
     *
     * Default is `constant_score`.
     *
     * This is an advanced option, use with care.
     *
     * Note: The deprecated multi term rewrite parameters `constant_score_auto`,
     * `constant_score_filter` (synonyms for `constant_score`) have been removed
     * in elasticsearch 6.0.
     *
     * @param {string} method The rewrite method as a string.
     * @returns {WildcardQuery} returns `this` so that calls can be chained.
     * @throws {Error} If the given `rewrite` method is not valid.
     */
    rewrite(method) {
        validateRewiteMethod$1(method, 'rewrite', ES_REF_URL$T);

        this._queryOpts.rewrite = method;
        return this;
    }
};

var wildcardQuery$2 = WildcardQuery$1;

const MultiTermQueryBase$2 = multiTermQueryBase;
const { validateRewiteMethod } = helper;

const ES_REF_URL$S =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html';

/**
 * Query for regular expression term queries. Elasticsearch will apply the regexp
 * to the terms produced by the tokenizer for that field, and not to the original
 * text of the field.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html)
 *
 * @example
 * const qry = esb.regexpQuery('name.first', 's.*y').boost(1.2);
 *
 * @param {string=} field
 * @param {string|number=} value
 *
 * @extends MultiTermQueryBase
 */
let RegexpQuery$1 = class RegexpQuery extends MultiTermQueryBase$2 {
    // eslint-disable-next-line require-jsdoc
    constructor(field, value) {
        super('regexp', field, value);
    }

    /**
     * Set special flags. Possible flags are `ALL` (default),
     * `ANYSTRING`, `COMPLEMENT`, `EMPTY`, `INTERSECTION`, `INTERVAL`, or `NONE`.
     *
     * @example
     * const qry = esb.regexpQuery('name.first', 's.*y')
     *     .flags('INTERSECTION|COMPLEMENT|EMPTY');
     *
     * @param {string} flags `|` separated flags. Possible flags are `ALL` (default),
     * `ANYSTRING`, `COMPLEMENT`, `EMPTY`, `INTERSECTION`, `INTERVAL`, or `NONE`.
     * @returns {RegexpQuery} returns `this` so that calls can be chained.
     */
    flags(flags) {
        this._queryOpts.flags = flags;
        return this;
    }

    /**
     * Allow case insensitive matching or not (added in 7.10.0).
     * Defaults to false.
     *
     * @example
     * const qry = esb.regexpQuery('name.first', 's.*y')
     *     .caseInsensitive(true);
     *
     * @param {boolean} caseInsensitive
     * @returns {RegexpQuery} returns `this` so that calls can be chained.
     */
    caseInsensitive(caseInsensitive) {
        this._queryOpts.case_insensitive = caseInsensitive;
        return this;
    }

    /**
     * Limit on how many automaton states regexp queries are allowed to create.
     * This protects against too-difficult (e.g. exponentially hard) regexps.
     * Defaults to 10000.
     *
     * @example
     * const qry = esb.regexpQuery('name.first', 's.*y')
     *     .flags('INTERSECTION|COMPLEMENT|EMPTY')
     *     .maxDeterminizedStates(20000);
     *
     * @param {number} limit
     * @returns {RegexpQuery} returns `this` so that calls can be chained.
     */
    maxDeterminizedStates(limit) {
        this._queryOpts.max_determinized_states = limit;
        return this;
    }

    /**
     * Sets the rewrite method. Valid values are:
     * - `constant_score` - tries to pick the best constant-score rewrite
     *  method based on term and document counts from the query.
     *  Synonyms - `constant_score_auto`, `constant_score_filter`
     *
     * - `scoring_boolean` - translates each term into boolean should and
     *  keeps the scores as computed by the query
     *
     * - `constant_score_boolean` - same as `scoring_boolean`, expect no scores
     *  are computed.
     *
     * - `constant_score_filter` - first creates a private Filter, by visiting
     *  each term in sequence and marking all docs for that term
     *
     * - `top_terms_boost_N` - first translates each term into boolean should
     *  and scores are only computed as the boost using the top N
     *  scoring terms. Replace N with an integer value.
     *
     * - `top_terms_N` - first translates each term into boolean should
     *  and keeps the scores as computed by the query. Only the top N
     *  scoring terms are used. Replace N with an integer value.
     *
     * Default is `constant_score`.
     *
     * This is an advanced option, use with care.
     *
     * Note: The deprecated multi term rewrite parameters `constant_score_auto`,
     * `constant_score_filter` (synonyms for `constant_score`) have been removed
     * in elasticsearch 6.0.
     *
     * @param {string} method The rewrite method as a string.
     * @returns {RegexpQuery} returns `this` so that calls can be chained.
     * @throws {Error} If the given `rewrite` method is not valid.
     */
    rewrite(method) {
        validateRewiteMethod(method, 'rewrite', ES_REF_URL$S);

        this._queryOpts.rewrite = method;
        return this;
    }
};

var regexpQuery$2 = RegexpQuery$1;

const MultiTermQueryBase$1 = multiTermQueryBase;

/**
 * The fuzzy query generates all possible matching terms that are within
 * the maximum edit distance specified in `fuzziness` and then checks
 * the term dictionary to find out which of those generated terms
 * actually exist in the index.
 *
 * The fuzzy query uses similarity based on Levenshtein edit distance.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html)
 *
 * @example
 * const qry = esb.fuzzyQuery('user', 'ki');
 *
 * @example
 * // More advanced settings
 * const qry = esb.fuzzyQuery('user', 'ki')
 *     .fuzziness(2)
 *     .prefixLength(0)
 *     .maxExpansions(100)
 *     .boost(1.0);
 *
 * @param {string=} field
 * @param {string|number=} value
 *
 * @extends MultiTermQueryBase
 */
let FuzzyQuery$1 = class FuzzyQuery extends MultiTermQueryBase$1 {
    // eslint-disable-next-line require-jsdoc
    constructor(field, value) {
        super('fuzzy', field, value);
    }

    /**
     * Sets the `fuzziness` parameter which is interpreted as a Levenshtein Edit Distance
     * the number of one character changes that need to be made to one string to make it
     * the same as another string.
     *
     * @param {number|string} factor Can be specified either as a number, or the maximum
     * number of edits, or as `AUTO` which generates an edit distance based on the length
     * of the term.
     * @returns {FuzzyQuery} returns `this` so that calls can be chained.
     */
    fuzziness(factor) {
        this._queryOpts.fuzziness = factor;
        return this;
    }

    /**
     * The number of initial characters which will not be fuzzified.
     * This helps to reduce the number of terms which must be examined. Defaults to `0`.
     *
     * @param {number} len Characters to skip fuzzy for. Defaults to `0`.
     * @returns {FuzzyQuery} returns `this` so that calls can be chained.
     */
    prefixLength(len) {
        this._queryOpts.prefix_length = len;
        return this;
    }

    /**
     * The maximum number of terms that the fuzzy query will expand to. Defaults to `50`.
     *
     * @param {number} limit Limit for fuzzy query expansion. Defaults to `50`.
     * @returns {FuzzyQuery} returns `this` so that calls can be chained.
     */
    maxExpansions(limit) {
        this._queryOpts.max_expansions = limit;
        return this;
    }

    /**
     * Transpositions (`ab`  `ba`) are allowed by default but can be disabled
     * by setting `transpositions` to false.
     *
     * @param {boolean} enable
     * @returns {FuzzyQuery} returns `this` so that calls can be chained.
     */
    transpositions(enable) {
        this._queryOpts.transpositions = enable;
        return this;
    }
};

var fuzzyQuery$2 = FuzzyQuery$1;

const isNil$S = lodash_isnil;

const { Query: Query$k } = core;

/**
 * Filters documents matching the provided document / mapping type.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-type-query.html)
 *
 * @example
 * const qry = esb.typeQuery('my_type');
 *
 * @param {string=} type The elasticsearch doc type
 *
 * @extends Query
 */
let TypeQuery$1 = class TypeQuery extends Query$k {
    // eslint-disable-next-line require-jsdoc
    constructor(type) {
        super('type');

        if (!isNil$S(type)) this._queryOpts.value = type;
    }

    /**
     * Sets the elasticsearch doc type to query on.
     *
     * @param {string} type The elasticsearch doc type
     * @returns {TypeQuery} returns `this` so that calls can be chained.
     */
    value(type) {
        this._queryOpts.value = type;
        return this;
    }

    /**
     * Sets the elasticsearch doc type to query on.
     * Alias for method `value`.
     *
     * @param {string} type The elasticsearch doc type
     * @returns {TypeQuery} returns `this` so that calls can be chained.
     */
    type(type) {
        return this.value(type);
    }
};

var typeQuery$2 = TypeQuery$1;

const isNil$R = lodash_isnil;

const {
    Query: Query$j,
    util: { checkType: checkType$C }
} = core;

/**
 * Filters documents that only have the provided ids.
 * Note, this query uses the _uid field.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-ids-query.html)
 *
 * @example
 * const qry = esb.idsQuery('my_type', ['1', '4', '100']);
 *
 * @param {Array|string=} type The elasticsearch doc type
 * @param {Array=} ids List of ids to fiter on.
 *
 * @extends Query
 */
let IdsQuery$1 = class IdsQuery extends Query$j {
    // eslint-disable-next-line require-jsdoc
    constructor(type, ids) {
        super('ids');

        if (!isNil$R(type)) this._queryOpts.type = type;
        if (!isNil$R(ids)) this.values(ids);
    }

    /**
     * Sets the elasticsearch doc type to query on.
     * The type is optional and can be omitted, and can also accept an array of values.
     * If no type is specified, all types defined in the index mapping are tried.
     *
     * @param {Array<string>|string} type The elasticsearch doc type
     * @returns {IdsQuery} returns `this` so that calls can be chained.
     */
    type(type) {
        this._queryOpts.type = type;
        return this;
    }

    /**
     * Sets the list of ids to fiter on.
     *
     * @param {Array<string|number>} ids
     * @returns {IdsQuery} returns `this` so that calls can be chained.
     */
    values(ids) {
        checkType$C(ids, Array);

        this._queryOpts.values = ids;
        return this;
    }

    /**
     * Sets the list of ids to fiter on.
     * Alias for `values` method.
     *
     * @param {Array<string|number>} ids
     * @returns {IdsQuery} returns `this` so that calls can be chained.
     */
    ids(ids) {
        return this.values(ids);
    }
};

var idsQuery$2 = IdsQuery$1;

termLevelQueries.MultiTermQueryBase = multiTermQueryBase;

termLevelQueries.TermQuery = termQuery$2;
termLevelQueries.TermsQuery = termsQuery$2;
termLevelQueries.TermsSetQuery = termsSetQuery$2;
termLevelQueries.RangeQuery = rangeQuery$2;
termLevelQueries.ExistsQuery = existsQuery$2;
termLevelQueries.PrefixQuery = prefixQuery$2;
termLevelQueries.WildcardQuery = wildcardQuery$2;
termLevelQueries.RegexpQuery = regexpQuery$2;
termLevelQueries.FuzzyQuery = fuzzyQuery$2;
termLevelQueries.TypeQuery = typeQuery$2;
termLevelQueries.IdsQuery = idsQuery$2;

var compoundQueries = {};

var scoreFunctions = {};

const {
    Query: Query$i,
    util: { checkType: checkType$B, recursiveToJSON: recursiveToJSON$6 }
} = core;

/**
 * `ScoreFunction` provides support for common options used across
 * various `ScoreFunction` implementations.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-function-score-query.html#score-functions)
 *
 * **NOTE:** Instantiating this directly should not be required.
 * However, if you wish to add a custom implementation for whatever reason,
 * this class could be extended.
 *
 * @param {string} name
 */
let ScoreFunction$6 = class ScoreFunction {
    // eslint-disable-next-line require-jsdoc
    constructor(name) {
        this._name = name;

        // Filter, weight go here
        this._body = {};
        // Score Function specific options go here
        this._opts = {};
    }

    /**
     * Adds a filter query whose matching documents will have the score function applied.
     *
     * @param {Query} filterQry A valid `Query` object.
     * @returns {ScoreFunction} returns `this` so that calls can be chained.
     */
    filter(filterQry) {
        checkType$B(filterQry, Query$i);

        this._body.filter = filterQry;
        return this;
    }

    /**
     * Sets the weight of the score function
     *
     * @param {number} weight The weight of this score function.
     * @returns {ScoreFunction} returns `this` so that calls can be chained.
     */
    weight(weight) {
        this._body.weight = weight;
        return this;
    }

    /**
     * Overrides default `toJSON` to return DSL representation of the score function
     * class instance.
     *
     * @override
     * @returns {Object} returns an Object which maps to the elasticsearch query DSL
     */
    toJSON() {
        const repr = Object.assign({ [this._name]: this._opts }, this._body);
        return recursiveToJSON$6(repr);
    }
};

var scoreFunction = ScoreFunction$6;

const isNil$Q = lodash_isnil;

const ScoreFunction$5 = scoreFunction;

/**
 * The `script_score` function allows you to wrap another query and customize
 * the scoring of it optionally with a computation derived from other numeric
 * field values in the doc using a script expression.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-function-score-query.html#function-script-score)
 *
 * @example
 * const scoreFunc = esb.scriptScoreFunction(
 *     esb.script('inline', "_score * doc['my_numeric_field'].value")
 *         .lang('painless')
 * );
 *
 * @example
 * // Script with parameters
 * const scoreFunc = esb.scriptScoreFunction(
 *     esb.script(
 *         'inline',
 *         "_score * doc['my_numeric_field'].value / Math.pow(params.param1, params.param2)"
 *     )
 *         .lang('painless')
 *         .params({ param1: 'value1', param2: 'value2' })
 * );
 *
 * @param {Script|string} script
 *
 * @extends ScoreFunction
 */
let ScriptScoreFunction$1 = class ScriptScoreFunction extends ScoreFunction$5 {
    // eslint-disable-next-line require-jsdoc
    constructor(script) {
        super('script_score');

        if (!isNil$Q(script)) this._opts.script = script;
    }

    /**
     *
     * @param {Script|string} script
     * @returns {ScriptScoreFunction} returns `this` so that calls can be chained.
     */
    script(script) {
        this._opts.script = script;
        return this;
    }
};

var scriptScoreFunction$2 = ScriptScoreFunction$1;

const isNil$P = lodash_isnil;

const ScoreFunction$4 = scoreFunction;

const {
    util: { recursiveToJSON: recursiveToJSON$5 }
} = core;

/**
 * The `weight` score allows you to multiply the score by the provided `weight`.
 * This can sometimes be desired since boost value set on specific queries gets
 * normalized, while for this score function it does not.
 * The number value is of type float.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-function-score-query.html#function-weight)
 *
 * @example
 * const scoreFunc = esb.weightScoreFunction(42);
 *
 * @param {number=} weight The weight of this score function.
 * @extends ScoreFunction
 */
let WeightScoreFunction$1 = class WeightScoreFunction extends ScoreFunction$4 {
    // eslint-disable-next-line require-jsdoc
    constructor(weight) {
        /*
            null to `super` is intentional.
            The following is a valid score function
            It doesn't have a name field
            {
                "filter": { "match": { "test": "cat" } },
                "weight": 42
            }
        */
        super(null);

        if (!isNil$P(weight)) this._body.weight = weight;
    }

    /**
     * Overrides default `toJSON` to return DSL representation of the score function
     * class instance.
     *
     * @override
     * @returns {Object} returns an Object which maps to the elasticsearch query DSL
     */
    toJSON() {
        return recursiveToJSON$5(this._body);
    }
};

var weightScoreFunction$2 = WeightScoreFunction$1;

const ScoreFunction$3 = scoreFunction;

/**
 * The `random_score` generates scores using a hash of the `_uid` field,
 * with a `seed` for variation. If `seed` is not specified, the current time is used.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-function-score-query.html#function-random)
 *
 * @example
 * const scoreFunc = esb.randomScoreFunction().seed(299792458);
 *
 * @extends ScoreFunction
 */
let RandomScoreFunction$2 = class RandomScoreFunction extends ScoreFunction$3 {
    // eslint-disable-next-line require-jsdoc
    constructor() {
        super('random_score');
    }

    /**
     * Sets random seed value.
     *
     * @param {number} seed A seed value.
     * @returns {RandomScoreFunction} returns `this` so that calls can be chained.
     */
    seed(seed) {
        this._opts.seed = seed;
        return this;
    }
};

var randomScoreFunction$2 = RandomScoreFunction$2;

const isNil$O = lodash_isnil;

const {
    util: { invalidParam: invalidParam$i },
    consts: { FIELD_MODIFIER_SET }
} = core;

const ScoreFunction$2 = scoreFunction;

const ES_REF_URL$R =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-function-score-query.html#function-field-value-factor';

const invaliModifierdParam = invalidParam$i(
    ES_REF_URL$R,
    'modifier',
    FIELD_MODIFIER_SET
);

/**
 * The `field_value_factor` function allows you to use a field from a document
 * to influence the score. It's similar to using the `script_score` function, however,
 * it avoids the overhead of scripting. If used on a multi-valued field, only the
 * first value of the field is used in calculations.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-function-score-query.html#function-field-value-factor)
 *
 * @example
 * // Scoring formula - sqrt(1.2 * doc['popularity'].value)
 * const scoreFunc = esb.fieldValueFactorFunction('popularity')
 *     .factor(1.2)
 *     .modifier('sqrt')
 *     .missing(1);
 *
 * @param {string=} field the field to be extracted from the document.
 *
 * @extends ScoreFunction
 */
let FieldValueFactorFunction$1 = class FieldValueFactorFunction extends ScoreFunction$2 {
    // eslint-disable-next-line require-jsdoc
    constructor(field) {
        super('field_value_factor');

        if (!isNil$O(field)) this._opts.field = field;
    }

    /**
     * Sets the field to be extracted from the document.
     *
     * @param {string} field the field to be extracted from the document.
     * @returns {FieldValueFactorFunction} returns `this` so that calls can be chained.
     */
    field(field) {
        this._opts.field = field;
        return this;
    }

    /**
     * Optional factor to multiply the field value with, defaults to `1`.
     *
     * @param {number} factor Factor to multiply the field with.
     * @returns {FieldValueFactorFunction} returns `this` so that calls can be chained.
     */
    factor(factor) {
        this._opts.factor = factor;
        return this;
    }

    /**
     * Modifier to apply to the field value, can be one of: `none`, `log`,
     * `log1p`, `log2p`, `ln`, `ln1p`, `ln2p`, `square`, `sqrt`, or `reciprocal`.
     * Defaults to `none`.
     *
     * @param {string} mod Modified to apply on field. Can be one of: `none`, `log`,
     * `log1p`, `log2p`, `ln`, `ln1p`, `ln2p`, `square`, `sqrt`, or `reciprocal`.
     * Defaults to `none`.
     * @returns {FieldValueFactorFunction} returns `this` so that calls can be chained.
     */
    modifier(mod) {
        if (isNil$O(mod)) invaliModifierdParam(mod);

        const modLower = mod.toLowerCase();
        if (!FIELD_MODIFIER_SET.has(modLower)) {
            invaliModifierdParam(mod);
        }

        this._opts.modifier = modLower;
        return this;
    }

    /**
     * Value used if the document doesnt have that field. The modifier and factor
     * are still applied to it as though it were read from the document.
     *
     * @param {number} val To be used with documents which do not have field value.
     * @returns {FieldValueFactorFunction} returns `this` so that calls can be chained.
     */
    missing(val) {
        this._opts.missing = val;
        return this;
    }
};

var fieldValueFactorFunction$2 = FieldValueFactorFunction$1;

const isNil$N = lodash_isnil;

const {
    util: { invalidParam: invalidParam$h, recursiveToJSON: recursiveToJSON$4 }
} = core;

const ES_REF_URL$Q =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-function-score-query.html#function-decay';

const ScoreFunction$1 = scoreFunction;

const invalidModeParam = invalidParam$h(
    ES_REF_URL$Q,
    'mode',
    "'linear', 'exp' or 'gauss'"
);

/**
 * Decay functions score a document with a function that decays depending on
 * the distance of a numeric field value of the document from a user given
 * origin. This is similar to a range query, but with smooth edges instead of
 * boxes.
 *
 * Supported decay functions are: `linear`, `exp`, and `gauss`.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-function-score-query.html#function-decay)
 *
 * If no `mode` is supplied, `gauss` will be used.
 *
 * @example
 * // Defaults to decay function `gauss`
 * const decayFunc = esb.decayScoreFunction()
 *     .field('location') // field is a geo_point
 *     .origin('11, 12') // geo format
 *     .scale('2km')
 *     .offset('0km')
 *     .decay(0.33);
 *
 * @example
 * const decayFunc = esb.decayScoreFunction('gauss', 'date')
 *     .origin('2013-09-17')
 *     .scale('10d')
 *     .offset('5d')
 *     .decay(0.5);
 *
 * @param {string=} mode Can be one of `linear`, `exp`, and `gauss`.
 * Defaults to `gauss`.
 * @param {string=} field the document field to run decay function against.
 *
 * @extends ScoreFunction
 */
let DecayScoreFunction$1 = class DecayScoreFunction extends ScoreFunction$1 {
    // eslint-disable-next-line require-jsdoc
    constructor(mode = 'gauss', field) {
        super(mode);

        if (!isNil$N(field)) this._field = field;
    }

    /**
     * Set the decay mode.
     *
     * @param {string} mode  Can be one of `linear`, `exp`, and `gauss`.
     * Defaults to `gauss`.
     * @returns {DecayScoreFunction} returns `this` so that calls can be chained.
     */
    mode(mode) {
        if (isNil$N(mode)) invalidModeParam(mode);

        const modeLower = mode.toLowerCase();
        if (
            modeLower !== 'linear' &&
            modeLower !== 'exp' &&
            modeLower !== 'gauss'
        ) {
            invalidModeParam(mode);
        }

        this._name = mode;
        return this;
    }

    /**
     * Sets the decay mode to linear.
     * Alias for `mode('linear')`
     *
     * @returns {DecayScoreFunction} returns `this` so that calls can be chained.
     */
    linear() {
        this._name = 'linear';
        return this;
    }

    /**
     * Sets the decay mode to exp.
     * Alias for `mode('exp')`
     *
     * @returns {DecayScoreFunction} returns `this` so that calls can be chained.
     */
    exp() {
        this._name = 'exp';
        return this;
    }

    /**
     * Sets the decay mode to gauss.
     * Alias for `mode('gauss')`
     *
     * @returns {DecayScoreFunction} returns `this` so that calls can be chained.
     */
    gauss() {
        this._name = 'gauss';
        return this;
    }

    /**
     * Sets the document field to run decay function against.
     *
     * @param {string} field the document field to run decay function against.
     * @returns {DecayScoreFunction} returns `this` so that calls can be chained.
     */
    field(field) {
        this._field = field;
        return this;
    }

    /**
     * The point of origin used for calculating distance. Must be given as a number
     * for numeric field, date for date fields and geo point for geo fields.
     * Required for geo and numeric field. For date fields the default is `now`.
     * Date math (for example `now-1h`) is supported for origin.
     *
     * @param {number|string|Object} origin A valid origin value for the field type.
     * @returns {DecayScoreFunction} returns `this` so that calls can be chained.
     */
    origin(origin) {
        this._opts.origin = origin;
        return this;
    }

    /**
     * Required for all types. Defines the distance from origin + offset at which
     * the computed score will equal decay parameter. For geo fields: Can be defined
     * as number+unit (`1km`, `12m`,). Default unit is meters. For date fields: Can be
     * defined as a number+unit (`1h`, `10d`,). Default unit is milliseconds.
     * For numeric field: Any number.
     *
     * @param {number|string} scale A valid scale value for the field type.
     * @returns {DecayScoreFunction} returns `this` so that calls can be chained.
     */
    scale(scale) {
        this._opts.scale = scale;
        return this;
    }

    /**
     * If an `offset` is defined, the decay function will only compute the decay function
     * for documents with a distance greater that the defined offset. The default is `0`.
     *
     * @param {number|string} offset A valid offset value for the field type.
     * @returns {DecayScoreFunction} returns `this` so that calls can be chained.
     */
    offset(offset) {
        this._opts.offset = offset;
        return this;
    }

    /**
     * The `decay` parameter defines how documents are scored at the distance given at `scale`.
     * If no `decay` is defined, documents at the distance `scale` will be scored `0.5`.
     *
     * @param {number} decay A decay value as a double.
     * @returns {DecayScoreFunction} returns `this` so that calls can be chained.
     */
    decay(decay) {
        this._opts.decay = decay;
        return this;
    }

    /**
     * Overrides default `toJSON` to return DSL representation of the decay score function
     * class instance.
     *
     * @override
     * @returns {Object} returns an Object which maps to the elasticsearch query DSL
     */
    toJSON() {
        // TODO: If mode/field is not set throw an error.
        const repr = Object.assign(
            { [this._name]: { [this._field]: this._opts } },
            this._body
        );
        return recursiveToJSON$4(repr);
    }
};

var decayScoreFunction$2 = DecayScoreFunction$1;

scoreFunctions.ScoreFunction = scoreFunction;
scoreFunctions.ScriptScoreFunction = scriptScoreFunction$2;
scoreFunctions.WeightScoreFunction = weightScoreFunction$2;
scoreFunctions.RandomScoreFunction = randomScoreFunction$2;
scoreFunctions.FieldValueFactorFunction = fieldValueFactorFunction$2;
scoreFunctions.DecayScoreFunction = decayScoreFunction$2;

const isNil$M = lodash_isnil;

const {
    Query: Query$h,
    util: { checkType: checkType$A }
} = core;

/**
 * A query that wraps another query and simply returns a constant score
 * equal to the query boost for every document in the filter.
 * Maps to Lucene `ConstantScoreQuery`.
 *
 * Constructs a query where each documents returned by the internal
 * query or filter have a constant score equal to the boost factor.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-constant-score-query.html)
 *
 * @example
 * const qry = esb.constantScoreQuery(esb.termQuery('user', 'kimchy')).boost(1.2);
 *
 * @param {Query=} filterQuery Query to filter on.
 *
 * @extends Query
 */
let ConstantScoreQuery$1 = class ConstantScoreQuery extends Query$h {
    // eslint-disable-next-line require-jsdoc
    constructor(filterQuery) {
        super('constant_score');

        if (!isNil$M(filterQuery)) this.filter(filterQuery);
    }

    /**
     * Adds the query to apply a constant score to.
     *
     * @param {Query} filterQuery  Query to filter on.
     * @returns {ConstantScoreQuery} returns `this` so that calls can be chained.
     */
    filter(filterQuery) {
        checkType$A(filterQuery, Query$h);

        this._queryOpts.filter = filterQuery;
        return this;
    }

    /**
     * Adds the query to apply a constant score to.
     * Alias for method `filter`.
     *
     * Note: This parameter has been removed in elasticsearch 6.0. Use `filter` instead.
     *
     * @param {Query} filterQuery  Query to filter on.
     * @returns {ConstantScoreQuery} returns `this` so that calls can be chained.
     */
    query(filterQuery) {
        return this.filter(filterQuery);
    }
};

var constantScoreQuery$2 = ConstantScoreQuery$1;

/**
 * lodash 4.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/**
 * Gets the first element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @alias first
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the first element of `array`.
 * @example
 *
 * _.head([1, 2, 3]);
 * // => 1
 *
 * _.head([]);
 * // => undefined
 */
function head$1(array) {
  return (array && array.length) ? array[0] : undefined;
}

var lodash_head = head$1;

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_SAFE_INTEGER = 9007199254740991;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    symbolTag = '[object Symbol]';

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/**
 * A specialized version of `_.includes` for arrays without support for
 * specifying an index to search from.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludes(array, value) {
  var length = array ? array.length : 0;
  return !!length && baseIndexOf(array, value, 0) > -1;
}

/**
 * This function is like `arrayIncludes` except that it accepts a comparator.
 *
 * @private
 * @param {Array} [array] The array to inspect.
 * @param {*} target The value to search for.
 * @param {Function} comparator The comparator invoked per element.
 * @returns {boolean} Returns `true` if `target` is found, else `false`.
 */
function arrayIncludesWith(array, value, comparator) {
  var index = -1,
      length = array ? array.length : 0;

  while (++index < length) {
    if (comparator(value, array[index])) {
      return true;
    }
  }
  return false;
}

/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array ? array.length : 0,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseFindIndex(array, predicate, fromIndex, fromRight) {
  var length = array.length,
      index = fromIndex + (fromRight ? 1 : -1);

  while ((fromRight ? index-- : ++index < length)) {
    if (predicate(array[index], index, array)) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function baseIndexOf(array, value, fromIndex) {
  if (value !== value) {
    return baseFindIndex(array, baseIsNaN, fromIndex);
  }
  var index = fromIndex - 1,
      length = array.length;

  while (++index < length) {
    if (array[index] === value) {
      return index;
    }
  }
  return -1;
}

/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */
function baseIsNaN(value) {
  return value !== value;
}

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/**
 * Checks if a cache value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/** Used for built-in method references. */
var arrayProto = Array.prototype,
    funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty$1 = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty$1).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/** Built-in value references. */
var index_6bd0eeff_Symbol = root.Symbol,
    getPrototype = overArg(Object.getPrototypeOf, Object),
    propertyIsEnumerable = objectProto.propertyIsEnumerable,
    splice = arrayProto.splice,
    spreadableSymbol = index_6bd0eeff_Symbol ? index_6bd0eeff_Symbol.isConcatSpreadable : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols,
    nativeMax = Math.max;

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map'),
    nativeCreate = getNative(Object, 'create');

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
}

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  return this.has(key) && delete this.__data__[key];
}

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty$1.call(data, key) ? data[key] : undefined;
}

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? data[key] !== undefined : hasOwnProperty$1.call(data, key);
}

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
}

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  return true;
}

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries ? entries.length : 0;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  return getMapData(this, key)['delete'](key);
}

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  getMapData(this, key).set(key, value);
  return this;
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values ? values.length : 0;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  // Safari 9 makes `arguments.length` enumerable in strict mode.
  var result = (isArray(value) || isArguments(value))
    ? baseTimes(value.length, String)
    : [];

  var length = result.length,
      skipIndexes = !!length;

  for (var key in value) {
    if ((inherited || hasOwnProperty$1.call(value, key)) &&
        !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/**
 * The base implementation of methods like `_.difference` without support
 * for excluding multiple arrays or iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Array} values The values to exclude.
 * @param {Function} [iteratee] The iteratee invoked per element.
 * @param {Function} [comparator] The comparator invoked per element.
 * @returns {Array} Returns the new array of filtered values.
 */
function baseDifference(array, values, iteratee, comparator) {
  var index = -1,
      includes = arrayIncludes,
      isCommon = true,
      length = array.length,
      result = [],
      valuesLength = values.length;

  if (!length) {
    return result;
  }
  if (iteratee) {
    values = arrayMap(values, baseUnary(iteratee));
  }
  if (comparator) {
    includes = arrayIncludesWith;
    isCommon = false;
  }
  else if (values.length >= LARGE_ARRAY_SIZE) {
    includes = cacheHas;
    isCommon = false;
    values = new SetCache(values);
  }
  outer:
  while (++index < length) {
    var value = array[index],
        computed = iteratee ? iteratee(value) : value;

    value = (comparator || value !== 0) ? value : 0;
    if (isCommon && computed === computed) {
      var valuesIndex = valuesLength;
      while (valuesIndex--) {
        if (values[valuesIndex] === computed) {
          continue outer;
        }
      }
      result.push(value);
    }
    else if (!includes(values, computed, comparator)) {
      result.push(value);
    }
  }
  return result;
}

/**
 * The base implementation of `_.flatten` with support for restricting flattening.
 *
 * @private
 * @param {Array} array The array to flatten.
 * @param {number} depth The maximum recursion depth.
 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
 * @param {Array} [result=[]] The initial result value.
 * @returns {Array} Returns the new flattened array.
 */
function baseFlatten(array, depth, predicate, isStrict, result) {
  var index = -1,
      length = array.length;

  predicate || (predicate = isFlattenable);
  result || (result = []);

  while (++index < length) {
    var value = array[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        // Recursively flatten arrays (susceptible to call stack limits).
        baseFlatten(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject$1(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!isObject$1(object)) {
    return nativeKeysIn(object);
  }
  var isProto = isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !hasOwnProperty$1.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/**
 * The base implementation of `_.pick` without support for individual
 * property identifiers.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} props The property identifiers to pick.
 * @returns {Object} Returns the new object.
 */
function basePick(object, props) {
  object = Object(object);
  return basePickBy(object, props, function(value, key) {
    return key in object;
  });
}

/**
 * The base implementation of  `_.pickBy` without support for iteratee shorthands.
 *
 * @private
 * @param {Object} object The source object.
 * @param {string[]} props The property identifiers to pick from.
 * @param {Function} predicate The function invoked per property.
 * @returns {Object} Returns the new object.
 */
function basePickBy(object, props, predicate) {
  var index = -1,
      length = props.length,
      result = {};

  while (++index < length) {
    var key = props[index],
        value = object[key];

    if (predicate(value, key)) {
      result[key] = value;
    }
  }
  return result;
}

/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = array;
    return apply(func, this, otherArgs);
  };
}

/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return baseGetAllKeys(object, keysIn, getSymbolsIn);
}

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

/**
 * Creates an array of the own enumerable symbol properties of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;

/**
 * Creates an array of the own and inherited enumerable symbol properties
 * of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  var result = [];
  while (object) {
    arrayPush(result, getSymbols(object));
    object = getPrototype(object);
  }
  return result;
};

/**
 * Checks if `value` is a flattenable `arguments` object or array.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
 */
function isFlattenable(value) {
  return isArray(value) || isArguments(value) ||
    !!(spreadableSymbol && value && value[spreadableSymbol]);
}

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
function isArguments(value) {
  // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
  return isArrayLikeObject(value) && hasOwnProperty$1.call(value, 'callee') &&
    (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
}

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return isObjectLike(value) && isArrayLike(value);
}

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8-9 which returns 'object' for typed array and other constructors.
  var tag = isObject$1(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject$1(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn(object) {
  return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
}

/**
 * The opposite of `_.pick`; this method creates an object composed of the
 * own and inherited enumerable string keyed properties of `object` that are
 * not omitted.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The source object.
 * @param {...(string|string[])} [props] The property identifiers to omit.
 * @returns {Object} Returns the new object.
 * @example
 *
 * var object = { 'a': 1, 'b': '2', 'c': 3 };
 *
 * _.omit(object, ['a', 'c']);
 * // => { 'b': '2' }
 */
var omit$1 = baseRest(function(object, props) {
  if (object == null) {
    return {};
  }
  props = arrayMap(baseFlatten(props, 1), toKey);
  return basePick(object, baseDifference(getAllKeysIn(object), props));
});

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

var lodash_omit = omit$1;

const has$4 = lodash_has;
const head = lodash_head;
const omit = lodash_omit;

const {
    Query: Query$g,
    util: { checkType: checkType$z, setDefault: setDefault$6, recursiveToJSON: recursiveToJSON$3 }
} = core;

/**
 * A query that matches documents matching boolean combinations of other queries.
 * The bool query maps to Lucene `BooleanQuery`. It is built using one or more
 * boolean clauses, each clause with a typed occurrence.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html)
 *
 * @example
 * const qry = esb.boolQuery()
 *     .must(esb.termQuery('user', 'kimchy'))
 *     .filter(esb.termQuery('tag', 'tech'))
 *     .mustNot(esb.rangeQuery('age').gte(10).lte(20))
 *     .should([
 *         esb.termQuery('tag', 'wow'),
 *         esb.termQuery('tag', 'elasticsearch')
 *     ])
 *     .minimumShouldMatch(1)
 *     .boost(1.0);
 *
 * @extends Query
 */
let BoolQuery$2 = class BoolQuery extends Query$g {
    // eslint-disable-next-line require-jsdoc
    constructor() {
        super('bool');
    }

    /**
     * Add given query to list of queries under given clause.
     *
     * @private
     * @param {string} clause
     * @param {Query} query
     * @throws {TypeError} If query is not an instance of `Query`
     */
    _addQuery(clause, query) {
        checkType$z(query, Query$g);

        this._queryOpts[clause].push(query);
    }

    /**
     * Add given query array or query to list of queries under given clause.
     *
     * @private
     * @param {string} clause
     * @param {Array<Query>|Query} queries List of valid `Query` objects or a `Query` object
     * @throws {TypeError} If Array item or query is not an instance of `Query`
     */
    _addQueries(clause, queries) {
        setDefault$6(this._queryOpts, clause, []);

        if (Array.isArray(queries))
            queries.forEach(qry => this._addQuery(clause, qry));
        else this._addQuery(clause, queries);
    }

    /**
     * Adds `must` query to boolean container.
     * The clause (query) **must** appear in matching documents and will contribute to the score.
     *
     * @param {Array<Query>|Query} queries List of valid `Query` objects or a `Query` object
     * @returns {BoolQuery} returns `this` so that calls can be chained.
     * @throws {TypeError} If Array item or query is not an instance of `Query`
     */
    must(queries) {
        this._addQueries('must', queries);
        return this;
    }

    /**
     * Adds `filter` query to boolean container.
     * The clause (query) **must** appear in matching documents. However unlike `must` the score
     * of the query will be ignored. Filter clauses are executed in filter context, meaning that
     * scoring is ignored and clauses are considered for caching.
     *
     * @example
     * // Assign score of `0` to all documents
     * const qry = esb.boolQuery().filter(esb.termQuery('status', 'active'));
     *
     * // Assign a score of `1.0` to all documents
     * const qry = esb.boolQuery()
     *     .must(esb.matchAllQuery())
     *     .filter(esb.termQuery('status', 'active'));
     *
     * @param {Array<Query>|Query} queries List of valid `Query` objects or a `Query` object
     * @returns {BoolQuery} returns `this` so that calls can be chained.
     * @throws {TypeError} If Array item or query is not an instance of `Query`
     */
    filter(queries) {
        this._addQueries('filter', queries);
        return this;
    }

    /**
     * Adds `must_not` query to boolean container.
     * The clause (query) **must not** appear in the matching documents.
     * Clauses are executed in filter context meaning that scoring is ignored
     * and clauses are considered for caching. Because scoring is ignored,
     * a score of 0 for all documents is returned.
     *
     * @param {Array<Query>|Query} queries List of valid `Query` objects or a `Query` object
     * @returns {BoolQuery} returns `this` so that calls can be chained.
     * @throws {TypeError} If Array item or query is not an instance of `Query`
     */
    mustNot(queries) {
        this._addQueries('must_not', queries);
        return this;
    }

    /**
     * Adds `should` query to boolean container.
     * The clause (query) **should** appear in the matching document. In a boolean query with
     * no must or filter clauses, one or more should clauses must match a document.
     * The minimum number of should clauses to match can be set using the
     * `minimum_should_match` parameter.
     *
     * @param {Array<Query>|Query} queries List of valid `Query` objects or a `Query` object
     * @returns {BoolQuery} returns `this` so that calls can be chained.
     * @throws {TypeError} If Array item or query is not an instance of `Query`
     */
    should(queries) {
        this._addQueries('should', queries);
        return this;
    }

    /**
     * Enables or disables similarity coordinate scoring of documents
     * commoning the `CommonTermsQuery`. Default: `false`.
     *
     * **NOTE**: This has been removed in elasticsearch 6.0. If provided,
     * it will be ignored and a deprecation warning will be issued.
     *
     * @param {boolean} enable
     * @returns {BoolQuery} returns `this` so that calls can be chained.
     */
    disableCoord(enable) {
        this._queryOpts.disable_coord = enable;
        return this;
    }

    /**
     * Sets the value controlling how many `should` clauses in the boolean
     * query should match. It can be an absolute value (2), a percentage (30%)
     * or a combination of both. By default no optional clauses are necessary for a match.
     * However, if the bool query is used in a filter context and it has `should` clauses then,
     * at least one `should` clause is required to match.
     *
     * @param {string|number} minimumShouldMatch An absolute value (2), a percentage (30%)
     * or a combination of both.
     * @returns {BoolQuery} returns `this` so that calls can be chained.
     */
    minimumShouldMatch(minimumShouldMatch) {
        this._queryOpts.minimum_should_match = minimumShouldMatch;
        return this;
    }

    /**
     * Sets if the `Query` should be enhanced with a `MatchAllQuery` in order
     * to act as a pure exclude when only negative (mustNot) clauses exist. Default: true.
     *
     * @param {boolean} enable
     * @returns {BoolQuery} returns `this` so that calls can be chained.
     */
    adjustPureNegative(enable) {
        this._queryOpts.adjust_pure_negative = enable;
        return this;
    }

    /**
     * Override default `toJSON` to return DSL representation of the `bool` compound query
     * class instance.
     *
     * @override
     * @returns {Object} returns an Object which maps to the elasticsearch query DSL
     */
    toJSON() {
        const clauseKeys = ['must', 'filter', 'must_not', 'should'];

        // Pick the clauses which have some queries
        const cleanQryOpts = clauseKeys
            .filter(clause => has$4(this._queryOpts, clause))
            .reduce(
                // Unwrap array and put into qryOpts if required
                (qryOpts, clause) => {
                    const clauseQueries = this._queryOpts[clause];
                    qryOpts[clause] = recursiveToJSON$3(
                        clauseQueries.length === 1
                            ? head(clauseQueries)
                            : clauseQueries
                    );
                    return qryOpts;
                },
                // initial value - all key-value except clauses
                omit(this._queryOpts, clauseKeys)
            );

        return {
            [this.queryType]: cleanQryOpts
        };
    }
};

var boolQuery$2 = BoolQuery$2;

const {
    Query: Query$f,
    util: { checkType: checkType$y, setDefault: setDefault$5 }
} = core;

/**
 * A query that generates the union of documents produced by its subqueries,
 * and that scores each document with the maximum score for that document
 * as produced by any subquery, plus a tie breaking increment for
 * any additional matching subqueries.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-dis-max-query.html)
 *
 * @example
 * const qry = esb.disMaxQuery()
 *     .queries([esb.termQuery('age', 34), esb.termQuery('age', 35)])
 *     .tieBreaker(0.7)
 *     .boost(1.2);
 *
 * @example
 * const qry = esb.disMaxQuery()
 *     .queries([
 *         esb.matchQuery('subject', 'brown fox'),
 *         esb.matchQuery('message', 'brown fox')
 *     ])
 *     .tieBreaker(0.3);
 *
 * @extends Query
 */
let DisMaxQuery$1 = class DisMaxQuery extends Query$f {
    // eslint-disable-next-line require-jsdoc
    constructor() {
        super('dis_max');
    }

    /**
     * Add given query to list of queries under given clause.
     *
     * @private
     * @param {Query} query
     * @throws {TypeError} If query is not an instance of `Query`
     */
    _addQuery(query) {
        checkType$y(query, Query$f);

        this._queryOpts.queries.push(query);
    }

    /**
     * The tie breaker value. The tie breaker capability allows results
     * that include the same term in multiple fields to be judged better than
     * results that include this term in only the best of those multiple
     * fields, without confusing this with the better case of two different
     * terms in the multiple fields. Default: `0.0`.
     *
     * @param {number} factor
     * @returns {DisMaxQuery} returns `this` so that calls can be chained.
     */
    tieBreaker(factor) {
        this._queryOpts.tie_breaker = factor;
        return this;
    }

    /**
     * Add given query array or query to list of queries
     *
     * @param {Array<Query>|Query} queries Array of valid `Query` objects or a `Query` object
     * @returns {DisMaxQuery} returns `this` so that calls can be chained.
     */
    queries(queries) {
        setDefault$5(this._queryOpts, 'queries', []);

        if (Array.isArray(queries)) queries.forEach(qry => this._addQuery(qry));
        else this._addQuery(queries);

        return this;
    }
};

var disMaxQuery$2 = DisMaxQuery$1;

const isNil$L = lodash_isnil;

const {
    Query: Query$e,
    util: { checkType: checkType$x, invalidParam: invalidParam$g },
    consts: { SCORE_MODE_SET, BOOST_MODE_SET }
} = core;

const { ScoreFunction } = scoreFunctions;

const ES_REF_URL$P =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-function-score-query.html';

const invalidScoreModeParam$1 = invalidParam$g(
    ES_REF_URL$P,
    'score_mode',
    SCORE_MODE_SET
);
const invalidBoostModeParam = invalidParam$g(
    ES_REF_URL$P,
    'boost_mode',
    BOOST_MODE_SET
);

/**
 * The `function_score` allows you to modify the score of documents that are
 * retrieved by a query. This can be useful if, for example, a score function
 * is computationally expensive and it is sufficient to compute the score on
 * a filtered set of documents.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-function-score-query.html)
 *
 * @example
 * // `function_score` with only one function
 * const qry = esb.functionScoreQuery()
 *     .query(esb.matchAllQuery())
 *     .function(esb.randomScoreFunction())
 *     .boostMode('multiply')
 *     .boost('5');
 *
 * @example
 * // Several functions combined
 * const qry = esb.functionScoreQuery()
 *     .query(esb.matchAllQuery())
 *     .functions([
 *         esb.randomScoreFunction()
 *             .filter(esb.matchQuery('test', 'bar'))
 *             .weight(23),
 *         esb.weightScoreFunction()
 *             .filter(esb.matchQuery('test', 'cat'))
 *             .weight(42)
 *     ])
 *     .maxBoost(42)
 *     .scoreMode('max')
 *     .boostMode('multiply')
 *     .minScore(42)
 *     .boost('5');
 *
 * @example
 * // Combine decay functions
 * const qry = esb.functionScoreQuery()
 *     .functions([
 *         esb.decayScoreFunction('gauss', 'price').origin('0').scale('20'),
 *         esb.decayScoreFunction('gauss', 'location')
 *             .origin('11, 12')
 *             .scale('2km')
 *     ])
 *     .query(esb.matchQuery('properties', 'balcony'))
 *     .scoreMode('multiply');
 *
 * @extends Query
 */
let FunctionScoreQuery$2 = class FunctionScoreQuery extends Query$e {
    // eslint-disable-next-line require-jsdoc
    constructor() {
        super('function_score');

        this._queryOpts.functions = [];
    }

    /**
     * Sets the source query.
     *
     * @param {Query} query A valid `Query` object
     * @returns {FunctionScoreQuery} returns `this` so that calls can be chained.
     */
    query(query) {
        checkType$x(query, Query$e);

        this._queryOpts.query = query;
        return this;
    }

    /**
     * Controls the way the scores are combined.
     *
     * @param {string} mode Can be one of `multiply`, `sum`, `first`, `min`, `max`, `avg`.
     * Defaults to `multiply`.
     * @returns {FunctionScoreQuery} returns `this` so that calls can be chained.
     */
    scoreMode(mode) {
        if (isNil$L(mode)) invalidScoreModeParam$1(mode);

        const modeLower = mode.toLowerCase();
        if (!SCORE_MODE_SET.has(modeLower)) {
            invalidScoreModeParam$1(mode);
        }

        this._queryOpts.score_mode = mode;
        return this;
    }

    /**
     * Controls the way the query and function scores are combined.
     *
     * @param {string} mode Can be one of `multiply`, `replace`, `sum`, `avg`, `max`, `min`.
     * Defaults to `multiply`.
     * @returns {FunctionScoreQuery} returns `this` so that calls can be chained.
     */
    boostMode(mode) {
        if (isNil$L(mode)) invalidBoostModeParam(mode);

        const modeLower = mode.toLowerCase();
        if (!BOOST_MODE_SET.has(modeLower)) {
            invalidBoostModeParam(mode);
        }

        this._queryOpts.boost_mode = modeLower;
        return this;
    }

    /**
     * Restricts new score to not exceed given limit. The default for `max_boost` is `FLT_MAX`.
     *
     * @param {number} limit
     * @returns {FunctionScoreQuery} returns `this` so that calls can be chained.
     */
    maxBoost(limit) {
        this._queryOpts.max_boost = limit;
        return this;
    }

    /**
     * Sets the minimum score limit for documents to be included in search result.
     *
     * @param {number} limit Minimum score threshold
     * @returns {FunctionScoreQuery} returns `this` so that calls can be chained.
     */
    minScore(limit) {
        this._queryOpts.min_score = limit;
        return this;
    }

    /**
     * Add a single score function to the list of existing functions.
     *
     * @param {ScoreFunction} func A valid `ScoreFunction` object.
     * @returns {FunctionScoreQuery} returns `this` so that calls can be chained.
     */
    function(func) {
        checkType$x(func, ScoreFunction);

        this._queryOpts.functions.push(func);
        return this;
    }

    /**
     * Adds array of score functions to the list of existing functions.
     *
     * @param {Array<ScoreFunction>} funcs An array of valid `ScoreFunction` objects
     * @returns {FunctionScoreQuery} returns `this` so that calls can be chained.
     */
    functions(funcs) {
        checkType$x(funcs, Array);

        funcs.forEach(func => this.function(func));
        return this;
    }
};

var functionScoreQuery$2 = FunctionScoreQuery$2;

const isNil$K = lodash_isnil;

const {
    Query: Query$d,
    util: { checkType: checkType$w }
} = core;

/**
 * The boosting query can be used to effectively demote results that match
 * a given query. Unlike the "NOT" clause in bool query, this still selects
 * documents that contain undesirable terms, but reduces their overall
 * score.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-boosting-query.html)
 *
 * @example
 * const qry = esb.boostingQuery(
 *     esb.termQuery('field1', 'value1'), // positiveQry
 *     esb.termQuery('field2', 'value2'), // negativeQry
 *     0.2 // negativeBoost
 * );
 *
 * @param {Query=} positiveQry A valid `Query` object.
 * @param {Query=} negativeQry A valid `Query` object.
 * @param {number=} negativeBoost A positive `double` value where `0 < n < 1`.
 *
 * @extends Query
 */
let BoostingQuery$1 = class BoostingQuery extends Query$d {
    // eslint-disable-next-line require-jsdoc
    constructor(positiveQry, negativeQry, negativeBoost) {
        super('boosting');

        if (!isNil$K(positiveQry)) this.positive(positiveQry);
        if (!isNil$K(negativeQry)) this.negative(negativeQry);
        if (!isNil$K(negativeBoost))
            this._queryOpts.negative_boost = negativeBoost;
    }

    /**
     * Sets the "master" query that determines which results are returned.
     *
     * @param {Query} query A valid `Query` object.
     * @returns {BoostingQuery} returns `this` so that calls can be chained.
     */
    positive(query) {
        checkType$w(query, Query$d);

        this._queryOpts.positive = query;
        return this;
    }

    /**
     * Sets the query used to match documents in the `positive`
     * query that will be negatively boosted.
     *
     * @param {Query} query A valid `Query` object.
     * @returns {BoostingQuery} returns `this` so that calls can be chained.
     */
    negative(query) {
        checkType$w(query, Query$d);

        this._queryOpts.negative = query;
        return this;
    }

    /**
     * Sets the negative boost value.
     *
     * @param {number} factor A positive `double` value where `0 < n < 1`.
     * @returns {BoostingQuery} returns `this` so that calls can be chained.
     */
    negativeBoost(factor) {
        this._queryOpts.negative_boost = factor;
        return this;
    }
};

var boostingQuery$2 = BoostingQuery$1;

compoundQueries.scoreFunctions = scoreFunctions;

compoundQueries.ConstantScoreQuery = constantScoreQuery$2;
compoundQueries.BoolQuery = boolQuery$2;
compoundQueries.DisMaxQuery = disMaxQuery$2;
compoundQueries.FunctionScoreQuery = functionScoreQuery$2;
compoundQueries.BoostingQuery = boostingQuery$2;

var joiningQueries = {};

const isNil$J = lodash_isnil;

const {
    Query: Query$c,
    InnerHits: InnerHits$1,
    util: { checkType: checkType$v, invalidParam: invalidParam$f },
    consts: { NESTED_SCORE_MODE_SET }
} = core;

const invalidScoreModeParam = invalidParam$f(
    '',
    'score_mode',
    NESTED_SCORE_MODE_SET
);
/**
 * The `JoiningQueryBase` class provides support for common options used across
 * various joining query implementations.
 *
 * **NOTE:** Instantiating this directly should not be required.
 * However, if you wish to add a custom implementation for whatever reason,
 * this class could be extended.
 *
 * @param {string} queryType
 * @param {string} refUrl
 * @param {Query=} qry A valid `Query` object
 *
 * @extends Query
 */
let JoiningQueryBase$3 = class JoiningQueryBase extends Query$c {
    // eslint-disable-next-line require-jsdoc
    constructor(queryType, refUrl, qry) {
        super(queryType);
        this.refUrl = refUrl;

        if (!isNil$J(qry)) this.query(qry);
    }

    /**
     * Sets the nested query to be executed.
     *
     * @param {Query} qry A valid `Query` object
     * @returns {JoiningQueryBase} returns `this` so that calls can be chained.
     */
    query(qry) {
        checkType$v(qry, Query$c);

        this._queryOpts.query = qry;
        return this;
    }

    /**
     * Sets the scoring method.
     *
     * Valid values are:
     * - `none` - no scoring
     * - `max` - the highest score of all matched child documents is used
     * - `min` - the lowest score of all matched child documents is used
     * - `sum` - the sum the all the matched child documents is used
     * - `avg` - the default, the average of all matched child documents is used
     *
     * @example
     * const qry = esb.hasChildQuery(
     *     esb.termQuery('tag', 'something'),
     *     'blog_tag'
     * ).scoreMode('min');
     *
     * @param {string} mode Can be one of `none`, `sum`, `min`, `max`, `avg`.
     * Defaults to `avg` for `NestedQuery`, `none` for `HasChildQuery`.
     * @returns {JoiningQueryBase} returns `this` so that calls can be chained.
     */
    scoreMode(mode) {
        if (isNil$J(mode)) invalidScoreModeParam(mode);

        const modeLower = mode.toLowerCase();
        if (!NESTED_SCORE_MODE_SET.has(modeLower)) {
            invalidScoreModeParam(mode);
        }

        this._queryOpts.score_mode = modeLower;
        return this;
    }

    /**
     * When set to `true` will ignore an unmapped `path` and will not match any
     * documents for this query. When set to `false` (the default value) the query
     * will throw an exception if the path is not mapped.
     *
     * @param {boolean} enable `true` or `false`, `false` by default.
     * @returns {JoiningQueryBase} returns `this` so that calls can be chained.
     */
    ignoreUnmapped(enable) {
        this._queryOpts.ignore_unmapped = enable;
        return this;
    }

    /**
     * Sets the inner hits options
     *
     * @param {InnerHits} innerHits A valid `InnerHits` object
     * @returns {JoiningQueryBase} returns `this` so that calls can be chained.
     */
    innerHits(innerHits) {
        checkType$v(innerHits, InnerHits$1);

        this._queryOpts.inner_hits = innerHits;
        return this;
    }
};

var joiningQueryBase = JoiningQueryBase$3;

const isNil$I = lodash_isnil;

const JoiningQueryBase$2 = joiningQueryBase;

const ES_REF_URL$O =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-nested-query.html';

/**
 * Nested query allows to query nested objects. The query is executed against
 * the nested objects / docs as if they were indexed as separate docs
 * (they are, internally) and resulting in the root parent doc (or parent nested mapping).
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-nested-query.html)
 *
 * @example
 * const qry = esb.nestedQuery()
 *     .path('obj1')
 *     .scoreMode('avg')
 *     .query(
 *         esb.boolQuery().must([
 *             esb.matchQuery('obj1.name', 'blue'),
 *             esb.rangeQuery('obj1.count').gt(5)
 *         ])
 *     );
 *
 * @param {Query=} qry A valid `Query` object
 * @param {string=} path The nested object path.
 *
 * @extends JoiningQueryBase
 */
let NestedQuery$1 = class NestedQuery extends JoiningQueryBase$2 {
    // eslint-disable-next-line require-jsdoc
    constructor(qry, path) {
        super('nested', ES_REF_URL$O, qry);

        if (!isNil$I(path)) this._queryOpts.path = path;
    }

    /**
     * Sets the root context for the nested query.
     *
     * @param {string} path
     * @returns {NestedQuery} returns `this` so that calls can be chained.
     */
    path(path) {
        this._queryOpts.path = path;
        return this;
    }
};

var nestedQuery$2 = NestedQuery$1;

const isNil$H = lodash_isnil;

const JoiningQueryBase$1 = joiningQueryBase;

const ES_REF_URL$N =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-has-child-query.html';

/**
 * The `has_child` filter accepts a query and the child type to run against, and
 * results in parent documents that have child docs matching the query.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-has-child-query.html)
 *
 * @example
 * // Scoring support
 * const qry = esb.hasChildQuery(
 *     esb.termQuery('tag', 'something'),
 *     'blog_tag'
 * ).scoreMode('min');
 *
 * @example
 * // Sort by child documents' `click_count` field
 * const qry = esb.hasChildQuery()
 *     .query(
 *         esb.functionScoreQuery().function(
 *             esb.scriptScoreFunction("_score * doc['click_count'].value")
 *         )
 *     )
 *     .type('blog_tag')
 *     .scoreMode('max');
 *
 * @param {Query=} qry A valid `Query` object
 * @param {string=} type The child type
 *
 * @extends JoiningQueryBase
 */
let HasChildQuery$1 = class HasChildQuery extends JoiningQueryBase$1 {
    // eslint-disable-next-line require-jsdoc
    constructor(qry, type) {
        super('has_child', ES_REF_URL$N, qry);

        if (!isNil$H(type)) this._queryOpts.type = type;
    }

    /**
     * Sets the child document type to search against.
     * Alias for method `childType`.
     *
     * @param {string} type A valid doc type name
     * @returns {HasChildQuery} returns `this` so that calls can be chained.
     */
    type(type) {
        this._queryOpts.type = type;
        return this;
    }

    /**
     * Sets the child document type to search against
     *
     * @param {string} type A valid doc type name
     * @returns {HasChildQuery} returns `this` so that calls can be chained.
     */
    childType(type) {
        console.warn(
            '[HasChildQuery] Field `child_type` is deprecated. Use `type` instead.'
        );
        return this.type(type);
    }

    /**
     * Specify the minimum number of children are required to match
     * for the parent doc to be considered a match
     *
     * @example
     * const qry = esb.hasChildQuery(esb.termQuery('tag', 'something'), 'blog_tag')
     *     .minChildren(2)
     *     .maxChildren(10)
     *     .scoreMode('min');
     *
     * @param {number} limit A positive `integer` value.
     * @returns {HasChildQuery} returns `this` so that calls can be chained.
     */
    minChildren(limit) {
        this._queryOpts.min_children = limit;
        return this;
    }

    /**
     * Specify the maximum number of children are required to match
     * for the parent doc to be considered a match
     *
     * @example
     * const qry = esb.hasChildQuery(esb.termQuery('tag', 'something'), 'blog_tag')
     *     .minChildren(2)
     *     .maxChildren(10)
     *     .scoreMode('min');
     *
     * @param {number} limit A positive `integer` value.
     * @returns {HasChildQuery} returns `this` so that calls can be chained.
     */
    maxChildren(limit) {
        this._queryOpts.max_children = limit;
        return this;
    }
};

var hasChildQuery$2 = HasChildQuery$1;

const isNil$G = lodash_isnil;

const JoiningQueryBase = joiningQueryBase;

const ES_REF_URL$M =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-has-parent-query.html';

/**
 * The `has_parent` query accepts a query and a parent type. The query is
 * executed in the parent document space, which is specified by the parent
 * type. This query returns child documents which associated parents have
 * matched.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-has-parent-query.html)
 *
 * @example
 * const qry = esb.hasParentQuery(esb.termQuery('tag', 'something'), 'blog');
 *
 * @example
 * // Sorting tags by parent documents' `view_count` field
 * const qry = esb.hasParentQuery()
 *     .parentType('blog')
 *     .score(true)
 *     .query(
 *         esb.functionScoreQuery().function(
 *             esb.scriptScoreFunction("_score * doc['view_count'].value")
 *         )
 *     );
 *
 * @param {Query=} qry A valid `Query` object
 * @param {string=} type The parent type
 *
 * @extends JoiningQueryBase
 */
let HasParentQuery$1 = class HasParentQuery extends JoiningQueryBase {
    // eslint-disable-next-line require-jsdoc
    constructor(qry, type) {
        super('has_parent', ES_REF_URL$M, qry);

        if (!isNil$G(type)) this._queryOpts.parent_type = type;
    }

    /**
     * @throws {Error} `score_mode` is deprecated. Use `score` instead.
     * @override
     */
    scoreMode() {
        console.log('`score_mode` is deprecated. Use `score` instead');
        console.log(`Please refer ${ES_REF_URL$M}`);
        throw new Error('scoreMode is not supported in HasParentQuery');
    }

    /**
     * Sets the child document type to search against
     * Alias for method `parentType`
     *
     * @param {string} type A valid doc type name
     * @returns {HasParentQuery} returns `this` so that calls can be chained.
     */
    type(type) {
        return this.parentType(type);
    }

    /**
     * Sets the child document type to search against
     *
     * @param {string} type A valid doc type name
     * @returns {HasParentQuery} returns `this` so that calls can be chained.
     */
    parentType(type) {
        this._queryOpts.parent_type = type;
        return this;
    }

    /**
     * By default, scoring is `false` which ignores the score from the parent document.
     * The score is in this case equal to the boost on the `has_parent` query (Defaults to 1).
     * If the score is set to `true`, then the score of the matching parent document is
     * aggregated into the child documents belonging to the matching parent document.
     *
     * @example
     * const qry = esb.hasParentQuery(
     *     esb.termQuery('tag', 'something'),
     *     'blog'
     * ).score(true);
     *
     * @param {boolean} enable `true` to enable scoring, `false` to disable.
     * `false` by default.
     * @returns {HasParentQuery} returns `this` so that calls can be chained.
     */
    score(enable) {
        this._queryOpts.score = enable;
        return this;
    }
};

var hasParentQuery$2 = HasParentQuery$1;

const isNil$F = lodash_isnil;

const { Query: Query$b } = core;

/**
 * The `parent_id` query can be used to find child documents which belong to a particular parent.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-parent-id-query.html)
 *
 * @example
 * const qry = esb.parentIdQuery('blog_tag', 1);
 *
 * @param {string=} type The **child** type. This must be a type with `_parent` field.
 * @param {string|number=} id The required parent id select documents must refer to.
 *
 * @extends Query
 */
let ParentIdQuery$1 = class ParentIdQuery extends Query$b {
    // eslint-disable-next-line require-jsdoc
    constructor(type, id) {
        super('parent_id');

        if (!isNil$F(type)) this._queryOpts.type = type;
        if (!isNil$F(id)) this._queryOpts.id = id;
    }

    /**
     * Sets the child type.
     *
     * @param {string} type The **child** type. This must be a type with `_parent` field.
     * @returns {ParentIdQuery} returns `this` so that calls can be chained.
     */
    type(type) {
        this._queryOpts.type = type;
        return this;
    }

    /**
     * Sets the id.
     *
     * @param {string|number} id The required parent id select documents must refer to.
     * @returns {ParentIdQuery} returns `this` so that calls can be chained.
     */
    id(id) {
        this._queryOpts.id = id;
        return this;
    }

    /**
     * When set to `true` will ignore an unmapped `path` and will not match any
     * documents for this query. When set to `false` (the default value) the query
     * will throw an exception if the path is not mapped.
     *
     * @param {boolean} enable `true` or `false`, `false` by default.
     * @returns {ParentIdQuery} returns `this` so that calls can be chained.
     */
    ignoreUnmapped(enable) {
        this._queryOpts.ignore_unmapped = enable;
        return this;
    }
};

var parentIdQuery$2 = ParentIdQuery$1;

joiningQueries.JoiningQueryBase = joiningQueryBase;

joiningQueries.NestedQuery = nestedQuery$2;
joiningQueries.HasChildQuery = hasChildQuery$2;
joiningQueries.HasParentQuery = hasParentQuery$2;
joiningQueries.ParentIdQuery = parentIdQuery$2;

var geoQueries = {};

const isNil$E = lodash_isnil;

const {
    Query: Query$a,
    util: { invalidParam: invalidParam$e, recursiveToJSON: recursiveToJSON$2 }
} = core;

const invalidValidationMethod = invalidParam$e(
    '',
    'validation_method',
    "'IGNORE_MALFORMED', 'COERCE' or 'STRICT'"
);

/**
 * The `GeoQueryBase` provides support for common options used across
 * various geo query implementations.
 *
 * **NOTE:** Instantiating this directly should not be required.
 * However, if you wish to add a custom implementation for whatever reason,
 * this class could be extended.
 *
 * @param {string} queryType
 * @param {string=} field
 *
 * @extends Query
 */
let GeoQueryBase$4 = class GeoQueryBase extends Query$a {
    // eslint-disable-next-line require-jsdoc
    constructor(queryType, field) {
        super(queryType);

        this._field = null;
        this._fieldOpts = {};

        if (!isNil$E(field)) this._field = field;
    }

    /**
     * Sets the field to run the geo query on.
     *
     * @param {string} field
     * @returns {GeoQueryBase} returns `this` so that calls can be chained.
     */
    field(field) {
        this._field = field;
        return this;
    }

    /**
     * Sets the `validation_method` parameter. Can be set to `IGNORE_MALFORMED` to accept
     * geo points with invalid latitude or longitude, `COERCE` to try and infer correct latitude
     * or longitude, or `STRICT` (default is `STRICT`).
     *
     * Note: The `ignore_malformed` and `coerce` parameters have been removed
     * from `geo_bounding_box`, `geo_polygon`, and `geo_distance` queries in
     * elasticsearch 6.0.
     *
     * @param {string} method One of `IGNORE_MALFORMED`, `COERCE` or `STRICT`(default)
     * @returns {GeoQueryBase} returns `this` so that calls can be chained.
     * @throws {Error} If `method` parameter is not one of `IGNORE_MALFORMED`, `COERCE` or `STRICT`
     */
    validationMethod(method) {
        if (isNil$E(method)) invalidValidationMethod(method);

        const methodUpper = method.toUpperCase();
        if (
            methodUpper !== 'IGNORE_MALFORMED' &&
            methodUpper !== 'COERCE' &&
            methodUpper !== 'STRICT'
        ) {
            invalidValidationMethod(method);
        }

        this._queryOpts.validation_method = methodUpper;
        return this;
    }

    /**
     * Override default `toJSON` to return DSL representation of the geo query
     * class instance.
     *
     * @override
     * @returns {Object} returns an Object which maps to the elasticsearch query DSL
     */
    toJSON() {
        return recursiveToJSON$2({
            [this.queryType]: Object.assign(
                { [this._field]: this._fieldOpts },
                this._queryOpts
            )
        });
    }
};

var geoQueryBase = GeoQueryBase$4;

const isNil$D = lodash_isnil;

const {
    GeoShape: GeoShape$1,
    IndexedShape: IndexedShape$1,
    util: { checkType: checkType$u, invalidParam: invalidParam$d },
    consts: { GEO_RELATION_SET }
} = core;

const GeoQueryBase$3 = geoQueryBase;

const ES_REF_URL$L =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-geo-shape-query.html';

const invalidRelationParam = invalidParam$d(
    ES_REF_URL$L,
    'relation',
    GEO_RELATION_SET
);

/**
 * Filter documents indexed using the `geo_shape` type. Requires
 * the `geo_shape` Mapping.
 *
 * The `geo_shape` query uses the same grid square representation as
 * the `geo_shape` mapping to find documents that have a shape that
 * intersects with the query shape. It will also use the same PrefixTree
 * configuration as defined for the field mapping.
 *
 * The query supports two ways of defining the query shape, either by
 * providing a whole shape definition, or by referencing the name of
 * a shape pre-indexed in another index.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-geo-shape-query.html)
 *
 * @example
 * const geoQry = esb.geoShapeQuery('location')
 *     .shape(esb.geoShape()
 *         .type('envelope')
 *         .coordinates([[13.0, 53.0], [14.0, 52.0]]))
 *     .relation('within');
 *
 * @example
 * // Pre-indexed shape
 * const geoQry = esb.geoShapeQuery()
 *     .field('location')
 *     .indexedShape(esb.indexedShape()
 *         .id('DEU')
 *         .type('countries')
 *         .index('shapes')
 *         .path('location'))
 *
 * @param {string=} field
 *
 * @extends GeoQueryBase
 */
let GeoShapeQuery$1 = class GeoShapeQuery extends GeoQueryBase$3 {
    // eslint-disable-next-line require-jsdoc
    constructor(field) {
        super('geo_shape', field);
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on GeoShapeQuery
     */
    validationMethod() {
        console.log(`Please refer ${ES_REF_URL$L}`);
        throw new Error('validationMethod is not supported in GeoShapeQuery');
    }

    /**
     * Sets the shape definition for the geo query.
     *
     * @param {GeoShape} shape
     * @returns {GeoShapeQuery} returns `this` so that calls can be chained.
     * @throws {TypeError} If given `shape` is not an instance of `GeoShape`
     */
    shape(shape) {
        checkType$u(shape, GeoShape$1);

        this._fieldOpts.shape = shape;
        return this;
    }

    /**
     * Sets the reference name of a shape pre-indexed in another index.
     *
     * @param {IndexedShape} shape
     * @returns {GeoShapeQuery} returns `this` so that calls can be chained.
     * @throws {TypeError} If given `shape` is not an instance of `IndexedShape`
     */
    indexedShape(shape) {
        checkType$u(shape, IndexedShape$1);

        this._fieldOpts.indexed_shape = shape;
        return this;
    }

    /**
     * Sets the relationship between Query and indexed data
     * that will be used to determine if a Document should be matched or not.
     *
     * @param {string} relation Can be one of `WITHIN`, `CONTAINS`, `DISJOINT`
     * or `INTERSECTS`(default)
     * @returns {GeoShapeQuery} returns `this` so that calls can be chained
     */
    relation(relation) {
        if (isNil$D(relation)) invalidRelationParam(relation);

        const relationUpper = relation.toUpperCase();
        if (!GEO_RELATION_SET.has(relationUpper)) {
            invalidRelationParam(relation);
        }

        this._fieldOpts.relation = relationUpper;
        return this;
    }

    /**
     * When set to `true` will ignore an unmapped `path` and will not match any
     * documents for this query. When set to `false` (the default value) the query
     * will throw an exception if the path is not mapped.
     *
     * @param {boolean} enable `true` or `false`, `false` by default.
     * @returns {GeoShapeQuery} returns `this` so that calls can be chained.
     */
    ignoreUnmapped(enable) {
        this._queryOpts.ignore_unmapped = enable;
        return this;
    }
};

var geoShapeQuery$2 = GeoShapeQuery$1;

const isNil$C = lodash_isnil;

const {
    GeoPoint: GeoPoint$4,
    util: { checkType: checkType$t, invalidParam: invalidParam$c }
} = core;

const GeoQueryBase$2 = geoQueryBase;

const ES_REF_URL$K =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-geo-bounding-box-query.html';

const invalidTypeParam = invalidParam$c(
    ES_REF_URL$K,
    'type',
    "'memory' or 'indexed'"
);

/**
 * A query allowing to filter hits based on a point location using a bounding box.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-geo-bounding-box-query.html)
 *
 * @example
 * // Format of point in Geohash
 * const qry = esb.geoBoundingBoxQuery('pin.location')
 *     .topLeft(esb.geoPoint().string('dr5r9ydj2y73'))
 *     .bottomRight(esb.geoPoint().string('drj7teegpus6'));
 *
 * @example
 * // Format of point with lat lon as properties
 * const qry = esb.geoBoundingBoxQuery()
 *     .field('pin.location')
 *     .topLeft(esb.geoPoint()
 *         .lat(40.73)
 *         .lon(-74.1))
 *     .bottomRight(esb.geoPoint()
 *         .lat(40.10)
 *         .lon(-71.12));
 *
 * @example
 * // Set bounding box values separately
 * const qry = esb.geoBoundingBoxQuery('pin.location')
 *     .top(40.73)
 *     .left(-74.1)
 *     .bottom(40.01)
 *     .right(-71.12);
 *
 * @param {string=} field
 *
 * @extends GeoQueryBase
 */
let GeoBoundingBoxQuery$1 = class GeoBoundingBoxQuery extends GeoQueryBase$2 {
    // eslint-disable-next-line require-jsdoc
    constructor(field) {
        super('geo_bounding_box', field);
    }

    /**
     * Sets the top left coordinate for the Geo bounding box filter for
     * querying documents
     *
     * @param {GeoPoint} point A valid `GeoPoint`
     * @returns {GeoBoundingBoxQuery} returns `this` so that calls can be chained.
     */
    topLeft(point) {
        checkType$t(point, GeoPoint$4);

        this._fieldOpts.top_left = point;
        return this;
    }

    /**
     * Sets the bottom right coordinate for the Geo bounding box filter for
     * querying documents
     *
     * @param {GeoPoint} point A valid `GeoPoint`
     * @returns {GeoBoundingBoxQuery} returns `this` so that calls can be chained.
     */
    bottomRight(point) {
        checkType$t(point, GeoPoint$4);

        this._fieldOpts.bottom_right = point;
        return this;
    }

    /**
     * Sets the top right coordinate for the Geo bounding box filter for
     * querying documents
     *
     * @param {GeoPoint} point A valid `GeoPoint`
     * @returns {GeoBoundingBoxQuery} returns `this` so that calls can be chained.
     */
    topRight(point) {
        checkType$t(point, GeoPoint$4);

        this._fieldOpts.top_right = point;
        return this;
    }

    /**
     * Sets the bottom left coordinate for the Geo bounding box filter for
     * querying documents
     *
     * @param {GeoPoint} point A valid `GeoPoint`
     * @returns {GeoBoundingBoxQuery} returns `this` so that calls can be chained.
     */
    bottomLeft(point) {
        checkType$t(point, GeoPoint$4);

        this._fieldOpts.bottom_left = point;
        return this;
    }

    /**
     * Sets value for top of the bounding box.
     *
     * @param {number} val
     * @returns {GeoBoundingBoxQuery} returns `this` so that calls can be chained.
     */
    top(val) {
        this._fieldOpts.top = val;
        return this;
    }

    /**
     * Sets value for left of the bounding box.
     *
     * @param {number} val
     * @returns {GeoBoundingBoxQuery} returns `this` so that calls can be chained.
     */
    left(val) {
        this._fieldOpts.left = val;
        return this;
    }

    /**
     * Sets value for bottom of the bounding box.
     *
     * @param {number} val
     * @returns {GeoBoundingBoxQuery} returns `this` so that calls can be chained.
     */
    bottom(val) {
        this._fieldOpts.bottom = val;
        return this;
    }

    /**
     * Sets value for right of the bounding box.
     *
     * @param {number} val
     * @returns {GeoBoundingBoxQuery} returns `this` so that calls can be chained.
     */
    right(val) {
        this._fieldOpts.right = val;
        return this;
    }

    /**
     * Sets the type of execution for the bounding box query.
     * The type of the bounding box execution by default is set to memory,
     * which means in memory checks if the doc falls within the bounding
     * box range. In some cases, an indexed option will perform faster
     * (but note that the geo_point type must have lat and lon indexed in this case)
     *
     * @example
     *
     * const geoQry = esb.geoBoundingBoxQuery()
     *     .field('pin.location')
     *     .topLeft(esb.geoPoint()
     *         .lat(40.73)
     *         .lon(-74.1))
     *     .bottomRight(esb.geoPoint()
     *         .lat(40.10)
     *         .lon(-71.12))
     *     .type('indexed');
     *
     * @param {string} type Can either `memory` or `indexed`
     * @returns {GeoBoundingBoxQuery} returns `this` so that calls can be chained.
     */
    type(type) {
        if (isNil$C(type)) invalidTypeParam(type);

        const typeLower = type.toLowerCase();
        if (typeLower !== 'memory' && typeLower !== 'indexed') {
            invalidTypeParam(type);
        }

        this._queryOpts.type = typeLower;
        return this;
    }
};

var geoBoundingBoxQuery$2 = GeoBoundingBoxQuery$1;

const isNil$B = lodash_isnil;

const {
    GeoPoint: GeoPoint$3,
    util: { checkType: checkType$s, invalidParam: invalidParam$b }
} = core;

const GeoQueryBase$1 = geoQueryBase;

const ES_REF_URL$J =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-geo-distance-query.html';

const invalidDistanceTypeParam$1 = invalidParam$b(
    ES_REF_URL$J,
    'distance_type',
    "'plane' or 'arc'"
);

/**
 * Filters documents that include only hits that exists within a specific distance from a geo point.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-geo-distance-query.html)
 *
 * @example
 * const qry = esb.geoDistanceQuery('pin.location', esb.geoPoint().lat(40).lon(-70))
 *     .distance('12km');
 *
 * const qry = esb.geoDistanceQuery()
 *     .field('pin.location')
 *     .distance('200km')
 *     .geoPoint(esb.geoPoint().lat(40).lon(-70));
 *
 * @param {string=} field
 * @param {GeoPoint=} point Geo point used to measure and filter documents based on distance from it.
 *
 * @extends GeoQueryBase
 */
let GeoDistanceQuery$1 = class GeoDistanceQuery extends GeoQueryBase$1 {
    // eslint-disable-next-line require-jsdoc
    constructor(field, point) {
        super('geo_distance', field);

        if (!isNil$B(point)) this.geoPoint(point);
    }

    /**
     * Sets the radius of the circle centred on the specified location. Points which
     * fall into this circle are considered to be matches. The distance can be specified
     * in various units.
     *
     * @param {string|number} distance Radius of circle centred on specified location.
     * @returns {GeoDistanceQuery} returns `this` so that calls can be chained.
     */
    distance(distance) {
        this._queryOpts.distance = distance;
        return this;
    }

    /**
     * Sets the distance calculation mode, `arc` or `plane`.
     * The `arc` calculation is the more accurate.
     * The `plane` is the faster but least accurate.
     *
     * @param {string} type
     * @returns {GeoDistanceQuery} returns `this` so that calls can be chained
     * @throws {Error} If `type` is neither `plane` nor `arc`.
     */
    distanceType(type) {
        if (isNil$B(type)) invalidDistanceTypeParam$1(type);

        const typeLower = type.toLowerCase();
        if (typeLower !== 'plane' && typeLower !== 'arc')
            invalidDistanceTypeParam$1(type);

        this._queryOpts.distance_type = typeLower;
        return this;
    }

    /**
     * Sets the point to filter documents based on the distance from it.
     *
     * @param {GeoPoint} point Geo point used to measure and filter documents based on distance from it.
     * @returns {GeoDistanceQuery} returns `this` so that calls can be chained
     * @throws {TypeError} If parameter `point` is not an instance of `GeoPoint`
     */
    geoPoint(point) {
        checkType$s(point, GeoPoint$3);

        this._fieldOpts = point;
        return this;
    }
};

var geoDistanceQuery$2 = GeoDistanceQuery$1;

const {
    util: { checkType: checkType$r }
} = core;

const GeoQueryBase = geoQueryBase;

/**
 * A query allowing to include hits that only fall within a polygon of points.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-geo-polygon-query.html)
 *
 * @example
 * const geoQry = esb.geoPolygonQuery('person.location')
 *     .points([
 *         {"lat" : 40, "lon" : -70},
 *         {"lat" : 30, "lon" : -80},
 *         {"lat" : 20, "lon" : -90}
 *     ]);
 *
 * @param {string=} field
 *
 * @extends GeoQueryBase
 */
let GeoPolygonQuery$1 = class GeoPolygonQuery extends GeoQueryBase {
    // eslint-disable-next-line require-jsdoc
    constructor(field) {
        super('geo_polygon', field);
    }

    /**
     * Sets the points which form the polygon.
     * Points can be instances of `GeoPoint`, Object with `lat`, `lon` keys,
     * `GeoJSON` array representation or string(`geohash`/`lat, lon`)
     *
     * @example
     * // Format in `[lon, lat]`
     * const qry = esb.geoPolygonQuery('person.location').points([
     *     [-70, 40],
     *     [-80, 30],
     *     [-90, 20]
     * ]);
     *
     * @example
     * // Format in lat,lon
     * const qry = esb.geoPolygonQuery('person.location').points([
     *     '40, -70',
     *     '30, -80',
     *     '20, -90'
     * ]);
     *
     * @example
     * // Geohash
     * const qry = esb.geoPolygonQuery('person.location').points([
     *     'drn5x1g8cu2y',
     *     '30, -80',
     *     '20, -90'
     * ]);
     *
     * @param {Array<*>} points
     * @returns {GeoPolygonQuery} returns `this` so that calls can be chained
     * @throws {TypeError} If `points` parameter is not an instance of `Array`.
     */
    points(points) {
        checkType$r(points, Array);

        this._fieldOpts.points = points;
        return this;
    }
};

var geoPolygonQuery$2 = GeoPolygonQuery$1;

geoQueries.GeoQueryBase = geoQueryBase;

geoQueries.GeoShapeQuery = geoShapeQuery$2;
geoQueries.GeoBoundingBoxQuery = geoBoundingBoxQuery$2;
geoQueries.GeoDistanceQuery = geoDistanceQuery$2;
geoQueries.GeoPolygonQuery = geoPolygonQuery$2;

var specializedQueries = {};

const has$3 = lodash_has;

const {
    Query: Query$9,
    util: { checkType: checkType$q }
} = core;

/**
 * The More Like This Query (MLT Query) finds documents that are "like" a given set
 * of documents. In order to do so, MLT selects a set of representative terms of
 * these input documents, forms a query using these terms, executes the query and
 * returns the results. The user controls the input documents, how the terms should
 * be selected and how the query is formed.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-mlt-query.html)
 *
 * @example
 * // Ask for documents that are similar to a provided piece of text
 * const qry = esb.moreLikeThisQuery()
 *     .fields(['title', 'description'])
 *     .like('Once upon a time')
 *     .minTermFreq(1)
 *     .maxQueryTerms(12);
 *
 * @example
 * // Mixing texts with documents already existing in the index
 * const qry = esb.moreLikeThisQuery()
 *     .fields(['title', 'description'])
 *     .like({ _index: 'imdb', _type: 'movies', _id: '1' })
 *     .like({ _index: 'imdb', _type: 'movies', _id: '2' })
 *     .like('and potentially some more text here as well')
 *     .minTermFreq(1)
 *     .maxQueryTerms(12);
 *
 * @example
 * // Provide documents not present in the index
 * const qry = esb.moreLikeThisQuery()
 *     .fields(['name.first', 'name.last'])
 *     .like([
 *         {
 *             _index: 'marvel',
 *             _type: 'quotes',
 *             doc: {
 *                 name: { first: 'Ben', last: 'Grimm' },
 *                 tweet: "You got no idea what I'd... what I'd give to be invisible."
 *             }
 *         },
 *         { _index: 'marvel', _type: 'quotes', _id: '2' }
 *     ])
 *     .minTermFreq(1)
 *     .maxQueryTerms(12);
 *
 * @extends Query
 */
let MoreLikeThisQuery$1 = class MoreLikeThisQuery extends Query$9 {
    // eslint-disable-next-line require-jsdoc
    constructor() {
        super('more_like_this');
    }

    /**
     *
     * @private
     * @param {string} clauseType
     * @param {string|Object|Array} clauses
     */
    _setSearchClause(clauseType, clauses) {
        // Replace the field. Don't care about previous contents
        if (Array.isArray(clauses)) this._queryOpts[clauseType] = clauses;
        else if (!has$3(this._queryOpts, clauseType)) {
            // Keep the single `like` without array.
            this._queryOpts[clauseType] = clauses;
        } else {
            // Wrap the single `like` in an array
            if (!Array.isArray(this._queryOpts[clauseType])) {
                this._queryOpts[clauseType] = [this._queryOpts[clauseType]];
            }
            // Append to array
            this._queryOpts[clauseType].push(clauses);
        }
    }

    /**
     * Sets the list of fields to fetch and analyze the text from. Defaults to
     * the `_all` field for free text and to all possible fields for document inputs.
     *
     * @param {Array<string>} fields Array of fields to search against
     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained
     */
    fields(fields) {
        checkType$q(fields, Array);

        this._queryOpts.fields = fields;
        return this;
    }

    /**
     * Sets the search clause for the query. It is the only required parameter of the MLT query
     * and follows a versatile syntax, in which the user can specify free form text and/or
     * a single or multiple documents (see examples above). The syntax to specify documents
     * is similar to the one used by the [Multi GET API](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-multi-get.html).
     * When specifying documents, the text is fetched from fields unless overridden
     * in each document request. The text is analyzed by the analyzer at the field,
     * but could also be overridden. The syntax to override the analyzer at the
     * field follows a similar syntax to the `per_field_analyzer` parameter of the
     * [Term Vectors API](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-termvectors.html#docs-termvectors-per-field-analyzer).
     * Additionally, to provide documents not necessarily present in the index,
     * [artificial documents](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-termvectors.html#docs-termvectors-artificial-doc)
     * are also supported.
     *
     * If string or object is passed, it is
     * appended to the list. If an array is passed, it replaces the existing list.
     *
     * @param {string|Object|Array} like Can be passed as a string,
     * Object representing indexed document, or array of string/objects.
     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained
     */
    like(like) {
        this._setSearchClause('like', like);
        return this;
    }

    /**
     * The `unlike` parameter is used in conjunction with `like` in order not to
     * select terms found in a chosen set of documents. In other words, we could ask
     * for documents `like`: "Apple", but `unlike`: "cake crumble tree".
     * The syntax is the same as like.
     *
     * @param {string|Object|Array} unlike Can be passed as a string,
     * Object representing indexed document, or array of string/objects.
     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained
     */
    unlike(unlike) {
        this._setSearchClause('unlike', unlike);
        return this;
    }

    /**
     * Sets the text to find documents like it.
     *
     * Note: This parameter has been removed in elasticsearch 6.0. Use `like`
     * instead.
     *
     * @param {string} txt The text to find documents like it.
     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained
     */
    likeText(txt) {
        this._queryOpts.like_text = txt;
        return this;
    }

    /**
     * Sets the list of `ids` for the documents with syntax similar to
     * the [Multi GET API](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-multi-get.html).
     *
     * Note: This parameter has been removed in elasticsearch 6.0. Use `like`
     * instead.
     *
     * @param {Array<string>} ids
     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained
     */
    ids(ids) {
        checkType$q(ids, Array);

        this._queryOpts.ids = ids;
        return this;
    }

    /**
     * Sets the list of `docs` for the documents with syntax similar to
     * the [Multi GET API](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-multi-get.html).
     *
     * Note: This parameter has been removed in elasticsearch 6.0. Use `like`
     * instead.
     *
     * @param {Array<Object>} docs
     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained
     */
    docs(docs) {
        checkType$q(docs, Array);

        this._queryOpts.docs = docs;
        return this;
    }

    /**
     * Sets the maximum number of query terms that will be selected.
     * Increasing this value gives greater accuracy at the expense of query execution speed.
     * Defaults to `25`.
     *
     * @param {number} termsLimit The maximum number of query terms that will be selected.
     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained
     */
    maxQueryTerms(termsLimit) {
        this._queryOpts.max_query_terms = termsLimit;
        return this;
    }

    /**
     * Sets the minimum term frequency below which the terms will be ignored from
     * the input document Defaults to 2.
     *
     * @param {number} termFreqLimit
     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained
     */
    minTermFreq(termFreqLimit) {
        this._queryOpts.min_term_freq = termFreqLimit;
        return this;
    }

    /**
     * Sets the minimum document frequency below which the terms will be ignored
     * from the input document. Defaults to `5`.
     *
     * @param {number} docFreqLimit The minimum document frequency
     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained
     */
    minDocFreq(docFreqLimit) {
        this._queryOpts.min_doc_freq = docFreqLimit;
        return this;
    }

    /**
     * Sets the maximum document frequency above which the terms will be ignored
     * from the input document. Defaults to unbounded (`0`).
     *
     * @param {number} docFreqLimit The minimum document frequency
     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained
     */
    maxDocFreq(docFreqLimit) {
        this._queryOpts.max_doc_freq = docFreqLimit;
        return this;
    }

    /**
     * Sets the minimum word length below which the terms will be ignored.
     * Defaults to `0`.
     *
     * @param {number} wordLenLimit
     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained
     */
    minWordLength(wordLenLimit) {
        this._queryOpts.min_word_length = wordLenLimit;
        return this;
    }

    /**
     * Sets the maximum word length above which the terms will be ignored.
     * Defaults to unbounded (`0`).
     *
     * @param {number} wordLenLimit
     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained
     */
    maxWordLength(wordLenLimit) {
        this._queryOpts.max_word_length = wordLenLimit;
        return this;
    }

    /**
     * Sets the array of stop words. Any word in this set is considered
     * "uninteresting" and ignored.
     *
     * @param {Array<string>} words Array of stop words.
     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained
     */
    stopWords(words) {
        this._queryOpts.stop_words = words;
        return this;
    }

    /**
     * Set the analyzer to control which analyzer will perform the analysis process on the text.
     * Defaults to the analyzer associated with the first field in `fields`.
     *
     * @param {string} analyzer A valid text analyzer.
     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained.
     */
    analyzer(analyzer) {
        this._queryOpts.analyzer = analyzer;
        return this;
    }

    /**
     * Sets the value controlling how many `should` clauses in the boolean
     * query should match. It can be an absolute value (2), a percentage (30%)
     * or a combination of both. (Defaults to `"30%"`).
     *
     * @param {string|number} minimumShouldMatch An absolute value (`2`), a percentage (`30%`)
     * or a combination of both.
     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained.
     */
    minimumShouldMatch(minimumShouldMatch) {
        this._queryOpts.minimum_should_match = minimumShouldMatch;
        return this;
    }

    /**
     * Sets the boost factor to use when boosting terms.
     * Defaults to deactivated (`0`).
     *
     * @param {number} boost A positive value to boost terms.
     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained.
     */
    boostTerms(boost) {
        this._queryOpts.boost_terms = boost;
        return this;
    }

    /**
     * Specifies whether the input documents should also be included in the
     * search results returned. Defaults to `false`.
     *
     * @param {boolean} enable
     * @returns {MoreLikeThisQuery} returns `this` so that calls can be chained.
     */
    include(enable) {
        this._queryOpts.include = enable;
        return this;
    }
};

var moreLikeThisQuery$2 = MoreLikeThisQuery$1;

const isNil$A = lodash_isnil;

const {
    Query: Query$8,
    Script: Script$4,
    util: { checkType: checkType$p }
} = core;

/**
 * A query allowing to define scripts as queries.
 * They are typically used in a filter context.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-script-query.html)
 *
 * @example
 * const scriptQry = esb.scriptQuery(esb.script()
 *  .lang('painless')
 *  .inline("doc['num1'].value > 1"))
 *
 * // Use in filter context
 * const qry = esb.boolQuery().must(scriptQry);
 *
 * @param {Script=} script
 *
 * @extends Query
 */
let ScriptQuery$1 = class ScriptQuery extends Query$8 {
    // eslint-disable-next-line require-jsdoc
    constructor(script) {
        super('script');

        if (!isNil$A(script)) this.script(script);
    }

    /**
     * Sets the `script` for query.
     *
     * @param {Script} script
     * @returns {ScriptQuery} returns `this` so that calls can be chained.
     */
    script(script) {
        checkType$p(script, Script$4);

        this._queryOpts.script = script;
        return this;
    }
};

var scriptQuery$2 = ScriptQuery$1;

const isNil$z = lodash_isnil;

const {
    util: { checkType: checkType$o },
    Query: Query$7
} = core;

/**
 * The `percolate` query can be used to match queries stored in an index.
 * The `percolate` query itself contains the document that will be used
 * as query to match with the stored queries.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-percolate-query.html)
 *
 * @example
 * const percolateQry = esb.percolateQuery('query', 'doctype')
 *     .document({ message: 'A new bonsai tree in the office' });
 *
 * const percolateQry = esb.percolateQuery()
 *     .field('query')
 *     .documentType('doctype')
 *     .index('my-index')
 *     .type('message')
 *     .id('1')
 *     .version(1);
 *
 * @param {string=} field The field of type `percolator` and that holds the indexed queries.
 * @param {string=} docType The type / mapping of the document being percolated.
 *
 * @extends Query
 */
let PercolateQuery$1 = class PercolateQuery extends Query$7 {
    // eslint-disable-next-line require-jsdoc
    constructor(field, docType) {
        super('percolate');
        this._queryOpts.documents = [];

        if (!isNil$z(field)) this._queryOpts.field = field;
        // Delegate this to method:
        if (!isNil$z(docType)) this._queryOpts.document_type = docType;
    }

    /**
     * Sets the field of type `percolator` and that holds the indexed queries.
     *
     * @param {string} field The field of type `percolator` and that holds the indexed queries.
     * @returns {PercolateQuery} returns `this` so that calls can be chained.
     */
    field(field) {
        this._queryOpts.field = field;
        return this;
    }

    /**
     * Sets the type / mapping of the document being percolated.
     *
     * Note: This param has been deprecated in elasticsearch 6.0. From 6.0 and
     * later, it is no longer required to specify the `document_type` parameter.
     *
     * @param {string} docType The type / mapping of the document being percolated.
     * @returns {PercolateQuery} returns `this` so that calls can be chained.
     */
    documentType(docType) {
        this._queryOpts.document_type = docType;
        return this;
    }

    /**
     * Appends given source document to the list of source documents being percolated.
     * Instead of specifying the source document being percolated,
     * the source can also be retrieved from an already stored document.
     *
     * @example
     *const qry = esb.percolateQuery('query', 'people')
     * .document({ name: 'Will Smith' });
     *
     * @param {Object} doc The source document being percolated.
     * @returns {PercolateQuery} returns `this` so that calls can be chained.
     */
    document(doc) {
        this._queryOpts.documents.push(doc);
        return this;
    }

    /**
     * Appends given source documents to the list of source documents being percolated.
     * Instead of specifying the source documents being percolated,
     * the source can also be retrieved from already stored documents.
     *
     * @example
     *const qry = esb.percolateQuery('query', 'people')
     * .documents([{ name: 'Will Smith' }, { name: 'Willow Smith' }]);
     *
     * @param {Object[]} docs The source documents being percolated.
     * @returns {PercolateQuery} returns `this` so that calls can be chained.
     */
    documents(docs) {
        checkType$o(docs, Array);

        this._queryOpts.documents = this._queryOpts.documents.concat(docs);
        return this;
    }

    /**
     * Sets the index the document resides in. This is a required parameter if `document`
     * is not specified.
     *
     * @param {string} index The index the document resides in.
     * @returns {PercolateQuery} returns `this` so that calls can be chained.
     */
    index(index) {
        this._queryOpts.index = index;
        return this;
    }

    /**
     * Sets the type of the document to fetch. This is a required parameter if `document`
     * is not specified.
     *
     * @param {string} type The type of the document to fetch.
     * @returns {PercolateQuery} returns `this` so that calls can be chained.
     */
    type(type) {
        this._queryOpts.type = type;
        return this;
    }

    /**
     * Sets the id of the document to fetch. This is a required parameter if `document`
     * is not specified.
     *
     * @param {string} id The id of the document to fetch.
     * @returns {PercolateQuery} returns `this` so that calls can be chained.
     */
    id(id) {
        this._queryOpts.id = id;
        return this;
    }

    /**
     * Sets the routing to be used to fetch document to percolate. Optional.
     *
     * @param {string} routing The routing to be used to fetch document to percolate.
     * @returns {PercolateQuery} returns `this` so that calls can be chained.
     */
    routing(routing) {
        this._queryOpts.routing = routing;
        return this;
    }

    /**
     * Sets the preference to be used to fetch document to percolate. Optional.
     *
     * @param {string} preference The preference to be used to fetch document to percolate.
     * @returns {PercolateQuery} returns `this` so that calls can be chained.
     */
    preference(preference) {
        this._queryOpts.preference = preference;
        return this;
    }

    /**
     * Sets the expected version of the document to be fetched. Optional.
     * If the version does not match, the search request will fail
     * with a version conflict error.
     *
     * @param {string} version The expected version of the document to be fetched.
     * @returns {PercolateQuery} returns `this` so that calls can be chained.
     */
    version(version) {
        this._queryOpts.version = version;
        return this;
    }
};

var percolateQuery$2 = PercolateQuery$1;

const isNil$y = lodash_isnil;
const { Query: Query$6 } = core;

/**
 * The `distance_feature` query can be used to filter documents that are inside
 * a timeframe or radius given an **origin** point. For dates the difference can be
 * minutes, hours, etc and for coordinates it can be meters, kilometers..
 *
 *  [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-distance-feature-query.html)
 *
 * NOTE: Only available in Elasticsearch 7.1.0+.
 *
 * @example
 * const query = new DistanceFeatureQuery('time');
 *   query
 *       .origin('now')
 *       .pivot('1h')
 *       .toJSON();
 * @param {string} field The field inside the document to be used in the query
 * @extends Query
 */
let DistanceFeatureQuery$1 = class DistanceFeatureQuery extends Query$6 {
    /**
     * @param {string} field The field inside the document to be used in the query
     */
    constructor(field) {
        super('distance_feature');
        if (!isNil$y(field)) this._queryOpts.field = field;
    }

    /**
     * Sets the field for the `distance_feature` query
     * @param {string} fieldName Name of the field inside the document
     * @returns {DistanceFeatureQuery} Instance of the distance feature query
     */
    field(fieldName) {
        this._queryOpts.field = fieldName;
        return this;
    }

    /**
     * Sets the origin of the function. Date or point of coordinates
     * used to calculate distances
     * @param {GeoPoint | string} originPoint Array of coordinates, LatLng object, "now-1h"
     * @returns {DistanceFeatureQuery} Instance of the distance feature query
     */
    origin(originPoint) {
        this._queryOpts.origin = originPoint;
        return this;
    }

    /**
     * Distance from the origin at which relevance scores receive half of the boost value.
     * @param {string} pivotDistance Distance value. If the field value is date then this must be a
     * [time unit](https://www.elastic.co/guide/en/elasticsearch/reference/current/api-conventions.html#time-units).
     * If it's a geo point field, then a [distance unit](https://www.elastic.co/guide/en/elasticsearch/reference/current/api-conventions.html#distance-units)
     * @returns {DistanceFeatureQuery} Instance of the distance feature query
     */
    pivot(pivotDistance) {
        this._queryOpts.pivot = pivotDistance;
        return this;
    }
};

var distanceFeatureQuery$2 = DistanceFeatureQuery$1;

specializedQueries.MoreLikeThisQuery = moreLikeThisQuery$2;
specializedQueries.ScriptQuery = scriptQuery$2;
specializedQueries.PercolateQuery = percolateQuery$2;
specializedQueries.DistanceFeatureQuery = distanceFeatureQuery$2;

var spanQueries = {};

const { Query: Query$5 } = core;

/**
 * Interface-like class used to group and identify various implementations of Span queries.
 *
 * **NOTE:** Instantiating this directly should not be required.
 * However, if you wish to add a custom implementation for whatever reason,
 * this class could be extended.
 *
 * @extends Query
 */
let SpanQueryBase$8 = class SpanQueryBase extends Query$5 {};

var spanQueryBase = SpanQueryBase$8;

const {
    util: { checkType: checkType$n }
} = core;

const SpanQueryBase$7 = spanQueryBase;

/**
 * Base class for span queries with `little`, `big` clauses.
 *
 * **NOTE:** Instantiating this directly should not be required.
 * However, if you wish to add a custom implementation for whatever reason,
 * this class could be extended.
 *
 * @extends SpanQueryBase
 */
let SpanLittleBigQueryBase$2 = class SpanLittleBigQueryBase extends SpanQueryBase$7 {
    /**
     * Sets the `little` clause.
     *
     * @param {SpanQueryBase} spanQry Any span type query
     * @returns {SpanLittleBigQueryBase} returns `this` so that calls can be chained.
     */
    little(spanQry) {
        checkType$n(spanQry, SpanQueryBase$7);

        this._queryOpts.little = spanQry;
        return this;
    }

    /**
     * Sets the `big` clause.
     *
     * @param {SpanQueryBase} spanQry Any span type query
     * @returns {SpanLittleBigQueryBase} returns `this` so that calls can be chained.
     */
    big(spanQry) {
        checkType$n(spanQry, SpanQueryBase$7);

        this._queryOpts.big = spanQry;
        return this;
    }
};

var spanLittleBigQueryBase = SpanLittleBigQueryBase$2;

const has$2 = lodash_has;
const isNil$x = lodash_isnil;

const SpanQueryBase$6 = spanQueryBase;

/**
 * Matches spans containing a term. The span term query maps to Lucene `SpanTermQuery`.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-span-term-query.html)
 *
 * @example
 * const qry = esb.spanTermQuery('user', 'kimchy');
 *
 * @example
 * const qry = esb.spanTermQuery()
 *     .field('user')
 *     .value('kimchy')
 *     .boost(2.0);
 *
 * @param {string=} field The document field to query against
 * @param {string|number=} value The query string
 *
 * @extends SpanQueryBase
 */
let SpanTermQuery$1 = class SpanTermQuery extends SpanQueryBase$6 {
    // This is extremely similar to ValueTermQueryBase
    // Maybe rename, move and reuse it?

    // eslint-disable-next-line require-jsdoc
    constructor(field, value) {
        super('span_term');

        if (!isNil$x(field)) this._field = field;
        if (!isNil$x(value)) this._queryOpts.value = value;
    }

    /**
     * Sets the field to search on.
     *
     * @param {string} field
     * @returns {SpanTermQuery} returns `this` so that calls can be chained.
     */
    field(field) {
        this._field = field;
        return this;
    }

    /**
     * Sets the query string.
     *
     * @param {string|number} queryVal
     * @returns {SpanTermQuery} returns `this` so that calls can be chained.
     */
    value(queryVal) {
        this._queryOpts.value = queryVal;
        return this;
    }

    /**
     * Override default `toJSON` to return DSL representation of the Span term query
     * class instance.
     *
     * @override
     * @returns {Object} returns an Object which maps to the elasticsearch query DSL
     */
    toJSON() {
        // recursiveToJSON doesn't seem to be required here.

        // Revisit this.. Smells a little bit
        if (!has$2(this._queryOpts, 'value')) {
            throw new Error('Value is required for Span term query!');
        }

        const qryOpts =
            Object.keys(this._queryOpts).length === 1
                ? this._queryOpts.value
                : this._queryOpts;
        return {
            [this.queryType]: {
                [this._field]: qryOpts
            }
        };
    }
};

var spanTermQuery$2 = SpanTermQuery$1;

const isNil$w = lodash_isnil;

const {
    util: { checkType: checkType$m }
} = core;

const { MultiTermQueryBase } = termLevelQueries;

const SpanQueryBase$5 = spanQueryBase;

/**
 * The `span_multi` query allows you to wrap a `multi term query` (one of wildcard,
 * fuzzy, prefix, range or regexp query) as a `span query`, so it can be nested.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-span-multi-term-query.html)
 *
 * @example
 * const spanQry = esb.spanMultiTermQuery()
 *     .match(esb.prefixQuery('user', 'ki').boost(1.08));
 *
 * @param {MultiTermQueryBase=} multiTermQry One of wildcard, fuzzy, prefix, range or regexp query
 *
 * @extends SpanQueryBase
 */
let SpanMultiTermQuery$1 = class SpanMultiTermQuery extends SpanQueryBase$5 {
    // eslint-disable-next-line require-jsdoc
    constructor(multiTermQry) {
        super('span_multi');

        if (!isNil$w(multiTermQry)) this.match(multiTermQry);
    }

    /**
     * Sets the multi term query.
     *
     * @param {MultiTermQueryBase} multiTermQry One of wildcard, fuzzy, prefix, range or regexp query
     * @returns {SpanMultiTermQuery} returns `this` so that calls can be chained.
     */
    match(multiTermQry) {
        checkType$m(multiTermQry, MultiTermQueryBase);

        this._queryOpts.match = multiTermQry;
        return this;
    }
};

var spanMultiTermQuery$2 = SpanMultiTermQuery$1;

const isNil$v = lodash_isnil;

const {
    util: { checkType: checkType$l }
} = core;

const SpanQueryBase$4 = spanQueryBase;

/**
 * Matches spans near the beginning of a field. The span first query maps to Lucene `SpanFirstQuery`.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-span-first-query.html)
 *
 * @example
 * const spanQry = esb.spanFirstQuery()
 *     .match(esb.spanTermQuery('user', 'kimchy'))
 *     .end(3);
 *
 * @param {SpanQueryBase=} spanQry Any other span type query
 *
 * @extends SpanQueryBase
 */
let SpanFirstQuery$1 = class SpanFirstQuery extends SpanQueryBase$4 {
    // eslint-disable-next-line require-jsdoc
    constructor(spanQry) {
        super('span_first');

        if (!isNil$v(spanQry)) this.match(spanQry);
    }

    /**
     * Sets the `match` clause which can be any other span type query.
     *
     * @param {SpanQueryBase} spanQry
     * @returns {SpanFirstQuery} returns `this` so that calls can be chained.
     */
    match(spanQry) {
        checkType$l(spanQry, SpanQueryBase$4);

        this._queryOpts.match = spanQry;
        return this;
    }

    /**
     * Sets the maximum end position permitted in a match.
     *
     * @param {number} limit The maximum end position permitted in a match.
     * @returns {SpanFirstQuery} returns `this` so that calls can be chained.
     */
    end(limit) {
        this._queryOpts.end = limit;
        return this;
    }
};

var spanFirstQuery$2 = SpanFirstQuery$1;

const {
    util: { checkType: checkType$k }
} = core;

const SpanQueryBase$3 = spanQueryBase;

/**
 * Matches spans which are near one another. One can specify `slop`, the maximum
 * number of intervening unmatched positions, as well as whether matches are
 * required to be in-order. The span near query maps to Lucene `SpanNearQuery`.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-span-near-query.html)
 *
 * @example
 * const spanQry = esb.spanNearQuery()
 *     .clauses([
 *         esb.spanTermQuery('field', 'value1'),
 *         esb.spanTermQuery('field', 'value2'),
 *         esb.spanTermQuery('field', 'value3')
 *     ])
 *     .slop(12)
 *     .inOrder(false);
 *
 * @extends SpanQueryBase
 */
let SpanNearQuery$1 = class SpanNearQuery extends SpanQueryBase$3 {
    // eslint-disable-next-line require-jsdoc
    constructor() {
        super('span_near');
    }

    /**
     * Sets the clauses element which is a list of one or more other span type queries.
     *
     * @param {Array<SpanQueryBase>} clauses
     * @returns {SpanNearQuery} returns `this` so that calls can be chained.
     * @throws {TypeError} If parameter `clauses` is not an instance of Array or if
     * any member of the array is not an instance of `SpanQueryBase`.
     */
    clauses(clauses) {
        checkType$k(clauses, Array);
        clauses.forEach(clause => checkType$k(clause, SpanQueryBase$3));

        this._queryOpts.clauses = clauses;
        return this;
    }

    /**
     * Configures the `slop`(default is 0), the maximum number of intervening
     * unmatched positions permitted.
     *
     * @param {number} slop A positive integer value, defaults is 0.
     * @returns {SpanNearQuery} returns `this` so that calls can be chained.
     */
    slop(slop) {
        this._queryOpts.slop = slop;
        return this;
    }

    // TODO: Add documentation for inOrder

    /**
     *
     * @param {boolean} enable
     * @returns {SpanNearQuery} returns `this` so that calls can be chained.
     */
    inOrder(enable) {
        this._queryOpts.in_order = enable;
        return this;
    }
};

var spanNearQuery$2 = SpanNearQuery$1;

const {
    util: { checkType: checkType$j }
} = core;

const SpanQueryBase$2 = spanQueryBase;

/**
 * Matches the union of its span clauses. The span or query maps to Lucene `SpanOrQuery`.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-span-or-query.html)
 *
 * @example
 * const spanQry = esb.spanOrQuery()
 *     .clauses([
 *         esb.spanTermQuery('field', 'value1'),
 *         esb.spanTermQuery('field', 'value2'),
 *         esb.spanTermQuery('field', 'value3')
 *     ]);
 *
 * @extends SpanQueryBase
 */
let SpanOrQuery$1 = class SpanOrQuery extends SpanQueryBase$2 {
    // eslint-disable-next-line require-jsdoc
    constructor() {
        super('span_or');
    }

    /**
     * Sets the clauses element which is a list of one or more other span type queries.
     *
     * @param {Array<SpanQueryBase>} clauses
     * @returns {SpanOrQuery} returns `this` so that calls can be chained.
     * @throws {TypeError} If parameter `clauses` is not an instance of Array or if
     * any member of the array is not an instance of `SpanQueryBase`.
     */
    clauses(clauses) {
        checkType$j(clauses, Array);
        clauses.forEach(clause => checkType$j(clause, SpanQueryBase$2));

        this._queryOpts.clauses = clauses;
        return this;
    }
};

var spanOrQuery$2 = SpanOrQuery$1;

const {
    util: { checkType: checkType$i }
} = core;

const SpanQueryBase$1 = spanQueryBase;

/**
 * Removes matches which overlap with another span query. The span not query
 * maps to Lucene `SpanNotQuery`.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-span-not-query.html)
 *
 * @example
 * const spanQry = esb.spanNotQuery()
 *     .include(esb.spanTermQuery('field1', 'hoya'))
 *     .exclude(esb.spanNearQuery()
 *         .clauses([
 *             esb.spanTermQuery('field1', 'la'),
 *             esb.spanTermQuery('field1', 'hoya')
 *         ])
 *         .slop(0)
 *         .inOrder(true));
 *
 * @extends SpanQueryBase
 */
let SpanNotQuery$1 = class SpanNotQuery extends SpanQueryBase$1 {
    // eslint-disable-next-line require-jsdoc
    constructor() {
        super('span_not');
    }

    /**
     * Sets the `include` clause which is the span query whose matches are filtered
     *
     * @param {SpanQueryBase} spanQry
     * @returns {SpanNotQuery} returns `this` so that calls can be chained.
     */
    include(spanQry) {
        checkType$i(spanQry, SpanQueryBase$1);

        this._queryOpts.include = spanQry;
        return this;
    }

    /**
     * Sets the `exclude` clause which is the span query whose matches must
     * not overlap those returned.
     *
     * @param {SpanQueryBase} spanQry
     * @returns {SpanNotQuery} returns `this` so that calls can be chained.
     */
    exclude(spanQry) {
        checkType$i(spanQry, SpanQueryBase$1);

        this._queryOpts.exclude = spanQry;
        return this;
    }

    /**
     * If set the amount of tokens before the include span can't have overlap with
     * the exclude span.
     *
     * @param {number} pre
     * @returns {SpanNotQuery} returns `this` so that calls can be chained.
     */
    pre(pre) {
        this._queryOpts.pre = pre;
        return this;
    }

    /**
     * If set the amount of tokens after the include span can't have overlap with the exclude span.
     *
     * @param {number} post
     * @returns {SpanNotQuery} returns `this` so that calls can be chained.
     */
    post(post) {
        this._queryOpts.post = post;
        return this;
    }

    /**
     * If set the amount of tokens from within the include span can't have overlap
     * with the exclude span. Equivalent of setting both `pre` and `post`.
     *
     * @param {number} dist
     * @returns {SpanNotQuery} returns `this` so that calls can be chained.
     */
    dist(dist) {
        this._queryOpts.dist = dist;
        return this;
    }
};

var spanNotQuery$2 = SpanNotQuery$1;

const SpanLittleBigQueryBase$1 = spanLittleBigQueryBase;

/**
 * Returns matches which enclose another span query. The span containing query
 * maps to Lucene `SpanContainingQuery`.
 *
 * Matching spans from big that contain matches from little are returned.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-span-containing-query.html)
 *
 * @example
 * const spanQry = esb.spanContainingQuery()
 *     .little(esb.spanTermQuery('field1', 'foo'))
 *     .big(esb.spanNearQuery()
 *         .clauses([
 *             esb.spanTermQuery('field1', 'bar'),
 *             esb.spanTermQuery('field1', 'baz')
 *         ])
 *         .slop(5)
 *         .inOrder(true))
 *
 * @extends SpanLittleBigQueryBase
 */
let SpanContainingQuery$1 = class SpanContainingQuery extends SpanLittleBigQueryBase$1 {
    // eslint-disable-next-line require-jsdoc
    constructor() {
        super('span_containing');
    }
};

var spanContainingQuery$2 = SpanContainingQuery$1;

const SpanLittleBigQueryBase = spanLittleBigQueryBase;

/**
 * Returns matches which are enclosed inside another span query. The span within
 * query maps to Lucene `SpanWithinQuery`.
 *
 * Matching spans from `little` that are enclosed within `big` are returned.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-span-containing-query.html)
 *
 * @example
 * const spanQry = esb.spanWithinQuery()
 *     .little(esb.spanTermQuery('field1', 'foo'))
 *     .big(esb.spanNearQuery()
 *         .clauses([
 *             esb.spanTermQuery('field1', 'bar'),
 *             esb.spanTermQuery('field1', 'baz')
 *         ])
 *         .slop(5)
 *         .inOrder(true));
 *
 * @extends SpanLittleBigQueryBase
 */
let SpanWithinQuery$1 = class SpanWithinQuery extends SpanLittleBigQueryBase {
    // eslint-disable-next-line require-jsdoc
    constructor() {
        super('span_within');
    }
};

var spanWithinQuery$2 = SpanWithinQuery$1;

const isNil$u = lodash_isnil;

const {
    util: { checkType: checkType$h }
} = core;

const SpanQueryBase = spanQueryBase;

/**
 * Wrapper to allow span queries to participate in composite single-field
 * span queries by lying about their search field. The span field masking
 * query maps to Lucene's `SpanFieldMaskingQuery`.
 *
 * This can be used to support queries like span-near or span-or across
 * different fields, which is not ordinarily permitted.
 *
 * Span field masking query is invaluable in conjunction with multi-fields
 * when same content is indexed with multiple analyzers. For instance we
 * could index a field with the standard analyzer which breaks text up into
 * words, and again with the english analyzer which stems words into their root form.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-span-field-masking-query.html)
 *
 * @param {string=} field
 * @param {SpanQueryBase=} spanQry Any other span type query
 *
 * @example
 * const spanQry = esb.spanNearQuery()
 *     .clauses([
 *         esb.spanTermQuery('text', 'quick brown'),
 *         esb.spanFieldMaskingQuery()
 *             .field('text')
 *             .query(esb.spanTermQuery('text.stems', 'fox'))
 *     ])
 *     .slop(5)
 *     .inOrder(false);
 *
 * @extends SpanQueryBase
 */
let SpanFieldMaskingQuery$1 = class SpanFieldMaskingQuery extends SpanQueryBase {
    // eslint-disable-next-line require-jsdoc
    constructor(field, spanQry) {
        super('field_masking_span');

        if (!isNil$u(field)) this._queryOpts.field = field;
        if (!isNil$u(spanQry)) this.query(spanQry);
    }

    /**
     * Sets the span query.
     *
     * @param {SpanQueryBase} spanQry
     * @returns {SpanFieldMaskingQuery} returns `this` so that calls can be chained.
     */
    query(spanQry) {
        checkType$h(spanQry, SpanQueryBase);

        this._queryOpts.query = spanQry;
        return this;
    }

    /**
     * Sets the field to mask.
     *
     * @param {string} field
     * @returns {SpanFieldMaskingQuery} returns `this` so that calls can be chained.
     */
    field(field) {
        this._queryOpts.field = field;
        return this;
    }
};

var spanFieldMaskingQuery$2 = SpanFieldMaskingQuery$1;

spanQueries.SpanLittleBigQueryBase = spanLittleBigQueryBase;

spanQueries.SpanTermQuery = spanTermQuery$2;
spanQueries.SpanMultiTermQuery = spanMultiTermQuery$2;
spanQueries.SpanFirstQuery = spanFirstQuery$2;
spanQueries.SpanNearQuery = spanNearQuery$2;
spanQueries.SpanOrQuery = spanOrQuery$2;
spanQueries.SpanNotQuery = spanNotQuery$2;
spanQueries.SpanContainingQuery = spanContainingQuery$2;
spanQueries.SpanWithinQuery = spanWithinQuery$2;
spanQueries.SpanFieldMaskingQuery = spanFieldMaskingQuery$2;

queries.MatchAllQuery = matchAllQuery$2;
queries.MatchNoneQuery = matchNoneQuery$2;

queries.fullTextQueries = fullTextQueries;

queries.termLevelQueries = termLevelQueries;

queries.compoundQueries = compoundQueries;

queries.joiningQueries = joiningQueries;

queries.geoQueries = geoQueries;

queries.specializedQueries = specializedQueries;

queries.spanQueries = spanQueries;

var aggregations = {};

var metricsAggregations = {};

const isNil$t = lodash_isnil;

const {
    Aggregation: Aggregation$4,
    Script: Script$3,
    util: { checkType: checkType$g }
} = core;

/**
 * The `MetricsAggregationBase` provides support for common options used across
 * various metrics `Aggregation` implementations.
 *
 * **NOTE:** Instantiating this directly should not be required.
 * However, if you wish to add a custom implementation for whatever reason,
 * this class could be extended.
 *
 * @param {string} name a valid aggregation name
 * @param {string} aggType type of aggregation
 * @param {string=} field The field to aggregate on
 *
 * @extends Aggregation
 */
let MetricsAggregationBase$e = class MetricsAggregationBase extends Aggregation$4 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, aggType, field) {
        super(name, aggType);

        if (!isNil$t(field)) this._aggsDef.field = field;
    }

    // TODO: Investigate whether Metrics Aggregations can have sub aggregations
    // Hide setters for `aggs` and `aggregations` if required

    // TODO: Investigate case when getters will be required

    /**
     * Sets field to run aggregation on.
     *
     * @param {string} field a valid field name
     * @returns {MetricsAggregationBase} returns `this` so that calls can be chained
     */
    field(field) {
        this._aggsDef.field = field;
        return this;
    }

    /**
     * Sets script parameter for aggregation.
     *
     * @example
     * // Compute the average grade based on a script
     * const agg = esb.avgAggregation('avg_grade').script(
     *     esb.script('inline', "doc['grade'].value").lang('painless')
     * );
     *
     * @example
     * // Value script, apply grade correction
     * const agg = esb.avgAggregation('avg_grade', 'grade').script(
     *     esb.script('inline', '_value * params.correction')
     *         .lang('painless')
     *         .params({ correction: 1.2 })
     * );
     *
     * @param {Script} script
     * @returns {MetricsAggregationBase} returns `this` so that calls can be chained
     * @throws {TypeError} If `script` is not an instance of `Script`
     */
    script(script) {
        checkType$g(script, Script$3);

        this._aggsDef.script = script;
        return this;
    }

    /**
     * Sets the missing parameter ehich defines how documents
     * that are missing a value should be treated.
     *
     * @example
     * const agg = esb.avgAggregation('avg_grade', 'grade').missing(10);
     *
     * @param {string} value
     * @returns {MetricsAggregationBase} returns `this` so that calls can be chained
     */
    missing(value) {
        this._aggsDef.missing = value;
        return this;
    }

    /**
     * Sets the format expression if applicable.
     *
     * @param {string} fmt Format mask to apply on aggregation response. Example: ####.00
     * @returns {MetricsAggregationBase} returns `this` so that calls can be chained
     */
    format(fmt) {
        this._aggsDef.format = fmt;
        return this;
    }
};

var metricsAggregationBase = MetricsAggregationBase$e;

const MetricsAggregationBase$d = metricsAggregationBase;

/**
 * A single-value metrics aggregation that computes the average of numeric
 * values that are extracted from the aggregated documents. These values can be
 * extracted either from specific numeric fields in the documents, or be
 * generated by a provided script.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-avg-aggregation.html)
 *
 * Aggregation that computes the average of numeric values that are extracted
 * from the aggregated documents.
 *
 * @example
 * // Compute the average grade over all documents
 * const agg = esb.avgAggregation('avg_grade', 'grade');
 *
 * @example
 * // Compute the average grade based on a script
 * const agg = esb.avgAggregation('avg_grade').script(
 *     esb.script('inline', "doc['grade'].value").lang('painless')
 * );
 *
 * @example
 * // Value script, apply grade correction
 * const agg = esb.avgAggregation('avg_grade', 'grade').script(
 *     esb.script('inline', '_value * params.correction')
 *         .lang('painless')
 *         .params({ correction: 1.2 })
 * );
 *
 * @example
 * // Missing value
 * const agg = esb.avgAggregation('avg_grade', 'grade').missing(10);
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} field The field to aggregate on
 *
 * @extends MetricsAggregationBase
 */
let AvgAggregation$1 = class AvgAggregation extends MetricsAggregationBase$d {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field) {
        super(name, 'avg', field);
    }
};

var avgAggregation$2 = AvgAggregation$1;

const MetricsAggregationBase$c = metricsAggregationBase;

const ES_REF_URL$I =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-cardinality-aggregation.html';

/**
 * A single-value metrics aggregation that calculates an approximate count of
 * distinct values. Values can be extracted either from specific fields in the
 * document or generated by a script.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-cardinality-aggregation.html)
 *
 * Aggregation that calculates an approximate count of distinct values.
 *
 * @example
 * const agg = esb.cardinalityAggregation('author_count', 'author');
 *
 * @example
 * const agg = esb.cardinalityAggregation('author_count').script(
 *     esb.script(
 *         'inline',
 *         "doc['author.first_name'].value + ' ' + doc['author.last_name'].value"
 *     ).lang('painless')
 * );
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} field The field to aggregate on
 *
 * @extends MetricsAggregationBase
 */
let CardinalityAggregation$1 = class CardinalityAggregation extends MetricsAggregationBase$c {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field) {
        super(name, 'cardinality', field);
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on CardinalityAggregation
     */
    format() {
        // Not 100% sure about this.
        console.log(`Please refer ${ES_REF_URL$I}`);
        throw new Error('format is not supported in CardinalityAggregation');
    }

    /**
     * The `precision_threshold` options allows to trade memory for accuracy,
     * and defines a unique count below which counts are expected to be close to accurate.
     *
     * @example
     * const agg = esb.cardinalityAggregation(
     *     'author_count',
     *     'author_hash'
     * ).precisionThreshold(100);
     *
     * @param {number} threshold The threshold value.
     * The maximum supported value is 40000, thresholds above this number
     * will have the same effect as a threshold of 40000. The default values is 3000.
     * @returns {CardinalityAggregation} returns `this` so that calls can be chained
     */
    precisionThreshold(threshold) {
        // TODO: Use validation and warning here
        this._aggsDef.precision_threshold = threshold;
        return this;
    }
};

var cardinalityAggregation$2 = CardinalityAggregation$1;

const MetricsAggregationBase$b = metricsAggregationBase;

/**
 * A multi-value metrics aggregation that computes stats over numeric values
 * extracted from the aggregated documents. These values can be extracted either
 * from specific numeric fields in the documents, or be generated by a provided
 * script.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-extendedstats-aggregation.html)
 *
 * Aggregation that computes extra stats over numeric values extracted from
 * the aggregated documents.
 *
 * @example
 * const agg = esb.extendedStatsAggregation('grades_stats', 'grade');
 *
 * @example
 * // Compute the grade stats based on a script
 * const agg = esb.extendedStatsAggregation('grades_stats').script(
 *     esb.script('inline', "doc['grade'].value").lang('painless')
 * );
 *
 * @example
 * // Value script, apply grade correction
 * const agg = esb.extendedStatsAggregation('grades_stats', 'grade').script(
 *     esb.script('inline', '_value * params.correction')
 *         .lang('painless')
 *         .params({ correction: 1.2 })
 * );
 *
 * @example
 * // Missing value
 * const agg = esb.extendedStatsAggregation('grades_stats', 'grade').missing(0);
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} field The field to aggregate on
 *
 * @extends MetricsAggregationBase
 */
let ExtendedStatsAggregation$1 = class ExtendedStatsAggregation extends MetricsAggregationBase$b {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field) {
        super(name, 'extended_stats', field);
    }

    /**
     * Set sigma in the request for getting custom boundary.
     * sigma controls how many standard deviations +/- from the mean should be displayed
     *
     * @example
     * const agg = esb.extendedStatsAggregation('grades_stats', 'grade').sigma(3);
     *
     * @param {number} sigma sigma can be any non-negative double,
     * meaning you can request non-integer values such as 1.5.
     * A value of 0 is valid, but will simply return the average for both upper and lower bounds.
     * @returns {ExtendedStatsAggregation} returns `this` so that calls can be chained
     */
    sigma(sigma) {
        this._aggsDef.sigma = sigma;
        return this;
    }
};

var extendedStatsAggregation$2 = ExtendedStatsAggregation$1;

const MetricsAggregationBase$a = metricsAggregationBase;

const ES_REF_URL$H =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-geobounds-aggregation.html';

/**
 * A metric aggregation that computes the bounding box
 * containing all geo_point values for a field.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-geobounds-aggregation.html)
 *
 * @example
 * const agg = esb.geoBoundsAggregation('viewport', 'location').wrapLongitude(true);
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} field The field to aggregate on
 *
 * @extends MetricsAggregationBase
 */
let GeoBoundsAggregation$1 = class GeoBoundsAggregation extends MetricsAggregationBase$a {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field) {
        super(name, 'geo_bounds', field);
    }

    // TODO: Override missing and take only GeoPoint as parameter

    /**
     * @override
     * @throws {Error} This method cannot be called on GeoBoundsAggregation
     */
    format() {
        console.log(`Please refer ${ES_REF_URL$H}`);
        throw new Error('format is not supported in GeoBoundsAggregation');
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on GeoBoundsAggregation
     */
    script() {
        console.log(`Please refer ${ES_REF_URL$H}`);
        throw new Error('script is not supported in GeoBoundsAggregation');
    }

    /**
     *
     * @param {boolean} allowOverlap Optional parameter which specifies whether
     * the bounding box should be allowed to overlap the international date line.
     * The default value is true
     * @returns {GeoBoundsAggregation} returns `this` so that calls can be chained
     */
    wrapLongitude(allowOverlap) {
        this._aggsDef.wrap_longitude = allowOverlap;
        return this;
    }
};

var geoBoundsAggregation$2 = GeoBoundsAggregation$1;

const MetricsAggregationBase$9 = metricsAggregationBase;

const ES_REF_URL$G =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-geocentroid-aggregation.html';

/**
 * A metric aggregation that computes the weighted centroid
 * from all coordinate values for a Geo-point datatype field.
 *
 * [Elasticsearchreference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-geocentroid-aggregation.html)
 *
 * @example
 * const agg = esb.geoCentroidAggregation('centroid', 'location');
 *
 * @example
 * // Combined as a sub-aggregation to other bucket aggregations
 * const reqBody = esb.requestBodySearch()
 *     .query(esb.matchQuery('crime', 'burglary'))
 *     .agg(
 *         esb.termsAggregation('towns', 'town').agg(
 *             esb.geoCentroidAggregation('centroid', 'location')
 *         )
 *     );
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} field The field to aggregate on. field must be a Geo-point datatype type
 *
 * @extends MetricsAggregationBase
 */
let GeoCentroidAggregation$1 = class GeoCentroidAggregation extends MetricsAggregationBase$9 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field) {
        super(name, 'geo_centroid', field);
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on GeoCentroidAggregation
     */
    format() {
        console.log(`Please refer ${ES_REF_URL$G}`);
        throw new Error('format is not supported in GeoCentroidAggregation');
    }
};

var geoCentroidAggregation$2 = GeoCentroidAggregation$1;

const MetricsAggregationBase$8 = metricsAggregationBase;

/**
 * A single-value metrics aggregation that keeps track and returns the
 * maximum value among the numeric values extracted from the aggregated
 * documents. These values can be extracted either from specific numeric fields
 * in the documents, or be generated by a provided script.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-max-aggregation.html)
 *
 * Aggregation that keeps track and returns the maximum value among the
 * numeric values extracted from the aggregated documents.
 *
 * @example
 * const agg = esb.maxAggregation('max_price', 'price');
 *
 * @example
 * // Use a file script
 * const agg = esb.maxAggregation('max_price').script(
 *     esb.script('file', 'my_script').params({ field: 'price' })
 * );
 *
 * @example
 * // Value script to apply the conversion rate to every value
 * // before it is aggregated
 * const agg = esb.maxAggregation('max_price').script(
 *     esb.script('inline', '_value * params.conversion_rate').params({
 *         conversion_rate: 1.2
 *     })
 * );
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} field The field to aggregate on
 *
 * @extends MetricsAggregationBase
 */
let MaxAggregation$1 = class MaxAggregation extends MetricsAggregationBase$8 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field) {
        super(name, 'max', field);
    }
};

var maxAggregation$2 = MaxAggregation$1;

const MetricsAggregationBase$7 = metricsAggregationBase;

/**
 * A single-value metrics aggregation that keeps track and returns the
 * minimum value among the numeric values extracted from the aggregated
 * documents. These values can be extracted either from specific numeric fields
 * in the documents, or be generated by a provided script.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-min-aggregation.html)
 *
 * Aggregation that keeps track and returns the minimum value among numeric
 * values extracted from the aggregated documents.
 *
 * @example
 * const agg = esb.minAggregation('min_price', 'price');
 *
 * @example
 * // Use a file script
 * const agg = esb.minAggregation('min_price').script(
 *     esb.script('file', 'my_script').params({ field: 'price' })
 * );
 *
 * @example
 * // Value script to apply the conversion rate to every value
 * // before it is aggregated
 * const agg = esb.minAggregation('min_price').script(
 *     esb.script('inline', '_value * params.conversion_rate').params({
 *         conversion_rate: 1.2
 *     })
 * );
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} field The field to aggregate on
 *
 * @extends MetricsAggregationBase
 */
let MinAggregation$1 = class MinAggregation extends MetricsAggregationBase$7 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field) {
        super(name, 'min', field);
    }
};

var minAggregation$2 = MinAggregation$1;

const {
    util: { checkType: checkType$f }
} = core;

const MetricsAggregationBase$6 = metricsAggregationBase;

/**
 * A multi-value metrics aggregation that calculates one or more percentiles
 * over numeric values extracted from the aggregated documents. These values can
 * be extracted either from specific numeric fields in the documents, or be
 * generated by a provided script.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-percentile-aggregation.html)
 *
 * Aggregation that calculates one or more percentiles over numeric values
 * extracted from the aggregated documents.
 *
 * @example
 * const agg = esb.percentilesAggregation('load_time_outlier', 'load_time');
 *
 * @example
 * // Convert load time from mills to seconds on-the-fly using script
 * const agg = esb.percentilesAggregation('load_time_outlier').script(
 *     esb.script('inline', "doc['load_time'].value / params.timeUnit")
 *         .lang('painless')
 *         .params({ timeUnit: 1000 })
 * );
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} field The field to aggregate on
 *
 * @extends MetricsAggregationBase
 */
let PercentilesAggregation$1 = class PercentilesAggregation extends MetricsAggregationBase$6 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field) {
        super(name, 'percentiles', field);
    }

    /**
     * Enable the response to be returned as a keyed object where the key is the
     * bucket interval.
     *
     * @example
     * // Return the ranges as an array rather than a hash
     * const agg = esb.percentilesAggregation('balance_outlier', 'balance').keyed(
     *     false
     * );
     *
     * @param {boolean} keyed To enable keyed response or not. True by default
     * @returns {PercentilesAggregation} returns `this` so that calls can be chained
     */
    keyed(keyed) {
        this._aggsDef.keyed = keyed;
        return this;
    }

    /**
     * Specifies the percents of interest.
     * Requested percentiles must be a value between 0-100 inclusive
     *
     * @example
     * // Specify particular percentiles to calculate
     * const agg = esb.percentilesAggregation(
     *     'load_time_outlier',
     *     'load_time'
     * ).percents([95, 99, 99.9]);
     *
     * @param {Array<number>} percents Parameter to specify particular percentiles to calculate
     * @returns {PercentilesAggregation} returns `this` so that calls can be chained
     * @throws {TypeError} If `percents` is not an instance of Array
     */
    percents(percents) {
        checkType$f(percents, Array);
        this._aggsDef.percents = percents;
        return this;
    }

    /**
     * Compression controls memory usage and approximation error. The compression
     * value limits the maximum number of nodes to 100 * compression. By
     * increasing the compression value, you can increase the accuracy of your
     * percentiles at the cost of more memory. Larger compression values also make
     * the algorithm slower since the underlying tree data structure grows in
     * size, resulting in more expensive operations. The default compression
     * value is 100.
     *
     * @example
     * const agg = esb.percentilesAggregation(
     *     'load_time_outlier',
     *     'load_time'
     * ).tdigest(200);
     *
     * @param {number} compression Parameter to balance memory utilization with estimation accuracy.
     * @returns {PercentilesAggregation} returns `this` so that calls can be chained
     */
    tdigest(compression) {
        this._aggsDef.tdigest = { compression };
        return this;
    }

    /**
     * Compression controls memory usage and approximation error. The compression
     * value limits the maximum number of nodes to 100 * compression. By
     * increasing the compression value, you can increase the accuracy of your
     * percentiles at the cost of more memory. Larger compression values also make
     * the algorithm slower since the underlying tree data structure grows in
     * size, resulting in more expensive operations. The default compression
     * value is 100.
     *
     * Alias for `tdigest`
     *
     * @example
     * const agg = esb.percentilesAggregation(
     *     'load_time_outlier',
     *     'load_time'
     * ).compression(200);
     *
     * @param {number} compression Parameter to balance memory utilization with estimation accuracy.
     * @returns {PercentilesAggregation} returns `this` so that calls can be chained
     */
    compression(compression) {
        this._aggsDef.tdigest = { compression };
        return this;
    }

    /**
     * HDR Histogram (High Dynamic Range Histogram) is an alternative implementation
     * that can be useful when calculating percentiles for latency measurements
     * as it can be faster than the t-digest implementation
     * with the trade-off of a larger memory footprint.
     *
     * The HDR Histogram can be used by specifying the method parameter in the request.
     *
     * @example
     * const agg = esb.percentilesAggregation('load_time_outlier', 'load_time')
     *     .percents([95, 99, 99.9])
     *     .hdr(3);
     *
     * @param {number} numberOfSigDigits The resolution of values
     * for the histogram in number of significant digits
     * @returns {PercentilesAggregation} returns `this` so that calls can be chained
     */
    hdr(numberOfSigDigits) {
        this._aggsDef.hdr = {
            number_of_significant_value_digits: numberOfSigDigits
        };
        return this;
    }
};

var percentilesAggregation$2 = PercentilesAggregation$1;

const isNil$s = lodash_isnil;

const {
    util: { checkType: checkType$e }
} = core;

const MetricsAggregationBase$5 = metricsAggregationBase;

const ES_REF_URL$F =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-percentile-rank-aggregation.html';

/**
 * A multi-value metrics aggregation that calculates one or more percentile ranks
 * over numeric values extracted from the aggregated documents. These values can
 * be extracted either from specific numeric fields in the documents, or be
 * generated by a provided script.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-percentile-rank-aggregation.html)
 *
 * Aggregation that calculates one or more percentiles ranks over numeric values
 * extracted from the aggregated documents.
 *
 * @example
 * const agg = esb.percentileRanksAggregation(
 *     'load_time_outlier',
 *     'load_time',
 *     [15, 30]
 * );
 *
 * @example
 * // Convert load time from mills to seconds on-the-fly using script
 * const agg = esb.percentileRanksAggregation('load_time_outlier')
 *     .values([3, 5])
 *     .script(
 *         esb.script('inline', "doc['load_time'].value / params.timeUnit")
 *             .lang('painless')
 *             .params({ timeUnit: 1000 })
 *     );
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} field The field to aggregate on. It must be a numeric field
 * @param {Array=} values Values to compute percentiles from.
 *
 * @throws {TypeError} If `values` is not an instance of Array
 *
 * @extends MetricsAggregationBase
 */
let PercentileRanksAggregation$1 = class PercentileRanksAggregation extends MetricsAggregationBase$5 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field, values) {
        super(name, 'percentile_ranks', field);

        if (!isNil$s(values)) this.values(values);
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on PercentileRanksAggregation
     */
    format() {
        // Not 100% sure about this.
        console.log(`Please refer ${ES_REF_URL$F}`);
        throw new Error(
            'format is not supported in PercentileRanksAggregation'
        );
    }

    /**
     * Enable the response to be returned as a keyed object where the key is the
     * bucket interval.
     *
     * @example
     * // Return the ranges as an array rather than a hash
     * const agg = esb.percentileRanksAggregation('balance_outlier', 'balance')
     *     .values([25000, 50000])
     *     .keyed(false);
     *
     * @param {boolean} keyed To enable keyed response or not.
     * @returns {PercentilesRanksAggregation} returns `this` so that calls can be chained
     */
    keyed(keyed) {
        this._aggsDef.keyed = keyed;
        return this;
    }

    /**
     * Specifies the values to compute percentiles from.
     *
     * @param {Array<number>} values Values to compute percentiles from.
     * @returns {PercentileRanksAggregation} returns `this` so that calls can be chained
     * @throws {TypeError} If `values` is not an instance of Array
     */
    values(values) {
        checkType$e(values, Array);
        this._aggsDef.values = values;
        return this;
    }

    /**
     * Compression controls memory usage and approximation error. The compression
     * value limits the maximum number of nodes to 100 * compression. By
     * increasing the compression value, you can increase the accuracy of your
     * percentiles at the cost of more memory. Larger compression values also make
     * the algorithm slower since the underlying tree data structure grows in
     * size, resulting in more expensive operations. The default compression
     * value is 100.
     *
     * @param {number} compression Parameter to balance memory utilization with estimation accuracy.
     * @returns {PercentileRanksAggregation} returns `this` so that calls can be chained
     */
    tdigest(compression) {
        this._aggsDef.tdigest = { compression };
        return this;
    }

    /**
     * Compression controls memory usage and approximation error. The compression
     * value limits the maximum number of nodes to 100 * compression. By
     * increasing the compression value, you can increase the accuracy of your
     * percentiles at the cost of more memory. Larger compression values also make
     * the algorithm slower since the underlying tree data structure grows in
     * size, resulting in more expensive operations. The default compression
     * value is 100.
     *
     * Alias for `tdigest`
     *
     * @param {number} compression Parameter to balance memory utilization with estimation accuracy.
     * @returns {PercentileRanksAggregation} returns `this` so that calls can be chained
     */
    compression(compression) {
        return this.tdigest(compression);
    }

    /**
     * HDR Histogram (High Dynamic Range Histogram) is an alternative implementation
     * that can be useful when calculating percentiles for latency measurements
     * as it can be faster than the t-digest implementation
     * with the trade-off of a larger memory footprint.
     *
     * The HDR Histogram can be used by specifying the method parameter in the request.
     *
     * @example
     * const agg = esb.percentileRanksAggregation(
     *     'load_time_outlier',
     *     'load_time',
     *     [15, 30]
     * ).hdr(3);
     *
     * @param {number} numberOfSigDigits The resolution of values
     * for the histogram in number of significant digits
     * @returns {PercentileRanksAggregation} returns `this` so that calls can be chained
     */
    hdr(numberOfSigDigits) {
        this._aggsDef.hdr = {
            number_of_significant_value_digits: numberOfSigDigits
        };
        return this;
    }
};

var percentileRanksAggregation$2 = PercentileRanksAggregation$1;

const MetricsAggregationBase$4 = metricsAggregationBase;

const ES_REF_URL$E =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-scripted-metric-aggregation.html';

/**
 * A metric aggregation that executes using scripts to provide a metric output.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-scripted-metric-aggregation.html)
 *
 * Aggregation that keeps track and returns the minimum value among numeric
 * values extracted from the aggregated documents.
 *
 * @example
 * const agg = esb.scriptedMetricAggregation('profit')
 *     .initScript('params._agg.transactions = []')
 *     .mapScript(
 *         "params._agg.transactions.add(doc.type.value == 'sale' ? doc.amount.value : -1 * doc.amount.value)"
 *     )
 *     .combineScript(
 *         'double profit = 0; for (t in params._agg.transactions) { profit += t } return profit'
 *     )
 *     .reduceScript(
 *         'double profit = 0; for (a in params._aggs) { profit += a } return profit'
 *     );
 *
 * @example
 * // Specify using file scripts
 * const agg = esb.scriptedMetricAggregation('profit')
 *     .initScript(esb.script('file', 'my_init_script'))
 *     .mapScript(esb.script('file', 'my_map_script'))
 *     .combineScript(esb.script('file', 'my_combine_script'))
 *     // script parameters for `init`, `map` and `combine` scripts must be
 *     // specified in a global params object so that
 *     // it can be shared between the scripts
 *     .params({ field: 'amount', _agg: {} })
 *     .reduceScript(esb.script('file', 'my_reduce_script'));
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 *
 * @extends MetricsAggregationBase
 */
let ScriptedMetricAggregation$1 = class ScriptedMetricAggregation extends MetricsAggregationBase$4 {
    // eslint-disable-next-line require-jsdoc
    constructor(name) {
        super(name, 'scripted_metric');
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on ScriptedMetricAggregation
     */
    field() {
        console.log(`Please refer ${ES_REF_URL$E}`);
        throw new Error('field is not supported in ScriptedMetricAggregation');
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on ScriptedMetricAggregation
     */
    script() {
        console.log(`Please refer ${ES_REF_URL$E}`);
        throw new Error('script is not supported in ScriptedMetricAggregation');
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on ScriptedMetricAggregation
     */
    missing() {
        console.log(`Please refer ${ES_REF_URL$E}`);
        throw new Error(
            'missing is not supported in ScriptedMetricAggregation'
        );
    }

    /**
     * Sets the initialization script.
     *
     * Executed prior to any collection of documents. Allows the aggregation to set up any initial state.
     *
     * @param {string|Script} initScript The initialization script. Can be a string or an Script instance
     * @returns {ScriptedMetricAggregation} returns `this` so that calls can be chained
     */
    initScript(initScript) {
        this._aggsDef.init_script = initScript;
        return this;
    }

    /**
     * Sets the map script. This is the only required script.
     *
     * Executed once per document collected.
     * If no combine_script is specified, the resulting state needs to be stored in an object named _agg.
     *
     * @param {string|Script} mapScript The map script. Can be a string or an Script instance
     * @returns {ScriptedMetricAggregation} returns `this` so that calls can be chained
     */
    mapScript(mapScript) {
        this._aggsDef.map_script = mapScript;
        return this;
    }

    /**
     * Sets the combine phase script.
     *
     * Executed once on each shard after document collection is complete.
     * Allows the aggregation to consolidate the state returned from each shard.
     * If a combine_script is not provided the combine phase will return the aggregation variable.
     *
     * @param {string|Script} combineScript The combine script. Can be a string or an Script instance
     * @returns {ScriptedMetricAggregation} returns `this` so that calls can be chained
     */
    combineScript(combineScript) {
        this._aggsDef.combine_script = combineScript;
        return this;
    }

    /**
     * Sets the reduce phase script.
     *
     * Executed once on the coordinating node after all shards have returned their results.
     * The script is provided with access to a variable _aggs
     * which is an array of the result of the combine_script on each shard.
     * If a reduce_script is not provided the reduce phase will return the _aggs variable.
     *
     * @param {string|Script} reduceScript The combine script. Can be a string or an Script instance
     * @returns {ScriptedMetricAggregation} returns `this` so that calls can be chained
     */
    reduceScript(reduceScript) {
        this._aggsDef.reduce_script = reduceScript;
        return this;
    }

    /**
     * Sets the params for scripts.
     *
     * Optional object whose contents will be passed as variables to
     * the init_script, map_script and combine_script
     *
     * If you specify script parameters then you must specify `"_agg": {}`.
     *
     * @param {Object} params Object passed to init, map and combine script. Default value - `{ "_agg": {} }`
     * @returns {ScriptedMetricAggregation} returns `this` so that calls can be chained
     */
    params(params) {
        // TODO: If sure, add validation to see that _agg: {} is present in params
        this._aggsDef.params = params;
        return this;
    }
};

var scriptedMetricAggregation$2 = ScriptedMetricAggregation$1;

const MetricsAggregationBase$3 = metricsAggregationBase;

/**
 * A multi-value metrics aggregation that computes stats over numeric values
 * extracted from the aggregated documents. These values can be extracted either
 * from specific numeric fields in the documents, or be generated by a provided
 * script.
 *
 * The stats that are returned consist of: min, max, sum, count and avg.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-stats-aggregation.html)
 *
 * Aggregation that computes stats over numeric values extracted from the
 * aggregated documents.
 *
 * @example
 * const agg = esb.statsAggregation('grades_stats', 'grade');
 *
 *
 * @example
 * // Use a file script
 * const agg = esb.statsAggregation('grades_stats').script(
 *     esb.script('file', 'my_script').params({ field: 'price' })
 * );
 *
 * @example
 * // Value script to apply the conversion rate to every value
 * // before it is aggregated
 * const agg = esb.statsAggregation('grades_stats').script(
 *     esb.script('inline', '_value * params.conversion_rate').params({
 *         conversion_rate: 1.2
 *     })
 * );
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} field The field to aggregate on
 *
 * @extends MetricsAggregationBase
 */
let StatsAggregation$1 = class StatsAggregation extends MetricsAggregationBase$3 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field) {
        super(name, 'stats', field);
    }
};

var statsAggregation$2 = StatsAggregation$1;

const MetricsAggregationBase$2 = metricsAggregationBase;

/**
 * A single-value metrics aggregation that sums up numeric values that are
 * extracted from the aggregated documents. These values can be extracted either
 * from specific numeric fields in the documents, or be generated by a
 * provided script.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-stats-aggregation.html)
 *
 * Aggregation that sums up numeric values that are extracted from the
 * aggregated documents.
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .query(esb.constantScoreQuery(esb.matchQuery('type', 'hat')))
 *     .agg(esb.sumAggregation('hat_prices', 'price'));
 *
 * @example
 * // Script to fetch the sales price
 * const reqBody = esb.requestBodySearch()
 *     .query(esb.constantScoreQuery(esb.matchQuery('type', 'hat')))
 *     .agg(
 *         esb.sumAggregation('hat_prices').script(
 *             esb.script('inline', 'doc.price.value')
 *         )
 *     );
 *
 * @example
 * // Access the field value from the script using `_value`
 * const reqBody = esb.requestBodySearch()
 *     .query(esb.constantScoreQuery(esb.matchQuery('type', 'hat')))
 *     .agg(
 *         esb.sumAggregation('square_hats', 'price').script(
 *             esb.script('inline', '_value * _value')
 *         )
 *     );
 *
 * @example
 * // Treat documents missing price as if they had a value
 * const reqBody = esb.requestBodySearch()
 *     .query(esb.constantScoreQuery(esb.matchQuery('type', 'hat')))
 *     .agg(esb.sumAggregation('hat_prices', 'price').missing(100));
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} field The field to aggregate on
 *
 * @extends MetricsAggregationBase
 */
let SumAggregation$1 = class SumAggregation extends MetricsAggregationBase$2 {
    /**
     * Creates an instance of `SumAggregation`
     *
     * @param {string} name The name which will be used to refer to this aggregation.
     * @param {string=} field The field to aggregate on
     */
    constructor(name, field) {
        super(name, 'sum', field);
    }
};

var sumAggregation$2 = SumAggregation$1;

const MetricsAggregationBase$1 = metricsAggregationBase,
    {
        Highlight: Highlight$1,
        Sort: Sort$1,
        util: { checkType: checkType$d, setDefault: setDefault$4 }
    } = core;

const ES_REF_URL$D =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-top-hits-aggregation.html';

/**
 * A `top_hits` metric aggregator keeps track of the most relevant document being
 * aggregated. This aggregator is intended to be used as a sub aggregator, so that
 * the top matching documents can be aggregated per bucket.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-top-hits-aggregation.html)
 *
 * `top_hits` metric aggregator keeps track of the most relevant document being
 * aggregated.
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .agg(
 *         esb.termsAggregation('top_tags', 'type')
 *             .size(3)
 *             .agg(
 *                 esb.topHitsAggregation('top_sales_hits')
 *                     .sort(esb.sort('date', 'desc'))
 *                     .source({ includes: ['date', 'price'] })
 *                     .size(1)
 *             )
 *     )
 *     .size(0);
 *
 * @example
 * // Field collapsing(logically groups a result set into
 * // groups and per group returns top documents)
 * const reqBody = esb.requestBodySearch()
 *     .query(esb.matchQuery('body', 'elections'))
 *     .agg(
 *         esb.termsAggregation('top-sites', 'domain')
 *             .order('top_hit', 'desc')
 *             .agg(esb.topHitsAggregation('top_tags_hits'))
 *             .agg(
 *                 esb.maxAggregation('top_hit').script(
 *                     esb.script('inline', '_score')
 *                 )
 *             )
 *     );
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 *
 * @extends MetricsAggregationBase
 */
let TopHitsAggregation$1 = class TopHitsAggregation extends MetricsAggregationBase$1 {
    // eslint-disable-next-line require-jsdoc
    constructor(name) {
        super(name, 'top_hits');
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on TopHitsAggregation
     */
    field() {
        console.log(`Please refer ${ES_REF_URL$D}`);
        throw new Error('field is not supported in TopHitsAggregation');
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on TopHitsAggregation
     */
    script() {
        console.log(`Please refer ${ES_REF_URL$D}`);
        throw new Error('script is not supported in TopHitsAggregation');
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on TopHitsAggregation
     */
    missing() {
        console.log(`Please refer ${ES_REF_URL$D}`);
        throw new Error('missing is not supported in TopHitsAggregation');
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on TopHitsAggregation
     */
    format() {
        console.log(`Please refer ${ES_REF_URL$D}`);
        throw new Error('format is not supported in TopHitsAggregation');
    }

    /**
     * Sets the offset for fetching result.
     *
     * @param {number} from The offset from the first result you want to fetch.
     * @returns {TopHitsAggregation} returns `this` so that calls can be chained
     */
    from(from) {
        this._aggsDef.from = from;
        return this;
    }

    /**
     * Sets the maximum number of top matching hits to return per bucket.
     *
     * @param {number} size The numer of aggregation entries to be returned per bucket.
     * @returns {TopHitsAggregation} returns `this` so that calls can be chained
     */
    size(size) {
        this._aggsDef.size = size;
        return this;
    }

    /**
     * How the top matching hits should be sorted. Allows to add sort on specific field.
     * The sort can be reversed as well. The sort is defined on a per field level,
     * with special field name for `_score` to sort by score, and `_doc` to sort by
     * index order.
     *
     * @param {Sort} sort How the top matching hits should be sorted.
     * @returns {TopHitsAggregation} returns `this` so that calls can be chained.
     * @throws {TypeError} If parameter `sort` is not an instance of `Sort`.
     */
    sort(sort) {
        checkType$d(sort, Sort$1);

        setDefault$4(this._aggsDef, 'sort', []);

        this._aggsDef.sort.push(sort);
        return this;
    }

    /**
     * Allows to add multiple sort on specific fields. Each sort can be reversed as well.
     * The sort is defined on a per field level, with special field name for _score to
     * sort by score, and _doc to sort by index order.
     *
     * @param {Array<Sort>} sorts Arry of sort How the top matching hits should be sorted.
     * @returns {TopHitsAggregation} returns `this` so that calls can be chained.
     * @throws {TypeError} If any item in parameter `sorts` is not an instance of `Sort`.
     */
    sorts(sorts) {
        sorts.forEach(sort => this.sort(sort));
        return this;
    }

    /**
     * Enables score computation and tracking during sorting.
     * By default, sorting scores are not computed.
     *
     * @param {boolean} trackScores If scores should be computed and tracked. Defaults to false.
     * @returns {TopHitsAggregation} returns `this` so that calls can be chained
     */
    trackScores(trackScores) {
        this._aggsDef.track_scores = trackScores;
        return this;
    }

    /**
     * Enable/Disable returning version number for each hit.
     *
     * @param {boolean} version true to enable, false to disable
     * @returns {TopHitsAggregation} returns `this` so that calls can be chained
     */
    version(version) {
        this._aggsDef.version = version;
        return this;
    }

    /**
     * Enable/Disable explanation of score for each hit.
     *
     * @param {boolean} explain true to enable, false to disable
     * @returns {TopHitsAggregation} returns `this` so that calls can be chained
     */
    explain(explain) {
        this._aggsDef.explain = explain;
        return this;
    }

    /**
     * Performs highlighting based on the `Highlight` settings.
     *
     * @param {Highlight} highlight
     * @returns {TopHitsAggregation} returns `this` so that calls can be chained
     */
    highlight(highlight) {
        checkType$d(highlight, Highlight$1);

        this._aggsDef.highlight = highlight;
        return this;
    }

    /**
     * Allows to control how the `_source` field is returned with every hit.
     * You can turn off `_source` retrieval by passing `false`.
     * It also accepts one(string) or more wildcard(array) patterns to control
     * what parts of the `_source` should be returned
     * An object can also be used to specify the wildcard patterns for `includes` and `excludes`.
     *
     * @param {boolean|string|Array|Object} source
     * @returns {TopHitsAggregation} returns `this` so that calls can be chained
     */
    source(source) {
        this._aggsDef._source = source;
        return this;
    }

    /**
     * The stored_fields parameter is about fields that are explicitly marked as stored in the mapping.
     * Selectively load specific stored fields for each document represented by a search hit
     * using array of stored fields.
     * An empty array will cause only the _id and _type for each hit to be returned.
     * To disable the stored fields (and metadata fields) entirely use: '_none_'
     *
     * @param {Array|string} fields
     * @returns {TopHitsAggregation} returns `this` so that calls can be chained
     */
    storedFields(fields) {
        this._aggsDef.stored_fields = fields;
        return this;
    }

    /**
     * Computes a document property dynamically based on the supplied `Script`.
     *
     * @param {string} scriptFieldName
     * @param {string|Script} script string or instance of `Script`
     * @returns {TopHitsAggregation} returns `this` so that calls can be chained
     */
    scriptField(scriptFieldName, script) {
        setDefault$4(this._aggsDef, 'script_fields', {});

        this._aggsDef.script_fields[scriptFieldName] = { script };
        return this;
    }

    /**
     * Sets given dynamic document properties to be computed using supplied `Script`s.
     *
     * Object should have `scriptFieldName` as key and `script` as the value.
     *
     * @param {Object} scriptFields Object with `scriptFieldName` as key and `script` as the value.
     * @returns {TopHitsAggregation} returns `this` so that calls can be chained
     */
    scriptFields(scriptFields) {
        checkType$d(scriptFields, Object);

        Object.keys(scriptFields).forEach(scriptFieldName =>
            this.scriptField(scriptFieldName, scriptFields[scriptFieldName])
        );

        return this;
    }

    /**
     * Allows to return the doc value representation of a field for each hit.
     * Doc value fields can work on fields that are not stored.
     *
     * @param {Array<string>} fields
     * @returns {TopHitsAggregation} returns `this` so that calls can be chained
     */
    docvalueFields(fields) {
        this._aggsDef.docvalue_fields = fields;
        return this;
    }
};

var topHitsAggregation$2 = TopHitsAggregation$1;

const MetricsAggregationBase = metricsAggregationBase;

const ES_REF_URL$C =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-valuecount-aggregation.html';

/**
 * A single-value metrics aggregation that counts the number of values that
 * are extracted from the aggregated documents. These values can be extracted
 * either from specific fields in the documents, or be generated by a provided
 * script. Typically, this aggregator will be used in conjunction with other
 * single-value aggregations.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-metrics-valuecount-aggregation.html)
 *
 * Aggregation that counts the number of values that are extracted from the
 * aggregated documents.
 *
 * @example
 * const agg = esb.valueCountAggregation('types_count', 'type');
 *
 * @example
 * const agg = esb.valueCountAggregation('types_count').script(
 *     esb.script('inline', "doc['type'].value")
 * );
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} field The field to aggregate on
 *
 * @extends MetricsAggregationBase
 */
let ValueCountAggregation$1 = class ValueCountAggregation extends MetricsAggregationBase {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field) {
        super(name, 'value_count', field);
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on ValueCountAggregation
     */
    format() {
        console.log(`Please refer ${ES_REF_URL$C}`);
        throw new Error('format is not supported in ValueCountAggregation');
    }
};

var valueCountAggregation$2 = ValueCountAggregation$1;

metricsAggregations.MetricsAggregationBase = metricsAggregationBase;

metricsAggregations.AvgAggregation = avgAggregation$2;
metricsAggregations.CardinalityAggregation = cardinalityAggregation$2;
metricsAggregations.ExtendedStatsAggregation = extendedStatsAggregation$2;
metricsAggregations.GeoBoundsAggregation = geoBoundsAggregation$2;
metricsAggregations.GeoCentroidAggregation = geoCentroidAggregation$2;
metricsAggregations.MaxAggregation = maxAggregation$2;
metricsAggregations.MinAggregation = minAggregation$2;
metricsAggregations.PercentilesAggregation = percentilesAggregation$2;
metricsAggregations.PercentileRanksAggregation = percentileRanksAggregation$2;
metricsAggregations.ScriptedMetricAggregation = scriptedMetricAggregation$2;
metricsAggregations.StatsAggregation = statsAggregation$2;
metricsAggregations.SumAggregation = sumAggregation$2;
metricsAggregations.TopHitsAggregation = topHitsAggregation$2;
metricsAggregations.ValueCountAggregation = valueCountAggregation$2;

var bucketAggregations = {};

const isNil$r = lodash_isnil;

const {
    Aggregation: Aggregation$3,
    Script: Script$2,
    util: { checkType: checkType$c }
} = core;

/**
 * The `BucketAggregationBase` provides support for common options used across
 * various bucket `Aggregation` implementations.
 *
 * **NOTE:** Instantiating this directly should not be required.
 * However, if you wish to add a custom implementation for whatever reason,
 * this class could be extended.
 *
 * @param {string} name a valid aggregation name
 * @param {string} aggType type of aggregation
 * @param {string=} field The field to aggregate on
 *
 * @extends Aggregation
 */
let BucketAggregationBase$k = class BucketAggregationBase extends Aggregation$3 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, aggType, field) {
        super(name, aggType);

        if (!isNil$r(field)) this._aggsDef.field = field;
    }

    /**
     * Sets field to run aggregation on.
     *
     * @param {string} field a valid field name
     * @returns {BucketAggregationBase} returns `this` so that calls can be chained
     */
    field(field) {
        this._aggsDef.field = field;
        return this;
    }

    /**
     * Sets script parameter for aggregation.
     *
     * @example
     * // Generating the terms using a script
     * const agg = esb.termsAggregation('genres').script(
     *     esb.script('file', 'my_script').params({ field: 'genre' })
     * );
     *
     * @example
     * // Value script
     * const agg = esb.termsAggregation('genres', 'genre').script(
     *     esb.script('inline', "'Genre: ' +_value").lang('painless')
     * );
     *
     * @param {Script} script
     * @returns {BucketAggregationBase} returns `this` so that calls can be chained
     * @throws {TypeError} If `script` is not an instance of `Script`
     */
    script(script) {
        checkType$c(script, Script$2);
        this._aggsDef.script = script;
        return this;
    }
};

var bucketAggregationBase = BucketAggregationBase$k;

const has$1 = lodash_has;
const isNil$q = lodash_isnil;

const {
    util: { invalidParam: invalidParam$a }
} = core;

const BucketAggregationBase$j = bucketAggregationBase;

const invalidDirectionParam$1 = invalidParam$a('', 'direction', "'asc' or 'desc'");

/**
 * The `HistogramAggregationBase` provides support for common options used across
 * various histogram `Aggregation` implementations like Histogram Aggregation,
 * Date Histogram aggregation.
 *
 * **NOTE:** Instantiating this directly should not be required.
 * However, if you wish to add a custom implementation for whatever reason,
 * this class could be extended.
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string} aggType Type of aggregation
 * @param {string=} field The field to aggregate on
 * @param {string|number=} interval Interval to generate histogram over.
 *
 * @extends BucketAggregationBase
 */
let HistogramAggregationBase$2 = class HistogramAggregationBase extends BucketAggregationBase$j {
    // eslint-disable-next-line require-jsdoc
    constructor(name, aggType, field, interval) {
        super(name, aggType, field);

        if (!isNil$q(interval)) this._aggsDef.interval = interval;
    }

    /**
     * Sets the histogram interval. Buckets are generated based on this interval value.
     *
     * @param {string} interval Interval to generate histogram over.
     * For date histograms, available expressions for interval:
     * year, quarter, month, week, day, hour, minute, second
     * @returns {HistogramAggregationBase} returns `this` so that calls can be chained
     */
    interval(interval) {
        this._aggsDef.interval = interval;
        return this;
    }

    /**
     * Sets the format expression for `key_as_string` in response buckets.
     * If no format is specified, then it will use the first format specified in the field mapping.
     *
     * @example
     * const agg = esb.dateHistogramAggregation(
     *     'sales_over_time',
     *     'date',
     *     '1M'
     * ).format('yyyy-MM-dd');
     *
     * @param {string} fmt Format mask to apply on aggregation response. Example: ####.00.
     * For Date Histograms, supports expressive [date format pattern](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-daterange-aggregation.html#date-format-pattern)
     * @returns {HistogramAggregationBase} returns `this` so that calls can be chained
     */
    format(fmt) {
        this._aggsDef.format = fmt;
        return this;
    }

    /**
     * The offset parameter is used to change the start value of each bucket
     * by the specified positive (+) or negative offset (-).
     * Negative offset is not applicable on HistogramAggregation.
     * In case of DateHistogramAggregation, duration can be
     * a value such as 1h for an hour, or 1d for a day.
     *
     * @example
     * const agg = esb.dateHistogramAggregation('by_day', 'date', 'day').offset('6h');
     *
     * @param {string} offset Time or bucket key offset for bucketing.
     * @returns {HistogramAggregationBase} returns `this` so that calls can be chained
     */
    offset(offset) {
        this._aggsDef.offset = offset;
        return this;
    }

    /**
     * Sets the ordering for buckets
     *
     * @example
     * const agg = esb.histogramAggregation('prices', 'price', 50)
     *     .order('_count', 'desc');
     *
     * @example
     * const agg = esb.histogramAggregation('prices', 'price', 50)
     *     .order('promoted_products>rating_stats.avg', 'desc')
     *     .agg(
     *         esb.filterAggregation('promoted_products')
     *             .filter(esb.termQuery('promoted', 'true'))
     *             .agg(esb.statsAggregation('rating_stats', 'rating'))
     *     );
     *
     * @param {string} key
     * @param {string} direction `asc` or `desc`
     * @returns {HistogramAggregationBase} returns `this` so that calls can be chained
     */
    order(key, direction = 'desc') {
        if (isNil$q(direction)) invalidDirectionParam$1(direction);

        const directionLower = direction.toLowerCase();
        if (directionLower !== 'asc' && directionLower !== 'desc') {
            invalidDirectionParam$1(direction);
        }

        if (has$1(this._aggsDef, 'order')) {
            if (!Array.isArray(this._aggsDef.order)) {
                this._aggsDef.order = [this._aggsDef.order];
            }

            this._aggsDef.order.push({ [key]: directionLower });
        } else {
            this._aggsDef.order = { [key]: directionLower };
        }

        return this;
    }

    /**
     * Sets the minimum number of matching documents in range to return the bucket.
     *
     * @example
     * const agg = esb.histogramAggregation('prices', 'price', 50).minDocCount(1);
     *
     * @param {number} minDocCnt Integer value for minimum number of documents
     * required to return bucket in response
     * @returns {HistogramAggregationBase} returns `this` so that calls can be chained
     */
    minDocCount(minDocCnt) {
        this._aggsDef.min_doc_count = minDocCnt;
        return this;
    }

    /**
     * Set's the range/bounds for the histogram aggregation.
     * Useful when you want to include buckets that might be
     * outside the bounds of indexed documents.
     *
     * @example
     * const agg = esb.histogramAggregation('prices', 'price', 50).extendedBounds(0, 500);
     *
     * @param {number|string} min Start bound / minimum bound value
     * For histogram aggregation, Integer value can be used.
     * For Date histogram, date expression can be used.
     * Available expressions for interval:
     * year, quarter, month, week, day, hour, minute, second
     * @param {number|string} max End bound / maximum bound value
     * For histogram aggregation, Integer value can be used.
     * For Date histogram, date expression can be used.
     * Available expressions for interval:
     * year, quarter, month, week, day, hour, minute, second
     * @returns {HistogramAggregationBase} returns `this` so that calls can be chained
     */
    extendedBounds(min, max) {
        this._aggsDef.extended_bounds = { min, max };
        return this;
    }

    /**
     * Set's the range/bounds for the histogram aggregation.
     * Useful when you want to limit the range of buckets in the histogram.
     * It is particularly useful in the case of open data ranges that can result in a very large number of buckets.
     * NOTE: Only available in Elasticsearch v7.10.0+
     *
     * @example
     * const agg = esb.histogramAggregation('prices', 'price', 50).hardBounds(0, 500);
     *
     * @param {number|string} min Start bound / minimum bound value
     * For histogram aggregation, Integer value can be used.
     * For Date histogram, date expression can be used.
     * Available expressions for interval:
     * year, quarter, month, week, day, hour, minute, second
     * @param {number|string} max End bound / maximum bound value
     * For histogram aggregation, Integer value can be used.
     * For Date histogram, date expression can be used.
     * Available expressions for interval:
     * year, quarter, month, week, day, hour, minute, second
     * @returns {HistogramAggregationBase} returns `this` so that calls can be chained
     */
    hardBounds(min, max) {
        this._aggsDef.hard_bounds = { min, max };
        return this;
    }

    /**
     * Sets the missing parameter which defines how documents
     * that are missing a value should be treated.
     *
     * @example
     * const agg = esb.histogramAggregation('quantity', 'quantity', 10).missing(0);
     *
     * @param {string} value
     * @returns {HistogramAggregationBase} returns `this` so that calls can be chained
     */
    missing(value) {
        this._aggsDef.missing = value;
        return this;
    }

    /**
     * Enable the response to be returned as a keyed object where the key is the
     * bucket interval.
     *
     * @example
     * const agg = esb.dateHistogramAggregation('sales_over_time', 'date', '1M')
     *     .keyed(true)
     *     .format('yyyy-MM-dd');
     *
     * @param {boolean} keyed To enable keyed response or not.
     * @returns {HistogramAggregationBase} returns `this` so that calls can be chained
     */
    keyed(keyed) {
        this._aggsDef.keyed = keyed;
        return this;
    }
};

var histogramAggregationBase = HistogramAggregationBase$2;

const isEmpty$2 = lodash_isemptyExports;

const {
    util: { checkType: checkType$b }
} = core;

const BucketAggregationBase$i = bucketAggregationBase;

const hasOwnProp = Object.prototype.hasOwnProperty;

/**
 * The `RangeAggregationBase` provides support for common options used across
 * various range `Aggregation` implementations like Range Aggregation and
 * Date Range aggregation.
 *
 * **NOTE:** Instantiating this directly should not be required.
 * However, if you wish to add a custom implementation for whatever reason,
 * this class could be extended.
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string} aggType Type of aggregation
 * @param {string=} field The field to aggregate on
 *
 * @extends BucketAggregationBase
 */
let RangeAggregationBase$4 = class RangeAggregationBase extends BucketAggregationBase$i {
    // eslint-disable-next-line require-jsdoc
    constructor(name, aggType, field) {
        super(name, aggType, field);
        // Variable name is misleading. Only one of these needs to be present.
        this._rangeRequiredKeys = ['from', 'to'];

        this._aggsDef.ranges = [];
    }

    /**
     * Sets the format expression for `key_as_string` in response buckets.
     * If no format is specified, then it will use the format specified in the field mapping.
     *
     * @param {string} fmt Supports expressive [date format pattern](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-daterange-aggregation.html#date-format-pattern) for Date Histograms
     * @returns {RangeAggregationBase} returns `this` so that calls can be chained
     */
    format(fmt) {
        this._aggsDef.format = fmt;
        return this;
    }

    /**
     * Adds a range to the list of existing range expressions.
     *
     * @param {Object} range Range to aggregate over. Valid keys are `from`, `to` and `key`
     * @returns {RangeAggregationBase} returns `this` so that calls can be chained
     *
     * @throws {TypeError} If `range` is not an instance of object
     * @throws {Error} If none of the required keys,
     * `from`, `to` or `mask`(for IP range) is passed
     */
    range(range) {
        checkType$b(range, Object);
        if (!this._rangeRequiredKeys.some(hasOwnProp, range)) {
            throw new Error(
                `Invalid Range! Range must have at least one of ${this._rangeRequiredKeys}`
            );
        }

        this._aggsDef.ranges.push(range);
        return this;
    }

    /**
     * Adds the list of ranges to the list of existing range expressions.
     *
     * @param {Array<Object>} ranges Ranges to aggregate over.
     * Each item must be an object with keys `from`, `to` and `key`.
     * @returns {RangeAggregationBase} returns `this` so that calls can be chained
     *
     * @throws {TypeError} If `ranges` is not an instance of an array or
     * and item in the array is not an instance of object
     * @throws {Error} If none of the required keys,
     * `from`, `to` or `mask`(for IP range) is passed
     */
    ranges(ranges) {
        checkType$b(ranges, Array);

        ranges.forEach(range => this.range(range));
        return this;
    }

    /**
     * Sets the missing parameter ehich defines how documents
     * that are missing a value should be treated.
     *
     * @param {string} value
     * @returns {RangeAggregationBase} returns `this` so that calls can be chained
     */
    missing(value) {
        this._aggsDef.missing = value;
        return this;
    }

    /**
     * Enable the response to be returned as a keyed object where the key is the
     * bucket interval.
     *
     * @example
     * const agg = esb.dateRangeAggregation('range', 'date')
     *     .format('MM-yyy')
     *     .ranges([{ to: 'now-10M/M' }, { from: 'now-10M/M' }])
     *     .keyed(true);
     *
     * @example
     * const agg = esb.geoDistanceAggregation('rings_around_amsterdam', 'location')
     *     .origin(esb.geoPoint().string('52.3760, 4.894'))
     *     .ranges([
     *         { to: 100000, key: 'first_ring' },
     *         { from: 100000, to: 300000, key: 'second_ring' },
     *         { from: 300000, key: 'third_ring' }
     *     ])
     *     .keyed(true);
     *
     * @param {boolean} keyed To enable keyed response or not.
     * @returns {RangeAggregationBase} returns `this` so that calls can be chained
     */
    keyed(keyed) {
        this._aggsDef.keyed = keyed;
        return this;
    }

    /**
     * Override default `toJSON` to return DSL representation for the `aggregation` query.
     *
     * @override
     * @returns {Object} returns an Object which maps to the elasticsearch query DSL
     */
    toJSON() {
        if (isEmpty$2(this._aggsDef.ranges)) {
            throw new Error('`ranges` cannot be empty.');
        }

        return super.toJSON();
    }
};

var rangeAggregationBase = RangeAggregationBase$4;

const isNil$p = lodash_isnil;

const {
    util: { invalidParam: invalidParam$9 },
    consts: { EXECUTION_HINT_SET: EXECUTION_HINT_SET$1 }
} = core;

const BucketAggregationBase$h = bucketAggregationBase;

const invalidExecutionHintParam$1 = invalidParam$9(
    '',
    'execution_hint',
    EXECUTION_HINT_SET$1
);

/**
 * The `TermsAggregationBase` provides support for common options used across
 * various terms `Aggregation` implementations like Significant terms and
 * Terms aggregation.
 *
 * **NOTE:** Instantiating this directly should not be required.
 * However, if you wish to add a custom implementation for whatever reason,
 * this class could be extended.
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string} aggType Type of aggregation
 * @param {string} refUrl Elasticsearch reference URL.
 * @param {string=} field The field to aggregate on
 *
 * @extends BucketAggregationBase
 */
let TermsAggregationBase$2 = class TermsAggregationBase extends BucketAggregationBase$h {
    // eslint-disable-next-line require-jsdoc
    constructor(name, aggType, refUrl, field) {
        super(name, aggType, field);

        this._refUrl = refUrl;
    }

    /**
     * Sets the format expression for `key_as_string` in response buckets.
     * If no format is specified, then it will use the first format specified in the field mapping.
     *
     * @param {string} fmt Format mask to apply on aggregation response. Example: ####.00.
     * @returns {TermsAggregationBase} returns `this` so that calls can be chained
     */
    format(fmt) {
        this._aggsDef.format = fmt;
        return this;
    }

    /**
     * Sets the minimum number of matching hits required to return the terms.
     *
     * @example
     * const agg = esb.significantTermsAggregation('tags', 'tag').minDocCount(10);
     *
     * @param {number} minDocCnt Integer value for minimum number of documents
     * required to return bucket in response
     * @returns {TermsAggregationBase} returns `this` so that calls can be chained
     */
    minDocCount(minDocCnt) {
        this._aggsDef.min_doc_count = minDocCnt;
        return this;
    }

    /**
     * Sets the parameter which regulates the _certainty_ a shard has if the term
     * should actually be added to the candidate list or not with respect to
     * the `min_doc_count`.
     * Terms will only be considered if their local shard frequency within
     * the set is higher than the `shard_min_doc_count`.
     *
     * @param {number} minDocCnt Sets the `shard_min_doc_count` parameter. Default is 1
     * and has no effect unless you explicitly set it.
     * @returns {TermsAggregationBase} returns `this` so that calls can be chained
     */
    shardMinDocCount(minDocCnt) {
        this._aggsDef.shard_min_doc_count = minDocCnt;
        return this;
    }

    /**
     * Defines how many term buckets should be returned out of the overall terms list.
     *
     * @example
     * const agg = esb.termsAggregation('products', 'product').size(5);
     *
     * @param {number} size
     * @returns {TermsAggregationBase} returns `this` so that calls can be chained
     */
    size(size) {
        this._aggsDef.size = size;
        return this;
    }

    /**
     * Sets the `shard_size` parameter to control the volumes of candidate terms
     * produced by each shard. For the default, -1, shard_size will be automatically
     * estimated based on the number of shards and the size parameter.
     *
     * `shard_size` cannot be smaller than size (as it doesnt make much sense).
     * When it is, elasticsearch will override it and reset it to be equal to size.
     *
     * @param {number} size
     * @returns {TermsAggregationBase} returns `this` so that calls can be chained
     */
    shardSize(size) {
        this._aggsDef.shard_size = size;
        return this;
    }

    /**
     * Sets the missing parameter which defines how documents
     * that are missing a value should be treated.
     *
     * @param {string} value
     * @returns {TermsAggregationBase} returns `this` so that calls can be chained
     */
    missing(value) {
        this._aggsDef.missing = value;
        return this;
    }

    /**
     * Filter the values for which buckets will be created.
     *
     * @example
     * const agg = esb.termsAggregation('tags', 'tags')
     *     .include('.*sport.*')
     *     .exclude('water_.*');
     *
     * @example
     * // Match on exact values
     * const reqBody = esb.requestBodySearch()
     *     .agg(
     *         esb.termsAggregation('JapaneseCars', 'make').include([
     *             'mazda',
     *             'honda'
     *         ])
     *     )
     *     .agg(
     *         esb.termsAggregation('ActiveCarManufacturers', 'make').exclude([
     *             'rover',
     *             'jensen'
     *         ])
     *     );
     *
     * @param {RegExp|Array|string} clause Determine what values are "allowed" to be aggregated
     * @returns {TermsAggregationBase} returns `this` so that calls can be chained
     */
    include(clause) {
        this._aggsDef.include = clause;
        return this;
    }

    /**
     * Filter the values for which buckets will be created.
     *
     * @example
     * const agg = esb.termsAggregation('tags', 'tags')
     *     .include('.*sport.*')
     *     .exclude('water_.*');
     *
     * @example
     * // Match on exact values
     * const reqBody = esb.requestBodySearch()
     *     .agg(
     *         esb.termsAggregation('JapaneseCars', 'make').include([
     *             'mazda',
     *             'honda'
     *         ])
     *     )
     *     .agg(
     *         esb.termsAggregation('ActiveCarManufacturers', 'make').exclude([
     *             'rover',
     *             'jensen'
     *         ])
     *     );
     *
     * @param {RegExp|Array|string} clause Determine the values that should not be aggregated
     * @returns {TermsAggregationBase} returns `this` so that calls can be chained
     */
    exclude(clause) {
        this._aggsDef.exclude = clause;
        return this;
    }

    /**
     * This setting can influence the management of the values used
     * for de-duplication. Each option will hold up to shard_size
     * values in memory while performing de-duplication but
     * the type of value held can be controlled
     *
     * @example
     * const agg = esb.significantTermsAggregation('tags', 'tag').executionHint('map');
     *
     * @example
     * const agg = esb.termsAggregation('tags', 'tags').executionHint('map');
     *
     * @param {string} hint the possible values are `map`, `global_ordinals`,
     * `global_ordinals_hash` and `global_ordinals_low_cardinality`
     * @returns {TermsAggregationBase} returns `this` so that calls can be chained
     * @throws {Error} If Execution Hint is outside the accepted set.
     */
    executionHint(hint) {
        if (isNil$p(hint)) invalidExecutionHintParam$1(hint, this._refUrl);

        const hintLower = hint.toLowerCase();
        if (!EXECUTION_HINT_SET$1.has(hintLower)) {
            invalidExecutionHintParam$1(hint, this._refUrl);
        }

        this._aggsDef.execution_hint = hint;
        return this;
    }
};

var termsAggregationBase = TermsAggregationBase$2;

const {
    Query: Query$4,
    Script: Script$1,
    util: { checkType: checkType$a }
} = core;

const TermsAggregationBase$1 = termsAggregationBase;

/**
 * The `SignificantAggregationBase` provides support for common options used
 * in `SignificantTermsAggregation` and `SignificantTextAggregation`.
 *
 * **NOTE:** Instantiating this directly should not be required.
 * However, if you wish to add a custom implementation for whatever reason,
 * this class could be extended.
 *
 * @extends TermsAggregationBase
 */
let SignificantAggregationBase$2 = class SignificantAggregationBase extends TermsAggregationBase$1 {
    /**
     * Use JLH score as significance score.
     *
     * @returns {SignificantAggregationBase} returns `this` so that calls can be chained
     */
    jlh() {
        // I am guessing here
        // Reference is not clear on usage
        this._aggsDef.jlh = {};
        return this;
    }

    /**
     * Use `mutual_information` as significance score
     *
     * @param {boolean=} includeNegatives Default `true`. If set to `false`,
     * filters out the terms that appear less often in the subset than in
     * documents outside the subset
     * @param {boolean=} backgroundIsSuperset `true`(default) if the documents in the bucket
     * are also contained in the background. If instead you defined a custom background filter
     * that represents a different set of documents that you want to compare to, pass `false`
     * @returns {SignificantAggregationBase} returns `this` so that calls can be chained
     */
    mutualInformation(includeNegatives = true, backgroundIsSuperset = true) {
        this._aggsDef.mutual_information = {
            include_negatives: includeNegatives,
            background_is_superset: backgroundIsSuperset
        };
        return this;
    }

    /**
     * Use `chi_square` as significance score
     *
     * @param {boolean} includeNegatives Default `true`. If set to `false`,
     * filters out the terms that appear less often in the subset than in
     * documents outside the subset
     * @param {boolean} backgroundIsSuperset `true`(default) if the documents in the bucket
     * are also contained in the background. If instead you defined a custom background filter
     * that represents a different set of documents that you want to compare to, pass `false`
     * @returns {SignificantAggregationBase} returns `this` so that calls can be chained
     */
    chiSquare(includeNegatives = true, backgroundIsSuperset = true) {
        this._aggsDef.chi_square = {
            include_negatives: includeNegatives,
            background_is_superset: backgroundIsSuperset
        };
        return this;
    }

    /**
     * Sets `gnd`, google normalized score to be used as significance score.
     *
     * @param {boolean} backgroundIsSuperset `true`(default) if the documents in the bucket
     * are also contained in the background. If instead you defined a custom background filter
     * that represents a different set of documents that you want to compare to, pass `false`
     * @returns {SignificantAggregationBase} returns `this` so that calls can be chained
     */
    gnd(backgroundIsSuperset = true) {
        this._aggsDef.gnd = {
            background_is_superset: backgroundIsSuperset
        };
        return this;
    }

    /**
     * Use a simple calculation of the number of documents in the foreground sample with a term
     * divided by the number of documents in the background with the term. By default this
     * produces a score greater than zero and less than one.
     *
     * @returns {SignificantAggregationBase} returns `this` so that calls can be chained
     */
    percentage() {
        this._aggsDef.percentage = {};
        return this;
    }

    /**
     * Sets script for customized score calculation.
     *
     * @param {Script} script
     * @returns {SignificantAggregationBase} returns `this` so that calls can be chained
     */
    scriptHeuristic(script) {
        checkType$a(script, Script$1);

        this._aggsDef.script_heuristic = { script };
        return this;
    }

    /**
     * Sets the `background_filter` to narrow the scope of statistical information
     * for background term frequencies instead of using the entire index.
     *
     * @example
     * const reqBody = esb.requestBodySearch()
     *     .query(esb.matchQuery('text', 'madrid'))
     *     .agg(
     *         esb.significantAggregationBase('tags', 'tag').backgroundFilter(
     *             esb.termQuery('text', 'spain')
     *         )
     *     );
     *
     * @param {Query} filterQuery Filter query
     * @returns {SignificantAggregationBase} returns `this` so that calls can be chained
     */
    backgroundFilter(filterQuery) {
        checkType$a(filterQuery, Query$4);

        this._aggsDef.background_filter = filterQuery;
        return this;
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on SignificantAggregationBase
     */
    script() {
        console.log(`Please refer ${this._refUrl}`);
        throw new Error(`script is not supported in ${this.constructor.name}`);
    }
};

var significantAggregationBase = SignificantAggregationBase$2;

const {
    Query: Query$3,
    util: { checkType: checkType$9, setDefault: setDefault$3 }
} = core;

const BucketAggregationBase$g = bucketAggregationBase;

const ES_REF_URL$B =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-adjacency-matrix-aggregation.html';

/**
 * A bucket aggregation returning a form of adjacency matrix.
 * The request provides a collection of named filter expressions,
 * similar to the `filters` aggregation request. Each bucket in the response
 * represents a non-empty cell in the matrix of intersecting filters.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-adjacency-matrix-aggregation.html)
 *
 * @example
 * const agg = esb.adjacencyMatrixAggregation('interactions').filters({
 *     grpA: esb.termsQuery('accounts', ['hillary', 'sidney']),
 *     grpB: esb.termsQuery('accounts', ['donald', 'mitt']),
 *     grpC: esb.termsQuery('accounts', ['vladimir', 'nigel'])
 * });
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 *
 * @extends BucketAggregationBase
 */
let AdjacencyMatrixAggregation$1 = class AdjacencyMatrixAggregation extends BucketAggregationBase$g {
    // eslint-disable-next-line require-jsdoc
    constructor(name) {
        super(name, 'adjacency_matrix');
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on AdjacencyMatrixAggregation
     */
    field() {
        console.log(`Please refer ${ES_REF_URL$B}`);
        throw new Error('field is not supported in AdjacencyMatrixAggregation');
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on AdjacencyMatrixAggregation
     */
    script() {
        console.log(`Please refer ${ES_REF_URL$B}`);
        throw new Error(
            'script is not supported in AdjacencyMatrixAggregation'
        );
    }

    /**
     * Sets a named filter query.
     *
     * @param {string} filterName Name for the filter.
     * @param {Query} filterQuery Query to filter on. Example - term query.
     * @returns {AdjacencyMatrixAggregation} returns `this` so that calls can be chained
     * @throws {TypeError} If `filterQuery` is not an instance of `Query`
     */
    filter(filterName, filterQuery) {
        checkType$9(filterQuery, Query$3);

        setDefault$3(this._aggsDef, 'filters', {});

        this._aggsDef.filters[filterName] = filterQuery;
        return this;
    }

    /**
     * Assigns filters to already added filters.
     * Does not mix with anonymous filters.
     * If anonymous filters are present, they will be overwritten.
     *
     * @param {Object} filterQueries Object with multiple key value pairs
     * where filter name is the key and filter query is the value.
     * @returns {AdjacencyMatrixAggregation} returns `this` so that calls can be chained
     * @throws {TypeError} If `filterQueries` is not an instance of object
     */
    filters(filterQueries) {
        checkType$9(filterQueries, Object);

        setDefault$3(this._aggsDef, 'filters', {});

        Object.assign(this._aggsDef.filters, filterQueries);
        return this;
    }

    /**
     * Sets the `separator` parameter to use a separator string other than
     * the default of the ampersand.
     *
     * @param {string} sep the string used to separate keys in intersections buckets
     * e.g. & character for keyed filters A and B would return an
     * intersection bucket named A&B
     * @returns {AdjacencyMatrixAggregation} returns `this` so that calls can be chained
     */
    separator(sep) {
        this._aggsDef.separator = sep;
        return this;
    }
};

var adjacencyMatrixAggregation$2 = AdjacencyMatrixAggregation$1;

const BucketAggregationBase$f = bucketAggregationBase;

const ES_REF_URL$A =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-children-aggregation.html';

/**
 * A special single bucket aggregation that enables aggregating
 * from buckets on parent document types to buckets on child documents.
 *
 * This aggregation relies on the `_parent` field in the mapping.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-children-aggregation.html)
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .agg(
 *         esb.termsAggregation('top-tags', 'tags.keyword')
 *             .size(10)
 *             .agg(
 *                 esb.childrenAggregation('to-answers')
 *                     .type('answer')
 *                     .agg(
 *                         esb.termsAggregation(
 *                             'top-names',
 *                             'owner.display_name.keyword'
 *                         ).size(10)
 *                     )
 *             )
 *     )
 *     .size(0);
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 *
 * @extends BucketAggregationBase
 */
let ChildrenAggregation$1 = class ChildrenAggregation extends BucketAggregationBase$f {
    // eslint-disable-next-line require-jsdoc
    constructor(name) {
        super(name, 'children');
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on ChildrenAggregation
     */
    field() {
        console.log(`Please refer ${ES_REF_URL$A}`);
        throw new Error('field is not supported in ChildrenAggregation');
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on ChildrenAggregation
     */
    script() {
        console.log(`Please refer ${ES_REF_URL$A}`);
        throw new Error('script is not supported in ChildrenAggregation');
    }

    /**
     * Sets the child type/mapping for aggregation.
     *
     * @param {string} type The child type that the buckets in the parent space should be mapped to.
     * @returns {ChildrenAggregation} returns `this` so that calls can be chained
     */
    type(type) {
        this._aggsDef.type = type;
        return this;
    }
};

var childrenAggregation$2 = ChildrenAggregation$1;

var compositeAggValuesSources = {};

const isEmpty$1 = lodash_isemptyExports;
const isNil$o = lodash_isnil;

const {
    util: { invalidParam: invalidParam$8, recursiveToJSON: recursiveToJSON$1 }
} = core;

const invalidOrderParam = invalidParam$8('', 'order', "'asc' or 'desc'");

/**
 * Base class implementation for all Composite Aggregation values sources.
 *
 * **NOTE:** Instantiating this directly should not be required.
 *
 * @param {string} valueSrcType Type of value source
 * @param {string} refUrl Elasticsearch reference URL
 * @param {string} name
 * @param {string=} field The field to aggregate on
 *
 * @throws {Error} if `name` is empty
 * @throws {Error} if `valueSrcType` is empty
 */
let ValuesSourceBase$4 = class ValuesSourceBase {
    // eslint-disable-next-line require-jsdoc
    constructor(valueSrcType, refUrl, name, field) {
        if (isEmpty$1(valueSrcType))
            throw new Error('ValuesSourceBase `valueSrcType` cannot be empty');

        this._name = name;
        this._valueSrcType = valueSrcType;
        this._refUrl = refUrl;

        this._body = {};
        this._opts = this._body[valueSrcType] = {};

        if (!isNil$o(field)) this._opts.field = field;
    }

    /**
     * Field to use for this source.
     *
     * @param {string} field a valid field name
     * @returns {ValuesSourceBase} returns `this` so that calls can be chained
     */
    field(field) {
        this._opts.field = field;
        return this;
    }

    /**
     * Script to use for this source.
     *
     * @param {Script|Object|string} script
     * @returns {ValuesSourceBase} returns `this` so that calls can be chained
     * @throws {TypeError} If `script` is not an instance of `Script`
     */
    script(script) {
        this._opts.script = script;
        return this;
    }

    /**
     * Specifies the type of values produced by this source, e.g. `string` or
     * `date`.
     *
     * @param {string} valueType
     * @returns {ValuesSourceBase} returns `this` so that calls can be chained
     */
    valueType(valueType) {
        this._opts.value_type = valueType;
        return this;
    }

    /**
     * Order specifies the order in the values produced by this source. It can
     * be either `asc` or `desc`.
     *
     * @param {string} order The `order` option can have the following values.
     * `asc`, `desc` to sort in ascending, descending order respectively.
     * @returns {ValuesSourceBase} returns `this` so that calls can be chained.
     */
    order(order) {
        if (isNil$o(order)) invalidOrderParam(order, this._refUrl);

        const orderLower = order.toLowerCase();
        if (orderLower !== 'asc' && orderLower !== 'desc') {
            invalidOrderParam(order, this._refUrl);
        }

        this._opts.order = orderLower;
        return this;
    }

    /**
     * Missing specifies the value to use when the source finds a missing value
     * in a document.
     *
     * Note: This option was deprecated in
     * [Elasticsearch v6](https://www.elastic.co/guide/en/elasticsearch/reference/6.8/breaking-changes-6.0.html#_literal_missing_literal_is_deprecated_in_the_literal_composite_literal_aggregation).
     * From 6.4 and later, use `missing_bucket` instead.
     *
     * @param {string|number} value
     * @returns {ValuesSourceBase} returns `this` so that calls can be chained
     */
    missing(value) {
        this._opts.missing = value;
        return this;
    }

    /**
     * Specifies whether to include documents without a value for a given source
     * in the response. Defaults to `false` (not included).
     *
     * Note: This method is incompatible with elasticsearch 6.3 and older.
     * Use it only with elasticsearch 6.4 and later.
     *
     * @param {boolean} value
     * @returns {ValuesSourceBase} returns `this` so that calls can be chained
     */
    missingBucket(value) {
        this._opts.missing_bucket = value;
        return this;
    }

    /**
     * Override default `toJSON` to return DSL representation for the Composite
     * Aggregation values source.
     *
     * @override
     * @returns {Object} returns an Object which maps to the elasticsearch query DSL
     */
    toJSON() {
        return { [this._name]: recursiveToJSON$1(this._body) };
    }
};

var valuesSourceBase = ValuesSourceBase$4;

const ValuesSourceBase$3 = valuesSourceBase;

const REF_URL$2 =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-composite-aggregation.html#_terms';

/**
 * `TermsValuesSource` is a source for the `CompositeAggregation` that handles
 * terms. It works very similar to a terms aggregation with a slightly different
 * syntax.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-composite-aggregation.html#_terms)
 *
 * @example
 * const valueSrc = esb.CompositeAggregation.termsValuesSource('product').script({
 *   source: "doc['product'].value",
 *   lang: 'painless'
 * });
 *
 * @param {string} name
 * @param {string=} field The field to aggregate on
 *
 * @extends ValuesSourceBase
 */
let TermsValuesSource$1 = class TermsValuesSource extends ValuesSourceBase$3 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field) {
        super('terms', REF_URL$2, name, field);
    }
};

var termsValuesSource = TermsValuesSource$1;

const isNil$n = lodash_isnil;

const ValuesSourceBase$2 = valuesSourceBase;

const REF_URL$1 =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-composite-aggregation.html#_histogram';

/**
 * `HistogramValuesSource` is a source for the `CompositeAggregation` that handles
 * histograms. It works very similar to a histogram aggregation with a slightly
 * different syntax.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-composite-aggregation.html#_histogram)
 *
 * @example
 * const valueSrc = esb.CompositeAggregation.histogramValuesSource(
 *   'histo', // name
 *   'price', // field
 *   5 // interval
 * );
 *
 * @param {string} name
 * @param {string=} field The field to aggregate on
 * @param {number=} interval Interval to generate histogram over.
 *
 * @extends ValuesSourceBase
 */
let HistogramValuesSource$1 = class HistogramValuesSource extends ValuesSourceBase$2 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field, interval) {
        super('histogram', REF_URL$1, name, field);

        if (!isNil$n(interval)) this._opts.interval = interval;
    }

    /**
     * Sets the histogram interval. Buckets are generated based on this interval value.
     *
     * @param {number} interval Interval to generate histogram over.
     * @returns {HistogramValuesSource} returns `this` so that calls can be chained
     */
    interval(interval) {
        this._opts.interval = interval;
        return this;
    }
};

var histogramValuesSource = HistogramValuesSource$1;

const isNil$m = lodash_isnil;

const ValuesSourceBase$1 = valuesSourceBase;

const REF_URL =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-composite-aggregation.html#_date_histogram';

/**
 * `DateHistogramValuesSource` is a source for the `CompositeAggregation` that
 * handles date histograms. It works very similar to a histogram aggregation
 * with a slightly different syntax.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-composite-aggregation.html#_date_histogram)
 *
 * @example
 * const valueSrc = esb.CompositeAggregation.dateHistogramValuesSource(
 *   'date', // name
 *   'timestamp', // field
 *   '1d' // interval
 * );
 *
 * @param {string} name
 * @param {string=} field The field to aggregate on
 * @param {string|number=} interval Interval to generate histogram over.
 *
 * @extends ValuesSourceBase
 */
let DateHistogramValuesSource$1 = class DateHistogramValuesSource extends ValuesSourceBase$1 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field, interval) {
        super('date_histogram', REF_URL, name, field);

        if (!isNil$m(interval)) this._opts.interval = interval;
    }

    /**
     * Sets the histogram interval. Buckets are generated based on this interval value.
     *
     * @param {string|number} interval Interval to generate histogram over.
     * @returns {DateHistogramValuesSource} returns `this` so that calls can be chained
     */
    interval(interval) {
        this._opts.interval = interval;
        return this;
    }

    /**
     * Calendar-aware intervals are configured with the calendarInterval parameter.
     * The combined interval field for date histograms is deprecated from ES 7.2.
     *
     * @example
     * const agg = esb.dateHistogramValuesSource('by_month', 'date').calendarInterval(
     *     'month'
     * );
     *
     * @param {string} interval Interval to generate histogram over.
     * You can specify calendar intervals using the unit name, such as month, or as
     * a single unit quantity, such as 1M. For example, day and 1d are equivalent.
     * Multiple quantities, such as 2d, are not supported.
     * @returns {DateHistogramValuesSource} returns `this` so that calls can be chained
     */
    calendarInterval(interval) {
        this._opts.calendar_interval = interval;
        return this;
    }

    /**
     * Fixed intervals are configured with the fixedInterval parameter.
     * The combined interval field for date histograms is deprecated from ES 7.2.
     *
     * @example
     * const agg = esb.dateHistogramValuesSource('by_minute', 'date').calendarInterval(
     *     '60s'
     * );
     *
     * @param {string} interval Interval to generate histogram over.
     * Intervals are a fixed number of SI units and never deviate, regardless
     * of where they fall on the calendar. However, it means fixed intervals
     * cannot express other units such as months, since the duration of a
     * month is not a fixed quantity.
     * The accepted units for fixed intervals are:
     * millseconds (ms), seconds (s), minutes (m), hours (h) and days (d).
     * @returns {DateHistogramValuesSource} returns `this` so that calls can be chained
     */
    fixedInterval(interval) {
        this._opts.fixed_interval = interval;
        return this;
    }

    /**
     * Sets the date time zone
     *
     * Date-times are stored in Elasticsearch in UTC. By default, all bucketing
     * and rounding is also done in UTC. The `time_zone` parameter can be used
     * to indicate that bucketing should use a different time zone.
     *
     * @param {string} tz Time zone. Time zones may either be specified
     * as an ISO 8601 UTC offset (e.g. +01:00 or -08:00) or as a timezone id,
     * an identifier used in the TZ database like America/Los_Angeles.
     * @returns {DateHistogramValuesSource} returns `this` so that calls can be chained
     */
    timeZone(tz) {
        this._opts.time_zone = tz;
        return this;
    }

    /**
     * Sets the format expression for `key_as_string` in response buckets.
     * If no format is specified, then it will use the first format specified
     * in the field mapping.
     *
     * @example
     * const valueSrc = esb.CompositeAggregation.valuesSource
     *   .dateHistogram('date', 'timestamp', '1d')
     *   .format('yyyy-MM-dd');
     *
     * @param {string} fmt Format mask to apply on aggregation response.
     * For Date Histograms, supports expressive [date format pattern](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-daterange-aggregation.html#date-format-pattern)
     * @returns {DateHistogramValuesSource} returns `this` so that calls can be chained
     */
    format(fmt) {
        this._opts.format = fmt;
        return this;
    }
};

var dateHistogramValuesSource = DateHistogramValuesSource$1;

compositeAggValuesSources.ValuesSourceBase = valuesSourceBase;

compositeAggValuesSources.TermsValuesSource = termsValuesSource;
compositeAggValuesSources.HistogramValuesSource = histogramValuesSource;
compositeAggValuesSources.DateHistogramValuesSource = dateHistogramValuesSource;

const {
    Aggregation: Aggregation$2,
    util: { checkType: checkType$8, constructorWrapper: constructorWrapper$1 }
} = core;

const {
    ValuesSourceBase,
    TermsValuesSource,
    HistogramValuesSource,
    DateHistogramValuesSource
} = compositeAggValuesSources;

/**
 * CompositeAggregation is a multi-bucket values source based aggregation that
 * can be used to calculate unique composite values from source documents.
 *
 * Unlike the other multi-bucket aggregation the composite aggregation can be
 * used to paginate **all** buckets from a multi-level aggregation efficiently.
 * This aggregation provides a way to stream **all** buckets of a specific
 * aggregation similarly to what scroll does for documents.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-composite-aggregation.html)
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *   .agg(
 *     esb.compositeAggregation('my_buckets')
 *       .sources(
 *         esb.CompositeAggregation.termsValuesSource('product', 'product')
 *       )
 *   )
 *
 * NOTE: This query was added in elasticsearch v6.1.
 *
 * @param {string} name a valid aggregation name
 *
 * @extends Aggregation
 */
let CompositeAggregation$1 = class CompositeAggregation extends Aggregation$2 {
    // eslint-disable-next-line require-jsdoc
    constructor(name) {
        super(name, 'composite');

        this._aggsDef.sources = [];
    }

    /**
     * Specifies the Composite Aggregation values sources to use in the
     * aggregation.
     *
     * @example
     * const { CompositeAggregation } = esb;
     * const reqBody = esb.requestBodySearch()
     *   .agg(
     *     esb.compositeAggregation('my_buckets')
     *       .sources(
     *         CompositeAggregation.dateHistogramValuesSource(
     *           'date',
     *           'timestamp',
     *           '1d'
     *         ),
     *         CompositeAggregation.termsValuesSource('product', 'product')
     *       )
     *   );
     *
     * @param {...ValuesSourceBase} sources
     * @returns {CompositeAggregation} returns `this` so that calls can be chained
     * @throws {TypeError} If any of the rest parameters `sources` is not an
     * instance of `ValuesSourceBase`
     */
    sources(...sources) {
        sources.forEach(valueSrc => checkType$8(valueSrc, ValuesSourceBase));

        this._aggsDef.sources = this._aggsDef.sources.concat(sources);
        return this;
    }

    /**
     * Defines how many composite buckets should be returned. Each composite
     * bucket is considered as a single bucket so setting a size of 10 will
     * return the first 10 composite buckets created from the values source. The
     * response contains the values for each composite bucket in an array
     * containing the values extracted from each value source.
     *
     * @param {number} size
     * @returns {CompositeAggregation} returns `this` so that calls can be chained
     */
    size(size) {
        this._aggsDef.size = size;
        return this;
    }

    /**
     * The `after` parameter can be used to retrieve the composite buckets that
     * are after the last composite buckets returned in a previous round.
     *
     * @example
     * const { CompositeAggregation } = esb;
     * const reqBody = esb.requestBodySearch().agg(
     *   esb.compositeAggregation('my_buckets')
     *     .size(2)
     *     .sources(
     *       CompositeAggregation.dateHistogramValuesSource(
     *         'date',
     *         'timestamp',
     *         '1d'
     *       ).order('desc'),
     *       CompositeAggregation.termsValuesSource('product', 'product').order('asc')
     *     )
     *     .after({ date: 1494288000000, product: 'mad max' })
     * );
     *
     * @param {Object} afterKey
     * @returns {CompositeAggregation} returns `this` so that calls can be chained
     */
    after(afterKey) {
        this._aggsDef.after = afterKey;
        return this;
    }
};

CompositeAggregation$1.TermsValuesSource = TermsValuesSource;
CompositeAggregation$1.termsValuesSource = constructorWrapper$1(TermsValuesSource);

CompositeAggregation$1.HistogramValuesSource = HistogramValuesSource;
CompositeAggregation$1.histogramValuesSource = constructorWrapper$1(
    HistogramValuesSource
);

CompositeAggregation$1.DateHistogramValuesSource = DateHistogramValuesSource;
CompositeAggregation$1.dateHistogramValuesSource = constructorWrapper$1(
    DateHistogramValuesSource
);

var compositeAggregation$2 = CompositeAggregation$1;

const HistogramAggregationBase$1 = histogramAggregationBase;

/**
 * A multi-bucket aggregation similar to the histogram except it can only be applied on date values.
 * The interval can be specified by date/time expressions.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-datehistogram-aggregation.html#_scripts)
 *
 * @example
 * const agg = esb.dateHistogramAggregation('sales_over_time', 'date', 'month');
 *
 * @example
 * const agg = esb.dateHistogramAggregation(
 *     'sales_over_time',
 *     'date',
 *     '1M'
 * ).format('yyyy-MM-dd');
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} field The field to aggregate on
 * @param {string=} interval Interval to generate histogram over.
 * Available expressions for interval: year, quarter, month, week, day, hour, minute, second
 *
 * @extends HistogramAggregationBase
 */
let DateHistogramAggregation$1 = class DateHistogramAggregation extends HistogramAggregationBase$1 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field, interval) {
        super(name, 'date_histogram', field, interval);
    }

    /**
     * Date-times are stored in Elasticsearch in UTC.
     * By default, all bucketing and rounding is also done in UTC.
     * The `time_zone` parameter can be used to indicate that bucketing should use a different time zone.
     * Sets the date time zone
     *
     * @example
     * const agg = esb.dateHistogramAggregation('by_day', 'date', 'day').timeZone(
     *     '-01:00'
     * );
     *
     * @param {string} tz Time zone. Time zones may either be specified
     * as an ISO 8601 UTC offset (e.g. +01:00 or -08:00) or as a timezone id,
     * an identifier used in the TZ database like America/Los_Angeles.
     * @returns {DateHistogramAggregation} returns `this` so that calls can be chained
     */
    timeZone(tz) {
        this._aggsDef.time_zone = tz;
        return this;
    }

    /**
     * Calendar-aware intervals are configured with the calendarInterval parameter.
     * The combined interval field for date histograms is deprecated from ES 7.2.
     *
     * @example
     * const agg = esb.dateHistogramAggregation('by_month', 'date').calendarInterval(
     *     'month'
     * );
     *
     * @param {string} interval Interval to generate histogram over.
     * You can specify calendar intervals using the unit name, such as month, or as
     * a single unit quantity, such as 1M. For example, day and 1d are equivalent.
     * Multiple quantities, such as 2d, are not supported.
     * @returns {DateHistogramAggregation} returns `this` so that calls can be chained
     */
    calendarInterval(interval) {
        this._aggsDef.calendar_interval = interval;
        return this;
    }

    /**
     * Fixed intervals are configured with the fixedInterval parameter.
     * The combined interval field for date histograms is deprecated from ES 7.2.
     *
     * @param {string} interval Interval to generate histogram over.
     * Intervals are a fixed number of SI units and never deviate, regardless
     * of where they fall on the calendar. However, it means fixed intervals
     * cannot express other units such as months, since the duration of a
     * month is not a fixed quantity.
     *
     * @example
     * const agg = esb.dateHistogramAggregation('by_minute', 'date').calendarInterval(
     *     '60s'
     * );
     *
     * The accepted units for fixed intervals are:
     * millseconds (ms), seconds (s), minutes (m), hours (h) and days (d).
     * @returns {DateHistogramAggregation} returns `this` so that calls can be chained
     */
    fixedInterval(interval) {
        this._aggsDef.fixed_interval = interval;
        return this;
    }
};

var dateHistogramAggregation$2 = DateHistogramAggregation$1;

const isNil$l = lodash_isnil;

const BucketAggregationBase$e = bucketAggregationBase;

/**
 * A multi-bucket aggregation similar to the Date histogram aggregation except instead of
 * providing an interval to use as the width of each bucket, a target number of buckets
 * is provided indicating the number of buckets needed and the interval of the buckets
 * is automatically chosen to best achieve that target. The number of buckets returned
 * will always be less than or equal to this target number.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-autodatehistogram-aggregation.html)
 *
 * @example
 * const agg = esb.autoDateHistogramAggregation('sales_over_time', 'date', 15);
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string} field The field to aggregate on
 * @param {number} buckets Bucket count to generate histogram over.
 *
 * @extends BucketAggregationBase
 */
let AutoDateHistogramAggregation$1 = class AutoDateHistogramAggregation extends BucketAggregationBase$e {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field, buckets) {
        super(name, 'auto_date_histogram', field);
        if (!isNil$l(buckets)) this._aggsDef.buckets = buckets;
    }

    /**
     * Sets the histogram bucket count. Buckets are generated based on this value.
     *
     * @param {number} buckets Bucket count to generate histogram over.
     * @returns {AutoDateHistogramAggregation} returns `this` so that calls can be chained
     */
    buckets(buckets) {
        this._aggsDef.buckets = buckets;
        return this;
    }

    /**
     * The minimum_interval allows the caller to specify the minimum rounding interval that
     * should be used. This can make the collection process more efficient, as the
     * aggregation will not attempt to round at any interval lower than minimum_interval.
     *
     * Accepted units: year, month, day, hour, minute, second
     *
     * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-autodatehistogram-aggregation.html#_minimum_interval_parameter)
     *
     * @example
     * const agg = esb.autoDateHistogramAggregation(
     *     'sales_over_time',
     *     'date',
     *     5
     * ).minimumInterval('minute');
     *
     * @param {string} interval Minimum Rounding Interval Example: 'minute'
     * @returns {AutoDateHistogramAggregation} returns `this` so that calls can be chained
     */
    minimumInterval(interval) {
        this._aggsDef.minimum_interval = interval;
        return this;
    }

    /**
     * Sets the format expression for `key_as_string` in response buckets.
     * If no format is specified, then it will use the first format specified in the field mapping.
     *
     * @example
     * const agg = esb.autoDateHistogramAggregation(
     *     'sales_over_time',
     *     'date',
     *     5
     * ).format('yyyy-MM-dd');
     *
     * @param {string} fmt Format mask to apply on aggregation response. Example: ####.00.
     * For Date Histograms, supports expressive [date format pattern](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-daterange-aggregation.html#date-format-pattern)
     * @returns {AutoDateHistogramAggregation} returns `this` so that calls can be chained
     */
    format(fmt) {
        this._aggsDef.format = fmt;
        return this;
    }

    /**
     * Sets the missing parameter which defines how documents
     * that are missing a value should be treated.
     *
     * @example
     * const agg = esb.autoDateHistogramAggregation('quantity', 'quantity', 10).missing(0);
     *
     * @param {string} value
     * @returns {AutoDateHistogramAggregation} returns `this` so that calls can be chained
     */
    missing(value) {
        this._aggsDef.missing = value;
        return this;
    }

    /**
     * Date-times are stored in Elasticsearch in UTC.
     * By default, all bucketing and rounding is also done in UTC.
     * The `time_zone` parameter can be used to indicate that bucketing should use a different time zone.
     * Sets the date time zone
     *
     * @example
     * const agg = esb.autoDateHistogramAggregation('by_day', 'date', 15).timeZone(
     *     '-01:00'
     * );
     *
     * @param {string} tz Time zone. Time zones may either be specified
     * as an ISO 8601 UTC offset (e.g. +01:00 or -08:00) or as a timezone id,
     * an identifier used in the TZ database like America/Los_Angeles.
     * @returns {AutoDateHistogramAggregation} returns `this` so that calls can be chained
     */
    timeZone(tz) {
        this._aggsDef.time_zone = tz;
        return this;
    }
};

var autoDateHistogramAggregation$2 = AutoDateHistogramAggregation$1;

const isNil$k = lodash_isnil;

const BucketAggregationBase$d = bucketAggregationBase;

/**
 * This is a multi-bucket aggregation similar to Histogram.
 * However, the width of each bucket is not specified.
 * Rather, a target number of buckets is provided and bucket intervals are dynamically determined based on the document distribution.
 * This is done using a simple one-pass document clustering algorithm that aims to obtain low distances between bucket centroids.
 * Unlike other multi-bucket aggregations, the intervals will not necessarily have a uniform width.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-variablewidthhistogram-aggregation.html)
 *
 * NOTE: Only available in Elasticsearch v7.9.0+
 * @example
 * const agg = esb.variableWidthHistogramAggregation('price', 'lowestPrice', 10)
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string} [field] The field to aggregate on
 * @param {number} [buckets] Bucket count to generate histogram over.
 *
 * @extends BucketAggregationBase
 */
let VariableWidthHistogramAggregation$1 = class VariableWidthHistogramAggregation extends BucketAggregationBase$d {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field, buckets) {
        super(name, 'variable_width_histogram', field);
        if (!isNil$k(buckets)) this._aggsDef.buckets = buckets;
    }

    /**
     * Sets the histogram bucket count. Buckets are generated based on this value.
     *
     * @param {number} buckets Bucket count to generate histogram over.
     * @returns {VariableWidthHistogramAggregation} returns `this` so that calls can be chained
     */
    buckets(buckets) {
        this._aggsDef.buckets = buckets;
        return this;
    }
};

var variableWidthHistogramAggregation$2 = VariableWidthHistogramAggregation$1;

const RangeAggregationBase$3 = rangeAggregationBase;

/**
 * A range aggregation that is dedicated for date values. The main difference
 * between this aggregation and the normal range aggregation is that the from
 * and to values can be expressed in Date Math expressions, and it is also
 * possible to specify a date format by which the from and to response fields
 * will be returned.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-daterange-aggregation.html)
 *
 * @example
 * const agg = esb.dateRangeAggregation('range', 'date')
 *     .format('MM-yyy')
 *     .ranges([{ to: 'now-10M/M' }, { from: 'now-10M/M' }]);
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} field The field to aggregate on
 *
 * @extends RangeAggregationBase
 */
let DateRangeAggregation$1 = class DateRangeAggregation extends RangeAggregationBase$3 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field) {
        super(name, 'date_range', field);
    }

    /**
     * Sets the date time zone.
     * Date-times are stored in Elasticsearch in UTC.
     * By default, all bucketing and rounding is also done in UTC.
     * The `time_zone` parameter can be used to indicate that
     * bucketing should use a different time zone.
     *
     * @example
     * const agg = esb.dateRangeAggregation('range', 'date')
     *     .timeZone('CET')
     *     .ranges([
     *         { to: '2016/02/01' },
     *         { from: '2016/02/01', to: 'now/d' },
     *         { from: 'now/d' }
     *     ]);
     *
     * @param {string} tz Time zone. Time zones may either be specified
     * as an ISO 8601 UTC offset (e.g. +01:00 or -08:00) or as a timezone id,
     * an identifier used in the TZ database like America/Los_Angeles.
     * @returns {DateRangeAggregation} returns `this` so that calls can be chained
     */
    timeZone(tz) {
        this._aggsDef.time_zone = tz;
        return this;
    }
};

var dateRangeAggregation$2 = DateRangeAggregation$1;

const isNil$j = lodash_isnil;

const {
    util: { invalidParam: invalidParam$7 },
    consts: { EXECUTION_HINT_SET }
} = core;

const BucketAggregationBase$c = bucketAggregationBase;

const ES_REF_URL$z =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-diversified-sampler-aggregation.html';

const invalidExecutionHintParam = invalidParam$7(
    ES_REF_URL$z,
    'execution_hint',
    EXECUTION_HINT_SET
);

/**
 * A filtering aggregation used to limit any sub aggregations' processing
 * to a sample of the top-scoring documents. Diversity settings
 * are used to limit the number of matches that share a common value such as an "author".
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-diversified-sampler-aggregation.html)
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .query(esb.queryStringQuery('tags:elasticsearch'))
 *     .agg(
 *         esb.diversifiedSamplerAggregation('my_unbiased_sample', 'author')
 *             .shardSize(200)
 *             .agg(
 *                 esb.significantTermsAggregation(
 *                     'keywords',
 *                     'tags'
 *                 ).exclude(['elasticsearch'])
 *             )
 *     );
 *
 * @example
 * // Use a script to produce a hash of the multiple values in a tags field
 * // to ensure we don't have a sample that consists of the same repeated
 * // combinations of tags
 * const reqBody = esb.requestBodySearch()
 *     .query(esb.queryStringQuery('tags:kibana'))
 *     .agg(
 *         esb.diversifiedSamplerAggregation('my_unbiased_sample')
 *             .shardSize(200)
 *             .maxDocsPerValue(3)
 *             .script(esb.script('inline', "doc['tags'].values.hashCode()"))
 *             .agg(
 *                 esb.significantTermsAggregation(
 *                     'keywords',
 *                     'tags'
 *                 ).exclude(['kibana'])
 *             )
 *     );
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} field The field to aggregate on
 *
 * @extends BucketAggregationBase
 */
let DiversifiedSamplerAggregation$1 = class DiversifiedSamplerAggregation extends BucketAggregationBase$c {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field) {
        super(name, 'diversified_sampler', field);
    }

    /**
     * The shard_size parameter limits how many top-scoring documents
     * are collected in the sample processed on each shard. The default value is 100.
     *
     * @param {number} size Maximum number of documents to return from each shard(Integer)
     * @returns {DiversifiedSamplerAggregation} returns `this` so that calls can be chained
     */
    shardSize(size) {
        this._aggsDef.shard_size = size;
        return this;
    }

    /**
     * Used to control the maximum number of documents collected
     * on any one shard which share a common value.
     * Applies on a per-shard basis only for the purposes of shard-local sampling.
     *
     * @param {number} maxDocsPerValue Default 1.(Integer)
     * @returns {DiversifiedSamplerAggregation} returns `this` so that calls can be chained
     */
    maxDocsPerValue(maxDocsPerValue) {
        this._aggsDef.max_docs_per_value = maxDocsPerValue;
        return this;
    }

    /**
     * This setting can influence the management of the values used
     * for de-duplication. Each option will hold up to shard_size
     * values in memory while performing de-duplication but
     * the type of value held can be controlled
     *
     * @param {string} hint the possible values are `map`, `global_ordinals`,
     * `global_ordinals_hash` and `global_ordinals_low_cardinality`
     * @returns {DiversifiedSamplerAggregation} returns `this` so that calls can be chained
     * @throws {Error} If Execution Hint is outside the accepted set.
     */
    executionHint(hint) {
        if (isNil$j(hint)) invalidExecutionHintParam(hint);

        const hintLower = hint.toLowerCase();
        if (!EXECUTION_HINT_SET.has(hintLower)) {
            invalidExecutionHintParam(hint);
        }

        this._aggsDef.execution_hint = hintLower;
        return this;
    }
};

var diversifiedSamplerAggregation$2 = DiversifiedSamplerAggregation$1;

const isNil$i = lodash_isnil;

const {
    Query: Query$2,
    util: { checkType: checkType$7 }
} = core;

const BucketAggregationBase$b = bucketAggregationBase;

const ES_REF_URL$y =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-filter-aggregation.html';

/**
 * Defines a single bucket of all the documents in the current document set
 * context that match a specified filter. Often this will be used to narrow down
 * the current aggregation context to a specific set of documents.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-filter-aggregation.html)
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .agg(
 *         esb.filterAggregation(
 *             't_shirts',
 *             esb.termQuery('type', 't-shirt')
 *         ).agg(esb.avgAggregation('avg_price', 'price'))
 *     )
 *     .size(0);
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {Query=} filterQuery Query to filter on. Example - term query.
 *
 * @extends BucketAggregationBase
 */
let FilterAggregation$1 = class FilterAggregation extends BucketAggregationBase$b {
    // eslint-disable-next-line require-jsdoc
    constructor(name, filterQuery) {
        super(name, 'filter');

        if (!isNil$i(filterQuery)) this.filter(filterQuery);
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on FilterAggregation
     */
    field() {
        console.log(`Please refer ${ES_REF_URL$y}`);
        throw new Error('field is not supported in FilterAggregation');
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on FilterAggregation
     */
    script() {
        console.log(`Please refer ${ES_REF_URL$y}`);
        throw new Error('script is not supported in FilterAggregation');
    }

    // NOTE: Special case. filter does not set a key inside
    // this._aggsDef but sets the entire object itself
    // Generic getOpt will fail for this.
    // Just a simple override should handle it though

    /**
     * Set the filter query for Filter Aggregation.
     *
     * @param {Query} filterQuery Query to filter on. Example - term query.
     * @returns {FilterAggregation} returns `this` so that calls can be chained
     * @throws {TypeError} If `filterQuery` is not an instance of `Query`
     */
    filter(filterQuery) {
        checkType$7(filterQuery, Query$2);
        this._aggsDef = this._aggs[this.aggType] = filterQuery;
        return this;
    }
};

var filterAggregation$2 = FilterAggregation$1;

const isEmpty = lodash_isemptyExports;

const {
    Query: Query$1,
    util: { checkType: checkType$6, setDefault: setDefault$2 }
} = core;

const BucketAggregationBase$a = bucketAggregationBase;

const ES_REF_URL$x =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-filters-aggregation.html';

/**
 * Defines a single bucket of all the documents in the current document set
 * context that match a specified filter. Often this will be used to narrow down
 * the current aggregation context to a specific set of documents.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-filters-aggregation.html)
 *
 * @example
 * const agg = esb.filtersAggregation('messages')
 *     .filter('errors', esb.matchQuery('body', 'error'))
 *     .filter('warnings', esb.matchQuery('body', 'warning'));
 *
 *
 * @example
 * const agg = esb.filtersAggregation('messages')
 *     .anonymousFilters([
 *         esb.matchQuery('body', 'error'),
 *         esb.matchQuery('body', 'warning')
 *     ])
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 *
 * @extends BucketAggregationBase
 */
let FiltersAggregation$1 = class FiltersAggregation extends BucketAggregationBase$a {
    // eslint-disable-next-line require-jsdoc
    constructor(name) {
        super(name, 'filters');
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on FiltersAggregation
     */
    field() {
        console.log(`Please refer ${ES_REF_URL$x}`);
        throw new Error('field is not supported in FiltersAggregation');
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on FiltersAggregation
     */
    script() {
        console.log(`Please refer ${ES_REF_URL$x}`);
        throw new Error('script is not supported in FiltersAggregation');
    }

    /**
     * Print warning message to console namespaced by class name.
     *
     * @param {string} msg
     * @private
     */
    _warn(msg) {
        console.warn(`[FiltersAggregation] ${msg}`);
    }

    /**
     * Check and puts an object for the `filters` key in
     * internal aggregation representation object.
     * If the key has a value but is not an object,
     * a warning is printed.
     * @private
     */
    _checkNamedFilters() {
        if (
            !setDefault$2(this._aggsDef, 'filters', {}) &&
            Array.isArray(this._aggsDef.filters)
        ) {
            this._warn('Do not mix named and anonymous filters!');
            this._warn('Overwriting anonymous filters.');
            this._aggsDef.filters = {};
        }
    }

    /**
     * Check and puts an array for the `filters` key in
     * internal aggregation representation object.
     * If the key has a value but is not an array,
     * a warning is printed.
     * @private
     */
    _checkAnonymousFilters() {
        if (
            !setDefault$2(this._aggsDef, 'filters', []) &&
            !Array.isArray(this._aggsDef.filters)
        ) {
            this._warn('Do not mix named and anonymous filters!');
            this._warn('Overwriting named filters.');
            this._aggsDef.filters = [];
        }
    }

    /**
     * Sets a named filter query.
     * Does not mix with anonymous filters.
     * If anonymous filters are present, they will be overwritten.
     *
     * @param {string} bucketName Name for bucket which will collect
     * all documents that match its associated filter.
     * @param {Query} filterQuery Query to filter on. Example - term query.
     * @returns {FiltersAggregation} returns `this` so that calls can be chained
     * @throws {TypeError} If `filterQuery` is not an instance of `Query`
     */
    filter(bucketName, filterQuery) {
        checkType$6(filterQuery, Query$1);

        this._checkNamedFilters();

        this._aggsDef.filters[bucketName] = filterQuery;
        return this;
    }

    /**
     * Assigns filters to already added filters.
     * Does not mix with anonymous filters.
     * If anonymous filters are present, they will be overwritten.
     *
     * @param {Object} filterQueries Object with multiple key value pairs
     * where bucket name is the key and filter query is the value.
     * @returns {FiltersAggregation} returns `this` so that calls can be chained
     * @throws {TypeError} If `filterQueries` is not an instance of object
     */
    filters(filterQueries) {
        checkType$6(filterQueries, Object);

        this._checkNamedFilters();

        Object.assign(this._aggsDef.filters, filterQueries);
        return this;
    }

    /**
     * Appends an anonymous filter query.
     * Does not mix with named filters.
     * If named filters are present, they will be overwritten.
     *
     * @param {*} filterQuery Query to filter on. Example - term query.
     * @returns {FiltersAggregation} returns `this` so that calls can be chained
     * @throws {TypeError} If `filterQuery` is not an instance of `Query`
     */
    anonymousFilter(filterQuery) {
        checkType$6(filterQuery, Query$1);

        this._checkAnonymousFilters();

        this._aggsDef.filters.push(filterQuery);
        return this;
    }

    /**
     * Appends an array of anonymous filters.
     * Does not mix with named filters.
     * If named filters are present, they will be overwritten.
     *
     * @param {*} filterQueries Array of queries to filter on and generate buckets.
     * Example - term query.
     * @returns {FiltersAggregation} returns `this` so that calls can be chained
     * @throws {TypeError} If `filterQueries` is not an instance of Array
     */
    anonymousFilters(filterQueries) {
        checkType$6(filterQueries, Array);

        this._checkAnonymousFilters();

        this._aggsDef.filters = this._aggsDef.filters.concat(filterQueries);
        return this;
    }

    /**
     * Adds a bucket to the response which will contain all documents
     * that do not match any of the given filters.
     * Returns the other bucket bucket either in a bucket
     * (named `_other_` by default) if named filters are being used,
     * or as the last bucket if anonymous filters are being used
     *
     * @param {boolean} enable `True` to return `other` bucket with documents
     * that do not match any filters and `False` to disable computation
     * @param {string=} otherBucketKey Optional key for the other bucket.
     * Default is `_other_`.
     * @returns {FiltersAggregation} returns `this` so that calls can be chained
     */
    otherBucket(enable, otherBucketKey) {
        this._aggsDef.other_bucket = enable;

        !isEmpty(otherBucketKey) && this.otherBucketKey(otherBucketKey);

        return this;
    }

    /**
     * Sets the key for the other bucket to a value other than the default `_other_`.
     * Setting this parameter will implicitly set the other_bucket parameter to true.
     * If anonymous filters are being used, setting this parameter will not make sense.
     *
     * @example
     * const agg = esb.filtersAggregation('messages')
     *     .filter('errors', esb.matchQuery('body', 'error'))
     *     .filter('warnings', esb.matchQuery('body', 'warning'))
     *     .otherBucketKey('other_messages');
     *
     * @param {string} otherBucketKey
     * @returns {FiltersAggregation} returns `this` so that calls can be chained
     */
    otherBucketKey(otherBucketKey) {
        this._aggsDef.other_bucket_key = otherBucketKey;
        return this;
    }
};

var filtersAggregation$2 = FiltersAggregation$1;

const isNil$h = lodash_isnil;

const {
    GeoPoint: GeoPoint$2,
    util: { checkType: checkType$5, invalidParam: invalidParam$6 },
    consts: { UNIT_SET }
} = core;

const RangeAggregationBase$2 = rangeAggregationBase;

const ES_REF_URL$w =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-geodistance-aggregation.html';

const invalidUnitParam = invalidParam$6(ES_REF_URL$w, 'unit', UNIT_SET);
const invalidDistanceTypeParam = invalidParam$6(
    ES_REF_URL$w,
    'distance_type',
    "'plane' or 'arc'"
);

/**
 * A multi-bucket aggregation that works on geo_point fields and conceptually
 * works very similar to the range aggregation. The user can define a point of
 * origin and a set of distance range buckets. The aggregation evaluate the
 * distance of each document value from the origin point and determines the
 * buckets it belongs to based on the ranges (a document belongs to a bucket
 * if the distance between the document and the origin falls within the distance
 * range of the bucket).
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-geodistance-aggregation.html)
 *
 * @example
 * const agg = esb.geoDistanceAggregation('rings_around_amsterdam', 'location')
 *     .origin(esb.geoPoint().string('52.3760, 4.894'))
 *     .ranges([{ to: 100000 }, { from: 100000, to: 300000 }, { from: 300000 }]);
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} field The field to aggregate on
 *
 * @extends RangeAggregationBase
 */
let GeoDistanceAggregation$1 = class GeoDistanceAggregation extends RangeAggregationBase$2 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field) {
        super(name, 'geo_distance', field);
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on GeoDistanceAggregation
     */
    format() {
        console.log(`Please refer ${ES_REF_URL$w}`);
        throw new Error('format is not supported in GeoDistanceAggregation');
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on GeoDistanceAggregation
     */
    script() {
        console.log(`Please refer ${ES_REF_URL$w}`);
        throw new Error('script is not supported in GeoDistanceAggregation');
    }

    /**
     * Sets the point of origin from where distances will be measured.
     *
     * @param {GeoPoint} point A valid `GeoPoint` object.
     * @returns {GeoDistanceAggregation} returns `this` so that calls can be chained
     * @throws {TypeError} If `point` is not an instance of `GeoPoint`
     */
    origin(point) {
        checkType$5(point, GeoPoint$2);

        this._aggsDef.origin = point;
        return this;
    }

    /**
     * Sets the distance unit.  Valid values are:
     * mi (miles), in (inches), yd (yards),
     * km (kilometers), cm (centimeters), mm (millimeters),
     * ft(feet), NM(nauticalmiles)
     *
     * @example
     * const agg = esb.geoDistanceAggregation('rings_around_amsterdam', 'location')
     *     .origin(esb.geoPoint().string('52.3760, 4.894'))
     *     .unit('km')
     *     .ranges([{ to: 100 }, { from: 100, to: 300 }, { from: 300 }]);
     *
     * @param {string} unit Distance unit, default is `m`(meters).
     * @returns {GeoDistanceAggregation} returns `this` so that calls can be chained
     * @throws {Error} If Unit is outside the accepted set.
     */
    unit(unit) {
        if (!UNIT_SET.has(unit)) {
            invalidUnitParam(unit);
        }

        this._aggsDef.unit = unit;
        return this;
    }

    /**
     * Sets the distance calculation mode, `arc` or `plane`.
     * The `arc` calculation is the more accurate.
     * The `plane` is the faster but least accurate.
     *
     * @example
     * const agg = esb.geoDistanceAggregation('rings_around_amsterdam', 'location')
     *     .origin(esb.geoPoint().string('52.3760, 4.894'))
     *     .unit('km')
     *     .distanceType('plane')
     *     .ranges([{ to: 100 }, { from: 100, to: 300 }, { from: 300 }]);
     *
     * @param {string} type
     * @returns {GeoDistanceAggregation} returns `this` so that calls can be chained
     * @throws {Error} If `type` is neither `plane` nor `arc`.
     */
    distanceType(type) {
        if (isNil$h(type)) invalidDistanceTypeParam(type);

        const typeLower = type.toLowerCase();
        if (typeLower !== 'plane' && typeLower !== 'arc')
            invalidDistanceTypeParam(type);

        this._aggsDef.distance_type = typeLower;
        return this;
    }
};

var geoDistanceAggregation$2 = GeoDistanceAggregation$1;

const isNil$g = lodash_isnil;

const BucketAggregationBase$9 = bucketAggregationBase;

const ES_REF_URL$v =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-geohashgrid-aggregation.html';

/**
 * A multi-bucket aggregation that works on geo_point fields and groups points
 * into buckets that represent cells in a grid. The resulting grid can be sparse
 * and only contains cells that have matching data. Each cell is labeled using a
 * geohash which is of user-definable precision.

 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-geohashgrid-aggregation.html)
 *
 * @example
 * const agg = esb.geoHashGridAggregation('large-grid', 'location').precision(3);
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} field The field to aggregate on
 *
 * @extends BucketAggregationBase
 */
let GeoHashGridAggregation$1 = class GeoHashGridAggregation extends BucketAggregationBase$9 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field) {
        super(name, 'geohash_grid', field);
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on GeoHashGridAggregation
     */
    format() {
        console.log(`Please refer ${ES_REF_URL$v}`);
        throw new Error('format is not supported in GeoHashGridAggregation');
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on GeoHashGridAggregation
     */
    script() {
        console.log(`Please refer ${ES_REF_URL$v}`);
        throw new Error('script is not supported in GeoHashGridAggregation');
    }

    /**
     * Sets the precision for the generated geohash.
     *
     * @param {number} precision Precision can be between 1 and 12
     * @returns {GeoHashGridAggregation} returns `this` so that calls can be chained
     * @throws {Error} If precision is not between 1 and 12.
     */
    precision(precision) {
        if (isNil$g(precision) || precision < 1 || precision > 12) {
            throw new Error('`precision` can only be value from 1 to 12.');
        }

        this._aggsDef.precision = precision;
        return this;
    }

    /**
     * Sets the maximum number of geohash buckets to return.
     * When results are trimmed, buckets are prioritised
     * based on the volumes of documents they contain.
     *
     * @param {number} size Optional. The maximum number of geohash
     * buckets to return (defaults to 10,000).
     * @returns {GeoHashGridAggregation} returns `this` so that calls can be chained
     */
    size(size) {
        this._aggsDef.size = size;
        return this;
    }

    /**
     * Determines how many geohash_grid the coordinating node
     * will request from each shard.
     *
     * @param {number} shardSize Optional.
     * @returns {GeoHashGridAggregation} returns `this` so that calls can be chained
     */
    shardSize(shardSize) {
        this._aggsDef.shard_size = shardSize;
        return this;
    }
};

var geoHashGridAggregation$2 = GeoHashGridAggregation$1;

const isNil$f = lodash_isnil;

const BucketAggregationBase$8 = bucketAggregationBase;

const ES_REF_URL$u =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-geohexgrid-aggregation.html';

/**
 * A multi-bucket aggregation that groups geo_point and geo_shape values into buckets
 * that represent a grid. The resulting grid can be sparse and only contains cells
 * that have matching data. Each cell corresponds to a H3 cell index and is labeled
 * using the H3Index representation.

 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-geohexgrid-aggregation.html)
 *
 * NOTE: This aggregation was added in elasticsearch v8.1.0.
 *
 * @example
 * const agg = esb.geoHexGridAggregation('hex-grid', 'location').precision(3);
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} field The field to aggregate on
 *
 * @extends BucketAggregationBase
 */
let GeoHexGridAggregation$1 = class GeoHexGridAggregation extends BucketAggregationBase$8 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field) {
        super(name, 'geohex_grid', field);
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on GeoHexGridAggregation
     */
    format() {
        console.log(`Please refer ${ES_REF_URL$u}`);
        throw new Error('format is not supported in GeoHexGridAggregation');
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on GeoHexGridAggregation
     */
    script() {
        console.log(`Please refer ${ES_REF_URL$u}`);
        throw new Error('script is not supported in GeoHexGridAggregation');
    }

    /**
     * Sets the precision for the generated geohex.
     *
     * @param {number} precision Precision can be between 0 and 15
     * @returns {GeoHexGridAggregation} returns `this` so that calls can be chained
     * @throws {Error} If precision is not between 0 and 15.
     */
    precision(precision) {
        if (isNil$f(precision) || precision < 0 || precision > 15) {
            throw new Error('`precision` can only be value from 0 to 15.');
        }

        this._aggsDef.precision = precision;
        return this;
    }

    /**
     * Sets the maximum number of geohex buckets to return.
     * When results are trimmed, buckets are prioritised
     * based on the volumes of documents they contain.
     *
     * @param {number} size Optional. The maximum number of geohex
     * buckets to return (defaults to 10,000).
     * @returns {GeoHexGridAggregation} returns `this` so that calls can be chained
     */
    size(size) {
        this._aggsDef.size = size;
        return this;
    }

    /**
     * Determines how many geohex_grid the coordinating node
     * will request from each shard.
     *
     * @param {number} shardSize Optional.
     * @returns {GeoHexGridAggregation} returns `this` so that calls can be chained
     */
    shardSize(shardSize) {
        this._aggsDef.shard_size = shardSize;
        return this;
    }
};

var geoHexGridAggregation$2 = GeoHexGridAggregation$1;

const isNil$e = lodash_isnil;

const {
    GeoPoint: GeoPoint$1,
    util: { checkType: checkType$4, setDefault: setDefault$1 }
} = core;

const BucketAggregationBase$7 = bucketAggregationBase;

const ES_REF_URL$t =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-geotilegrid-aggregation.html';

/**
 * A multi-bucket aggregation that works on geo_point fields and groups points
 * into buckets that represent cells in a grid. The resulting grid can be sparse
 * and only contains cells that have matching data. Each cell corresponds to a
 * map tile as used by many online map sites. Each cell is labeled using a
 * "{zoom}/{x}/{y}" format, where zoom is equal to the user-specified precision.

 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-geotilegrid-aggregation.html)
 *
 * NOTE: This query was added in elasticsearch v7.0.
 *
 * @example
 * const agg = esb.geoTileGridAggregation('large-grid', 'location').precision(8);
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} field The field to aggregate on
 *
 * @extends BucketAggregationBase
 */
let GeoTileGridAggregation$1 = class GeoTileGridAggregation extends BucketAggregationBase$7 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field) {
        super(name, 'geotile_grid', field);
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on GeoTileGridAggregation
     */
    format() {
        console.log(`Please refer ${ES_REF_URL$t}`);
        throw new Error('format is not supported in GeoTileGridAggregation');
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on GeoTileGridAggregation
     */
    script() {
        console.log(`Please refer ${ES_REF_URL$t}`);
        throw new Error('script is not supported in GeoTileGridAggregation');
    }

    /**
     * The integer zoom of the key used to define cells/buckets in the results.
     * Defaults to 7.
     *
     * @param {number} precision Precision can be between 0 and 29
     * @returns {GeoTileGridAggregation} returns `this` so that calls can be chained
     * @throws {Error} If precision is not between 0 and 29.
     */
    precision(precision) {
        if (isNil$e(precision) || precision < 0 || precision > 29) {
            throw new Error('`precision` can only be value from 0 to 29.');
        }

        this._aggsDef.precision = precision;
        return this;
    }

    /**
     * Sets the maximum number of geotile buckets to return.
     * When results are trimmed, buckets are prioritised
     * based on the volumes of documents they contain.
     *
     * @param {number} size Optional. The maximum number of geotile
     * buckets to return (defaults to 10,000).
     * @returns {GeoTileGridAggregation} returns `this` so that calls can be chained
     */
    size(size) {
        this._aggsDef.size = size;
        return this;
    }

    /**
     * Determines how many geotile_grid buckets the coordinating node
     * will request from each shard. To allow for more accurate counting of the
     * top cells returned in the final result the aggregation defaults to
     * returning `max(10,(size x number-of-shards))` buckets from each shard.
     * If this heuristic is undesirable, the number considered from each shard
     * can be over-ridden using this parameter.
     *
     * @param {number} shardSize Optional.
     * @returns {GeoTileGridAggregation} returns `this` so that calls can be chained
     */
    shardSize(shardSize) {
        this._aggsDef.shard_size = shardSize;
        return this;
    }

    /**
     * Sets the top left coordinate for the bounding box used to filter the
     * points in the bucket.
     *
     * @param {GeoPoint} point A valid `GeoPoint`
     * @returns {GeoTileGridAggregation} returns `this` so that calls can be chained.
     */
    topLeft(point) {
        checkType$4(point, GeoPoint$1);
        setDefault$1(this._aggsDef, 'bounds', {});
        this._aggsDef.bounds.top_left = point;
        return this;
    }

    /**
     * Sets the bottom right coordinate for the bounding box used to filter the
     * points in the bucket.
     *
     * @param {GeoPoint} point A valid `GeoPoint`
     * @returns {GeoTileGridAggregation} returns `this` so that calls can be chained.
     */
    bottomRight(point) {
        checkType$4(point, GeoPoint$1);
        setDefault$1(this._aggsDef, 'bounds', {});
        this._aggsDef.bounds.bottom_right = point;
        return this;
    }

    /**
     * Sets the top right coordinate for the bounding box used to filter the
     * points in the bucket.
     *
     * @param {GeoPoint} point A valid `GeoPoint`
     * @returns {GeoTileGridAggregation} returns `this` so that calls can be chained.
     */
    topRight(point) {
        checkType$4(point, GeoPoint$1);
        setDefault$1(this._aggsDef, 'bounds', {});
        this._aggsDef.bounds.top_right = point;
        return this;
    }

    /**
     * Sets the bottom left coordinate for the bounding box used to filter the
     * points in the bucket.
     *
     * @param {GeoPoint} point A valid `GeoPoint`
     * @returns {GeoTileGridAggregation} returns `this` so that calls can be chained.
     */
    bottomLeft(point) {
        checkType$4(point, GeoPoint$1);
        setDefault$1(this._aggsDef, 'bounds', {});
        this._aggsDef.bounds.bottom_left = point;
        return this;
    }

    /**
     * Sets value for top of the bounding box.
     *
     * @param {number} val
     * @returns {GeoTileGridAggregation} returns `this` so that calls can be chained.
     */
    top(val) {
        setDefault$1(this._aggsDef, 'bounds', {});
        this._aggsDef.bounds.top = val;
        return this;
    }

    /**
     * Sets value for left of the bounding box.
     *
     * @param {number} val
     * @returns {GeoTileGridAggregation} returns `this` so that calls can be chained.
     */
    left(val) {
        setDefault$1(this._aggsDef, 'bounds', {});
        this._aggsDef.bounds.left = val;
        return this;
    }

    /**
     * Sets value for bottom of the bounding box.
     *
     * @param {number} val
     * @returns {GeoTileGridAggregation} returns `this` so that calls can be chained.
     */
    bottom(val) {
        setDefault$1(this._aggsDef, 'bounds', {});
        this._aggsDef.bounds.bottom = val;
        return this;
    }

    /**
     * Sets value for right of the bounding box.
     *
     * @param {number} val
     * @returns {GeoTileGridAggregation} returns `this` so that calls can be chained.
     */
    right(val) {
        setDefault$1(this._aggsDef, 'bounds', {});
        this._aggsDef.bounds.right = val;
        return this;
    }
};

var geoTileGridAggregation$2 = GeoTileGridAggregation$1;

const BucketAggregationBase$6 = bucketAggregationBase;

const ES_REF_URL$s =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-global-aggregation.html';

/**
 * Defines a single bucket of all the documents within the search execution
 * context. This context is defined by the indices and the document types youre
 * searching on, but is not influenced by the search query itself.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-global-aggregation.html)
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .query(esb.matchQuery('type', 't-shirt'))
 *     .agg(
 *         esb.globalAggregation('all_products').agg(
 *             esb.avgAggregation('avg_price', 'price')
 *         )
 *     )
 *     .agg(esb.avgAggregation('t_shirts', 'price'));
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 *
 * @extends BucketAggregationBase
 */
let GlobalAggregation$1 = class GlobalAggregation extends BucketAggregationBase$6 {
    // eslint-disable-next-line require-jsdoc
    constructor(name) {
        super(name, 'global');
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on GlobalAggregation
     */
    field() {
        console.log(`Please refer ${ES_REF_URL$s}`);
        throw new Error('field is not supported in GlobalAggregation');
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on GlobalAggregation
     */
    script() {
        console.log(`Please refer ${ES_REF_URL$s}`);
        throw new Error('script is not supported in GlobalAggregation');
    }
};

var globalAggregation$2 = GlobalAggregation$1;

const HistogramAggregationBase = histogramAggregationBase;

/**
 * A multi-bucket values source based aggregation that can be applied on
 * numeric values extracted from the documents. It dynamically builds fixed
 * size (a.k.a. interval) buckets over the values.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-histogram-aggregation.html)
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} field The field to aggregate on
 * @param {number=} interval Interval to generate histogram over.
 *
 * @example
 * const agg = esb.histogramAggregation('prices', 'price', 50);
 *
 * @example
 * const agg = esb.histogramAggregation('prices', 'price', 50).minDocCount(1);
 *
 * @example
 * const agg = esb.histogramAggregation('prices', 'price', 50)
 *     .extendedBounds(0, 500);
 *
 * @example
 * const agg = esb.histogramAggregation('quantity', 'quantity', 10).missing(0);
 *
 * @extends HistogramAggregationBase
 */
let HistogramAggregation$1 = class HistogramAggregation extends HistogramAggregationBase {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field, interval) {
        super(name, 'histogram', field, interval);
    }
};

var histogramAggregation$2 = HistogramAggregation$1;

const RangeAggregationBase$1 = rangeAggregationBase;

const ES_REF_URL$r =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-iprange-aggregation.html';

/**
 * Dedicated range aggregation for IP typed fields.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/5current/search-aggregations-bucket-iprange-aggregation.html)
 *
 * @example
 * const agg = esb.ipRangeAggregation('ip_ranges', 'ip').ranges([
 *     { to: '10.0.0.5' },
 *     { from: '10.0.0.5' }
 * ]);
 *
 * @example
 * const agg = esb.ipRangeAggregation('ip_ranges', 'ip').ranges([
 *     { mask: '10.0.0.0/25' },
 *     { mask: '10.0.0.127/25' }
 * ]);
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} field The field to aggregate on
 *
 * @extends RangeAggregationBase
 */
let IpRangeAggregation$1 = class IpRangeAggregation extends RangeAggregationBase$1 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field) {
        super(name, 'ip_range', field);
        // Variable name is misleading. Only one of these needs to be present.
        this._rangeRequiredKeys = ['from', 'to', 'mask'];
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on IpRangeAggregation
     */
    format() {
        console.log(`Please refer ${ES_REF_URL$r}`);
        throw new Error('format is not supported in IpRangeAggregation');
    }
};

var ipRangeAggregation$2 = IpRangeAggregation$1;

const BucketAggregationBase$5 = bucketAggregationBase;

const ES_REF_URL$q =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-missing-aggregation.html';

/**
 * A field data based single bucket aggregation, that creates a bucket of all
 * documents in the current document set context that are missing a field value
 * (effectively, missing a field or having the configured NULL value set).
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-missing-aggregation.html)
 *
 * @example
 * const agg = esb.missingAggregation('products_without_a_price', 'price');
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} field The field to aggregate on
 *
 * @extends BucketAggregationBase
 */
let MissingAggregation$1 = class MissingAggregation extends BucketAggregationBase$5 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field) {
        super(name, 'missing', field);
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on MissingAggregation
     */
    script() {
        console.log(`Please refer ${ES_REF_URL$q}`);
        throw new Error('script is not supported in MissingAggregation');
    }
};

var missingAggregation$2 = MissingAggregation$1;

const isNil$d = lodash_isnil;

const BucketAggregationBase$4 = bucketAggregationBase;

const ES_REF_URL$p =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-nested-aggregation.html';

/**
 * A special single bucket aggregation that enables aggregating nested
 * documents.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-nested-aggregation.html)
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .query(esb.matchQuery('name', 'led tv'))
 *     .agg(
 *         esb.nestedAggregation('resellers', 'resellers').agg(
 *             esb.minAggregation('min_price', 'resellers.price')
 *         )
 *     );
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} path `path` of the nested document
 *
 * @extends BucketAggregationBase
 */
let NestedAggregation$1 = class NestedAggregation extends BucketAggregationBase$4 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, path) {
        super(name, 'nested');

        if (!isNil$d(path)) this._aggsDef.path = path;
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on NestedAggregation
     */
    field() {
        console.log(`Please refer ${ES_REF_URL$p}`);
        throw new Error('field is not supported in NestedAggregation');
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on NestedAggregation
     */
    script() {
        console.log(`Please refer ${ES_REF_URL$p}`);
        throw new Error('script is not supported in NestedAggregation');
    }

    /**
     * Sets the nested path
     *
     * @param {string} path `path` of the nested document
     * @returns {NestedAggregation} returns `this` so that calls can be chained
     */
    path(path) {
        this._aggsDef.path = path;
        return this;
    }
};

var nestedAggregation$2 = NestedAggregation$1;

const isNil$c = lodash_isnil;

const BucketAggregationBase$3 = bucketAggregationBase;

const ES_REF_URL$o =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-parent-aggregation.html';

/**
 * A special single bucket aggregation that enables aggregating
 * from buckets on child document types to buckets on parent documents.
 *
 * This aggregation relies on the `_parent` field in the mapping.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-parent-aggregation.html)
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .agg(
 *         esb.termsAggregation('top-names', 'owner.display_name.keyword')
 *             .size(10)
 *             .agg(
 *                 esb.parentAggregation('to-questions')
 *                     .type('answer')
 *                     .agg(
 *                         esb.termsAggregation(
 *                             'top-tags',
 *                             'tags.keyword'
 *                         ).size(10)
 *                     )
 *             )
 *     )
 *     .size(0);
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} type The type of the child document.
 *
 * @extends BucketAggregationBase
 */
let ParentAggregation$1 = class ParentAggregation extends BucketAggregationBase$3 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, type) {
        super(name, 'parent');

        if (!isNil$c(type)) this.type(type);
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on ParentAggregation
     */
    field() {
        console.log(`Please refer ${ES_REF_URL$o}`);
        throw new Error('field is not supported in ParentAggregation');
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on ParentAggregation
     */
    script() {
        console.log(`Please refer ${ES_REF_URL$o}`);
        throw new Error('script is not supported in ParentAggregation');
    }

    /**
     * Sets the child type/mapping for aggregation.
     *
     * @param {string} type The child type that the buckets in the parent space should be mapped to.
     * @returns {ParentAggregation} returns `this` so that calls can be chained
     */
    type(type) {
        this._aggsDef.type = type;
        return this;
    }
};

var parentAggregation$2 = ParentAggregation$1;

const RangeAggregationBase = rangeAggregationBase;

/**
 * A multi-bucket value source based aggregation that enables the user to
 * define a set of ranges - each representing a bucket. During the aggregation
 * process, the values extracted from each document will be checked against each
 * bucket range and "bucket" the relevant/matching document.
 *
 * Note that this aggregration includes the from value and excludes the to
 * value for each range.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-range-aggregation.html)
 *
 * @example
 * const agg = esb.rangeAggregation('price_ranges', 'price').ranges([
 *     { to: 50 },
 *     { from: 50, to: 100 },
 *     { from: 100 }
 * ]);
 *
 * @example
 * const agg = esb.rangeAggregation('price_ranges')
 *     .script(esb.script('inline', "doc['price'].value").lang('painless'))
 *     .ranges([{ to: 50 }, { from: 50, to: 100 }, { from: 100 }]);
 *
 * @example
 * // Value script for on-the-fly conversion before aggregation
 * const agg = esb.rangeAggregation('price_ranges', 'price')
 *     .script(
 *         esb.script('inline', '_value * params.conversion_rate')
 *             .lang('painless')
 *             .params({ conversion_rate: 0.8 })
 *     )
 *     .ranges([{ to: 50 }, { from: 50, to: 100 }, { from: 100 }]);
 *
 * @example
 * // Compute statistics over the prices in each price range
 * const agg = esb.rangeAggregation('price_ranges', 'price')
 *     .ranges([{ to: 50 }, { from: 50, to: 100 }, { from: 100 }])
 *     // Passing price to Stats Aggregation is optional(same value source)
 *     .agg(esb.statsAggregation('price_stats', 'price'));
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} field The field to aggregate on
 *
 * @extends RangeAggregationBase
 */
let RangeAggregation$1 = class RangeAggregation extends RangeAggregationBase {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field) {
        super(name, 'range', field);
    }
};

var rangeAggregation$2 = RangeAggregation$1;

const isNil$b = lodash_isnil;

const BucketAggregationBase$2 = bucketAggregationBase;

const ES_REF_URL$n =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-rare-terms-aggregation.html';

/**
 * A multi-bucket value source based aggregation which finds
 * "rare" terms  terms that are at the long-tail of the
 * distribution and are not frequent. Conceptually, this is like
 * a terms aggregation that is sorted by `_count` ascending.
 * As noted in the terms aggregation docs, actually ordering
 * a `terms` agg by count ascending has unbounded error.
 * Instead, you should use the `rare_terms` aggregation
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-rare-terms-aggregation.html)
 *
 * NOTE: Only available in Elasticsearch 7.3.0+.
 *
 * @example
 * const agg = esb.rareTermsAggregation('genres', 'genre');
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string} field The field we wish to find rare terms in
 *
 * @extends BucketAggregationBase
 */
let RareTermsAggregation$1 = class RareTermsAggregation extends BucketAggregationBase$2 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field) {
        super(name, 'rare_terms', field);
    }

    /**
     * Sets the maximum number of documents a term should appear in.
     *
     * @example
     * const agg = esb.rareTermsAggregation('genres', 'genre').maxDocCount(2);
     *
     * @param {number} maxDocCnt Integer value for maximum number of documents a term should appear in.
     * Max doc count can be between 1 and 100.
     * @returns {RareTermsAggregation} returns `this` so that calls can be chained
     */
    maxDocCount(maxDocCnt) {
        if (isNil$b(maxDocCnt) || maxDocCnt < 1 || maxDocCnt > 100) {
            throw new Error('`maxDocCount` can only be value from 1 to 100.');
        }

        this._aggsDef.max_doc_count = maxDocCnt;
        return this;
    }

    /**
     * Sets the precision of the internal CuckooFilters. Smaller precision
     * leads to better approximation, but higher memory usage.
     * Cannot be smaller than 0.00001
     *
     * @example
     * const agg = esb.rareTermsAggregation('genres', 'genre').precision(0.001);
     *
     * @param {number} precision Float value for precision of the internal CuckooFilters. Default is 0.01
     * @returns {RareTermsAggregation} returns `this` so that calls can be chained
     */
    precision(precision) {
        if (precision < 0.00001) {
            throw new Error('`precision` must be greater than 0.00001.');
        }

        this._aggsDef.precision = precision;
        return this;
    }

    /**
     * Sets terms that should be included in the aggregation
     *
     * @example
     * const agg = esb.rareTermsAggregation('genres', 'genre').include('swi*');
     *
     * @param {string} include Regular expression that will determine what values
     * are "allowed" to be aggregated
     * @returns {RareTermsAggregation} returns `this` so that calls can be chained
     */
    include(include) {
        this._aggsDef.include = include;
        return this;
    }

    /**
     * Sets terms that should be excluded from the aggregation
     *
     * @example
     * const agg = esb.rareTermsAggregation('genres', 'genre').exclude('electro*');
     *
     * @param {string} exclude Regular expression that will determine what values
     * should not be aggregated
     * @returns {RareTermsAggregation} returns `this` so that calls can be chained
     */
    exclude(exclude) {
        this._aggsDef.exclude = exclude;
        return this;
    }

    /**
     * Sets the missing parameter which defines how documents
     * that are missing a value should be treated.
     *
     * @param {string} value
     * @returns {RareTermsAggregation} returns `this` so that calls can be chained
     */
    missing(value) {
        this._aggsDef.missing = value;
        return this;
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on RareTermsAggregation
     */
    script() {
        console.log(`Please refer ${ES_REF_URL$n}`);
        throw new Error('script is not supported in RareTermsAggregation');
    }
};

var rareTermsAggregation$2 = RareTermsAggregation$1;

const isNil$a = lodash_isnil;

const BucketAggregationBase$1 = bucketAggregationBase;

const ES_REF_URL$m =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-reverse-nested-aggregation.html';

/**
 * A special single bucket aggregation that enables aggregating
 * on parent docs from nested documents. Effectively this
 * aggregation can break out of the nested block structure and
 * link to other nested structures or the root document,
 * which allows nesting other aggregations that arent part of
 * the nested object in a nested aggregation.
 *
 * The `reverse_nested` aggregation must be defined inside a nested aggregation.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-reverse-nested-aggregation.html)
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .query(esb.matchQuery('name', 'led tv'))
 *     .agg(
 *         esb.nestedAggregation('comments', 'comments').agg(
 *             esb.termsAggregation('top_usernames', 'comments.username').agg(
 *                 esb.reverseNestedAggregation('comment_to_issue').agg(
 *                     esb.termsAggregation('top_tags_per_comment', 'tags')
 *                 )
 *             )
 *         )
 *     );
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} path Defines to what nested object field should be joined back.
 * The default is empty, which means that it joins back to the root / main document
 * level.
 *
 * @extends BucketAggregationBase
 */
let ReverseNestedAggregation$1 = class ReverseNestedAggregation extends BucketAggregationBase$1 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, path) {
        super(name, 'reverse_nested');

        if (!isNil$a(path)) this._aggsDef.path = path;
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on ReverseNestedAggregation
     */
    field() {
        console.log(`Please refer ${ES_REF_URL$m}`);
        throw new Error('field is not supported in ReverseNestedAggregation');
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on ReverseNestedAggregation
     */
    script() {
        console.log(`Please refer ${ES_REF_URL$m}`);
        throw new Error('script is not supported in ReverseNestedAggregation');
    }

    /**
     * Sets the level to join back for subsequent aggregations in a multiple
     * layered nested object types
     *
     * @param {string} path Defines to what nested object field should be joined back.
     * The default is empty, which means that it joins back to the root / main document
     * level.
     * @returns {ReverseNestedAggregation} returns `this` so that calls can be chained
     */
    path(path) {
        this._aggsDef.path = path;
        return this;
    }
};

var reverseNestedAggregation$2 = ReverseNestedAggregation$1;

const BucketAggregationBase = bucketAggregationBase;

const ES_REF_URL$l =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-sampler-aggregation.html';

/**
 * A filtering aggregation used to limit any sub aggregations'
 * processing to a sample of the top-scoring documents.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-sampler-aggregation.html)
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .query(esb.queryStringQuery('tags:kibana OR tags:javascript'))
 *     .agg(
 *         esb.samplerAggregation('sample')
 *             .shardSize(200)
 *             .agg(
 *                 esb.significantTermsAggregation(
 *                     'keywords',
 *                     'tags'
 *                 ).exclude(['kibana', 'javascript'])
 *             )
 *     );
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} field The field to aggregate on
 *
 * @extends BucketAggregationBase
 */
let SamplerAggregation$1 = class SamplerAggregation extends BucketAggregationBase {
    // eslint-disable-next-line require-jsdoc
    constructor(name) {
        super(name, 'sampler');
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on SamplerAggregation
     */
    field() {
        console.log(`Please refer ${ES_REF_URL$l}`);
        throw new Error('field is not supported in SamplerAggregation');
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on SamplerAggregation
     */
    script() {
        console.log(`Please refer ${ES_REF_URL$l}`);
        throw new Error('script is not supported in SamplerAggregation');
    }

    /**
     * The shard_size parameter limits how many top-scoring documents
     * are collected in the sample processed on each shard. The default value is 100.
     *
     * @param {number} size Maximum number of documents to return from each shard(Integer)
     * @returns {SamplerAggregation} returns `this` so that calls can be chained
     */
    shardSize(size) {
        this._aggsDef.shard_size = size;
        return this;
    }
};

var samplerAggregation$2 = SamplerAggregation$1;

const SignificantAggregationBase$1 = significantAggregationBase;

const ES_REF_URL$k =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-significantterms-aggregation.html';

/**
 * An aggregation that returns interesting or unusual occurrences of terms in
 * a set.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-significantterms-aggregation.html)
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .query(esb.termsQuery('force', 'British Transport Police'))
 *     .agg(
 *         esb.significantTermsAggregation(
 *             'significantCrimeTypes',
 *             'crime_type'
 *         )
 *     );
 *
 * @example
 * // Use parent aggregation for segregated data analysis
 * const agg = esb.termsAggregation('forces', 'force').agg(
 *     esb.significantTermsAggregation('significantCrimeTypes', 'crime_type')
 * );
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} field The field to aggregate on
 *
 * @extends SignificantAggregationBase
 */
let SignificantTermsAggregation$1 = class SignificantTermsAggregation extends SignificantAggregationBase$1 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field) {
        super(name, 'significant_terms', ES_REF_URL$k, field);
    }
};

var significantTermsAggregation$2 = SignificantTermsAggregation$1;

const {
    util: { checkType: checkType$3 }
} = core;

const SignificantAggregationBase = significantAggregationBase;

const ES_REF_URL$j =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-significanttext-aggregation.html';

/**
 * An aggregation that returns interesting or unusual occurrences of free-text
 * terms in a set. It is like the `SignificantTermsAggregation` but differs in
 * that:
 *   - It is specifically designed for use on type `text` fields
 *   - It does not require field data or doc-values
 *   - It re-analyzes text content on-the-fly meaning it can also filter
 *     duplicate sections of noisy text that otherwise tend to skew statistics.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-significanttext-aggregation.html)
 *
 * NOTE: This query was added in elasticsearch v6.0.
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *   .query(esb.matchQuery('content', 'Bird flu'))
 *   .agg(
 *     esb.samplerAggregation('my_sample')
 *       .shardSize(100)
 *       .agg(esb.significantTextAggregation('keywords', 'content'))
 *   );
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} field The field to aggregate on
 *
 * @extends SignificantAggregationBase
 */
let SignificantTextAggregation$1 = class SignificantTextAggregation extends SignificantAggregationBase {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field) {
        super(name, 'significant_text', ES_REF_URL$j, field);
    }

    /**
     * Control if duplicate paragraphs of text should try be filtered from the
     * statistical text analysis. Can improve results but slows down analysis.
     * Default is `false`.
     *
     * @example
     * const reqBody = esb.requestBodySearch()
     *   .query(esb.matchQuery('content', 'elasticsearch'))
     *   .agg(
     *     esb.samplerAggregation('sample')
     *       .shardSize(100)
     *       .agg(
     *         esb.significantTextAggregation('keywords', 'content')
     *           .filterDuplicateText(true)
     *       )
     *   );
     *
     * @param {boolean} enable
     * @returns {SignificantTextAggregation} returns `this` so that calls can be chained
     */
    filterDuplicateText(enable) {
        this._aggsDef.filter_duplicate_text = enable;
        return this;
    }

    /**
     * Selects the fields to load from `_source` JSON and analyze. If none are
     * specified, the indexed "fieldName" value is assumed to also be the name
     * of the JSON field holding the value
     *
     * @example
     * const reqBody = esb.requestBodySearch()
     *   .query(esb.matchQuery('custom_all', 'elasticsearch'))
     *   .agg(
     *     esb.significantTextAggregation('tags', 'custom_all')
     *       .sourceFields(['content', 'title'])
     *   );
     *
     * @param {Array<string>} srcFields Array of fields
     * @returns {SignificantTextAggregation} returns `this` so that calls can be chained
     */
    sourceFields(srcFields) {
        checkType$3(srcFields, Array);

        this._aggsDef.source_fields = srcFields;
        return this;
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on SignificantTextAggregation
     */
    missing() {
        console.log(`Please refer ${ES_REF_URL$j}`);
        throw new Error(
            'missing is not supported in SignificantTextAggregation'
        );
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on SignificantTextAggregation
     */
    executionHint() {
        console.log(`Please refer ${ES_REF_URL$j}`);
        throw new Error(
            'executionHint is not supported in SignificantTextAggregation'
        );
    }
};

var significantTextAggregation$2 = SignificantTextAggregation$1;

const has = lodash_has;
const isNil$9 = lodash_isnil;

const {
    util: { invalidParam: invalidParam$5 }
} = core;

const TermsAggregationBase = termsAggregationBase;

const ES_REF_URL$i =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html';

const invalidDirectionParam = invalidParam$5(
    ES_REF_URL$i,
    'direction',
    "'asc' or 'desc'"
);
const invalidCollectModeParam = invalidParam$5(
    ES_REF_URL$i,
    'mode',
    "'breadth_first' or 'depth_first'"
);

/**
 * A multi-bucket value source based aggregation where buckets are dynamically
 * built - one per unique value.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-terms-aggregation.html)
 *
 * @example
 * const agg = esb.termsAggregation('genres', 'genre');
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} field The field to aggregate on
 *
 * @extends TermsAggregationBase
 */
let TermsAggregation$1 = class TermsAggregation extends TermsAggregationBase {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field) {
        super(name, 'terms', ES_REF_URL$i, field);
    }

    /**
     * When set to `true`, shows an error value for each term returned by the aggregation
     * which represents the _worst case error_ in the document count and can be useful
     * when deciding on a value for the shard_size parameter.
     *
     * @param {boolean} enable
     * @returns {TermsAggregation} returns `this` so that calls can be chained
     */
    showTermDocCountError(enable) {
        this._aggsDef.show_term_doc_count_error = enable;
        return this;
    }

    /**
     * Break the analysis up into multiple requests by grouping the fields values
     * into a number of partitions at query-time and processing only one
     * partition in each request.
     *
     * Note that this method is a special case as the name doesn't map to the
     * elasticsearch parameter name. This is required because there is already
     * a method for `include` applicable for Terms aggregations. However, this
     * could change depending on community interest.
     *
     * @example
     * const agg = esb.termsAggregation('expired_sessions', 'account_id')
     *     .includePartition(0, 20)
     *     .size(10000)
     *     .order('last_access', 'asc')
     *     .agg(esb.maxAggregation('last_access', 'access_date'));
     *
     * @param {number} partition
     * @param {number} numPartitions
     * @returns {TermsAggregation} returns `this` so that calls can be chained
     */
    includePartition(partition, numPartitions) {
        // TODO: Print warning if include key is being overwritten
        this._aggsDef.include = {
            partition,
            num_partitions: numPartitions
        };
        return this;
    }

    /**
     * Can be used for deferring calculation of child aggregations by using
     * `breadth_first` mode. In `depth_first` mode all branches of the aggregation
     * tree are expanded in one depth-first pass and only then any pruning occurs.
     *
     * @example
     * const agg = esb.termsAggregation('actors', 'actors')
     *     .size(10)
     *     .collectMode('breadth_first')
     *     .agg(esb.termsAggregation('costars', 'actors').size(5));
     *
     * @param {string} mode The possible values are `breadth_first` and `depth_first`.
     * @returns {TermsAggregation} returns `this` so that calls can be chained
     */
    collectMode(mode) {
        if (isNil$9(mode)) invalidCollectModeParam(mode);

        const modeLower = mode.toLowerCase();
        if (modeLower !== 'breadth_first' && modeLower !== 'depth_first') {
            invalidCollectModeParam(mode);
        }

        this._aggsDef.collect_mode = modeLower;
        return this;
    }

    /**
     * Sets the ordering for buckets
     *
     * @example
     * // Ordering the buckets by their doc `_count` in an ascending manner
     * const agg = esb.termsAggregation('genres', 'genre').order('_count', 'asc');
     *
     * @example
     * // Ordering the buckets alphabetically by their terms in an ascending manner
     * const agg = esb.termsAggregation('genres', 'genre').order('_term', 'asc');
     *
     * @example
     * // Ordering the buckets by single value metrics sub-aggregation
     * // (identified by the aggregation name)
     * const agg = esb.termsAggregation('genres', 'genre')
     *     .order('max_play_count', 'asc')
     *     .agg(esb.maxAggregation('max_play_count', 'play_count'));
     *
     * @example
     * // Ordering the buckets by multi value metrics sub-aggregation
     * // (identified by the aggregation name):
     * const agg = esb.termsAggregation('genres', 'genre')
     *     .order('playback_stats.max', 'desc')
     *     .agg(esb.statsAggregation('playback_stats', 'play_count'));
     *
     * @example
     * // Multiple order criteria
     * const agg = esb.termsAggregation('countries')
     *     .field('artist.country')
     *     .order('rock>playback_stats.avg', 'desc')
     *     .order('_count', 'desc')
     *     .agg(
     *         esb.filterAggregation('rock')
     *             .filter(esb.termQuery('genre', 'rock'))
     *             .agg(esb.statsAggregation('playback_stats', 'play_count'))
     *     );
     *
     * @param {string} key
     * @param {string} direction `asc` or `desc`
     * @returns {TermsAggregation} returns `this` so that calls can be chained
     */
    order(key, direction = 'desc') {
        if (isNil$9(direction)) invalidDirectionParam(direction);

        const directionLower = direction.toLowerCase();
        if (directionLower !== 'asc' && directionLower !== 'desc') {
            invalidDirectionParam(direction);
        }

        if (has(this._aggsDef, 'order')) {
            if (!Array.isArray(this._aggsDef.order)) {
                this._aggsDef.order = [this._aggsDef.order];
            }

            this._aggsDef.order.push({ [key]: directionLower });
        } else {
            this._aggsDef.order = { [key]: directionLower };
        }

        return this;
    }
};

var termsAggregation$2 = TermsAggregation$1;

bucketAggregations.BucketAggregationBase = bucketAggregationBase;
bucketAggregations.HistogramAggregationBase = histogramAggregationBase;
bucketAggregations.RangeAggregationBase = rangeAggregationBase;
bucketAggregations.TermsAggregationBase = termsAggregationBase;
bucketAggregations.SignificantAggregationBase = significantAggregationBase;

bucketAggregations.AdjacencyMatrixAggregation = adjacencyMatrixAggregation$2;
bucketAggregations.ChildrenAggregation = childrenAggregation$2;
bucketAggregations.CompositeAggregation = compositeAggregation$2;
bucketAggregations.DateHistogramAggregation = dateHistogramAggregation$2;
bucketAggregations.AutoDateHistogramAggregation = autoDateHistogramAggregation$2;
bucketAggregations.VariableWidthHistogramAggregation = variableWidthHistogramAggregation$2;
bucketAggregations.DateRangeAggregation = dateRangeAggregation$2;
bucketAggregations.DiversifiedSamplerAggregation = diversifiedSamplerAggregation$2;
bucketAggregations.FilterAggregation = filterAggregation$2;
bucketAggregations.FiltersAggregation = filtersAggregation$2;
bucketAggregations.GeoDistanceAggregation = geoDistanceAggregation$2;
bucketAggregations.GeoHashGridAggregation = geoHashGridAggregation$2;
bucketAggregations.GeoHexGridAggregation = geoHexGridAggregation$2;
bucketAggregations.GeoTileGridAggregation = geoTileGridAggregation$2;
bucketAggregations.GlobalAggregation = globalAggregation$2;
bucketAggregations.HistogramAggregation = histogramAggregation$2;
bucketAggregations.IpRangeAggregation = ipRangeAggregation$2;
bucketAggregations.MissingAggregation = missingAggregation$2;
bucketAggregations.NestedAggregation = nestedAggregation$2;
bucketAggregations.ParentAggregation = parentAggregation$2;
bucketAggregations.RangeAggregation = rangeAggregation$2;
bucketAggregations.RareTermsAggregation = rareTermsAggregation$2;
bucketAggregations.ReverseNestedAggregation = reverseNestedAggregation$2;
bucketAggregations.SamplerAggregation = samplerAggregation$2;
bucketAggregations.SignificantTermsAggregation = significantTermsAggregation$2;
bucketAggregations.SignificantTextAggregation = significantTextAggregation$2;
bucketAggregations.TermsAggregation = termsAggregation$2;

var pipelineAggregations = {};

const isNil$8 = lodash_isnil;

const {
    Aggregation: Aggregation$1,
    util: { invalidParam: invalidParam$4 }
} = core;

const invalidGapPolicyParam = invalidParam$4(
    '',
    'gap_policy',
    "'skip' or 'insert_zeros'"
);

/**
 * The `PipelineAggregationBase` provides support for common options used across
 * various pipeline `Aggregation` implementations.
 *
 * Pipeline aggregations cannot have sub-aggregations but depending on the type
 * it can reference another pipeline in the buckets_path allowing pipeline
 * aggregations to be chained. For example, you can chain together two derivatives
 * to calculate the second derivative (i.e. a derivative of a derivative).
 *
 * **NOTE:** Instantiating this directly should not be required.
 * However, if you wish to add a custom implementation for whatever reason,
 * this class could be extended.
 *
 * @param {string} name a valid aggregation name
 * @param {string} aggType type of aggregation
 * @param {string} refUrl Elasticsearch reference URL
 * @param {string|Object=} bucketsPath The relative path of metric to aggregate over
 *
 * @extends Aggregation
 */
let PipelineAggregationBase$f = class PipelineAggregationBase extends Aggregation$1 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, aggType, refUrl, bucketsPath) {
        super(name, aggType);

        this._refUrl = refUrl;

        if (!isNil$8(bucketsPath)) this._aggsDef.buckets_path = bucketsPath;
    }

    /**
     * Sets the relative path, `buckets_path`, which refers to the metric to aggregate over.
     * Required.
     *
     * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline.html#buckets-path-syntax)
     *
     * @example
     * const reqBody = esb.requestBodySearch()
     *     .agg(
     *         esb.dateHistogramAggregation('histo', 'date')
     *             .interval('day')
     *             .agg(esb.termsAggregation('categories', 'category'))
     *             .agg(
     *                 esb.bucketSelectorAggregation('min_bucket_selector')
     *                     .bucketsPath({ count: 'categories._bucket_count' })
     *                     .script(esb.script('inline', 'params.count != 0'))
     *             )
     *     )
     *     .size(0);
     *
     * @param {string|Object} path
     * @returns {PipelineAggregationBase} returns `this` so that calls can be chained
     */
    bucketsPath(path) {
        this._aggsDef.buckets_path = path;
        return this;
    }

    /**
     * Set policy for missing data. Optional.
     *
     * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline.html#gap-policy)
     *
     * @param {string} policy Can be `skip` or `insert_zeros`
     * @returns {PipelineAggregationBase} returns `this` so that calls can be chained
     */
    gapPolicy(policy) {
        if (isNil$8(policy)) invalidGapPolicyParam(policy, this._refUrl);

        const policyLower = policy.toLowerCase();
        if (policyLower !== 'skip' && policyLower !== 'insert_zeros') {
            invalidGapPolicyParam(policy, this._refUrl);
        }

        this._aggsDef.gap_policy = policyLower;
        return this;
    }

    /**
     * Sets the format expression if applicable. Optional.
     *
     * @param {string} fmt Format mask to apply on aggregation response. Example: ####.00
     * @returns {PipelineAggregationBase} returns `this` so that calls can be chained
     */
    format(fmt) {
        this._aggsDef.format = fmt;
        return this;
    }
};

var pipelineAggregationBase = PipelineAggregationBase$f;

const PipelineAggregationBase$e = pipelineAggregationBase;

const ES_REF_URL$h =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-avg-bucket-aggregation.html';

/**
 * A sibling pipeline aggregation which calculates the (mean) average value
 * of a specified metric in a sibling aggregation. The specified metric must
 * be numeric and the sibling aggregation must be a multi-bucket aggregation.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-avg-bucket-aggregation.html)
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .agg(
 *         esb.dateHistogramAggregation('sales_per_month', 'date')
 *             .interval('month')
 *             .agg(esb.sumAggregation('sales', 'price'))
 *     )
 *     .agg(
 *         esb.avgBucketAggregation(
 *             'avg_monthly_sales',
 *             'sales_per_month>sales'
 *         )
 *     )
 *     .size(0);
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} bucketsPath The relative path of metric to aggregate over
 *
 * @extends PipelineAggregationBase
 */
let AvgBucketAggregation$1 = class AvgBucketAggregation extends PipelineAggregationBase$e {
    // eslint-disable-next-line require-jsdoc
    constructor(name, bucketsPath) {
        super(name, 'avg_bucket', ES_REF_URL$h, bucketsPath);
    }
};

var avgBucketAggregation$2 = AvgBucketAggregation$1;

const PipelineAggregationBase$d = pipelineAggregationBase;

const ES_REF_URL$g =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-derivative-aggregation.html';

/**
 * A parent pipeline aggregation which calculates the derivative of a
 * specified metric in a parent histogram (or date_histogram) aggregation.
 * The specified metric must be numeric and the enclosing histogram must
 * have min_doc_count set to 0 (default for histogram aggregations).
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-derivative-aggregation.html)
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .agg(
 *         esb.dateHistogramAggregation('sales_per_month', 'date')
 *             .interval('month')
 *             .agg(esb.sumAggregation('sales', 'price'))
 *             .agg(esb.derivativeAggregation('sales_deriv', 'sales'))
 *     )
 *     .size(0);
 *
 * @example
 * // First and second order derivative of the monthly sales
 * const reqBody = esb.requestBodySearch()
 *     .agg(
 *         esb.dateHistogramAggregation('sales_per_month', 'date')
 *             .interval('month')
 *             .agg(esb.sumAggregation('sales', 'price'))
 *             .agg(esb.derivativeAggregation('sales_deriv', 'sales'))
 *             .agg(esb.derivativeAggregation('sales_2nd_deriv', 'sales_deriv'))
 *     )
 *     .size(0);
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} bucketsPath The relative path of metric to aggregate over
 *
 * @extends PipelineAggregationBase
 */
let DerivativeAggregation$1 = class DerivativeAggregation extends PipelineAggregationBase$d {
    // eslint-disable-next-line require-jsdoc
    constructor(name, bucketsPath) {
        super(name, 'derivative', ES_REF_URL$g, bucketsPath);
    }

    /**
     * Set the units of the derivative values. `unit` specifies what unit to use for
     * the x-axis of the derivative calculation
     *
     * @example
     * const reqBody = esb.requestBodySearch()
     *     .agg(
     *         esb.dateHistogramAggregation('sales_per_month', 'date')
     *             .interval('month')
     *             .agg(esb.sumAggregation('sales', 'price'))
     *             .agg(esb.derivativeAggregation('sales_deriv', 'sales').unit('day'))
     *     )
     *     .size(0);
     *
     * @param {string} unit `unit` specifies what unit to use for
     * the x-axis of the derivative calculation
     * @returns {DerivativeAggregation} returns `this` so that calls can be chained
     */
    unit(unit) {
        this._aggsDef.unit = unit;
        return this;
    }
};

var derivativeAggregation$2 = DerivativeAggregation$1;

const PipelineAggregationBase$c = pipelineAggregationBase;

const ES_REF_URL$f =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-max-bucket-aggregation.html';

/**
 * A sibling pipeline aggregation which identifies the bucket(s) with
 * the maximum value of a specified metric in a sibling aggregation and
 * outputs both the value and the key(s) of the bucket(s). The specified
 * metric must be numeric and the sibling aggregation must be a multi-bucket
 * aggregation.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-max-bucket-aggregation.html)
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .agg(
 *         esb.dateHistogramAggregation('sales_per_month', 'date')
 *             .interval('month')
 *             .agg(esb.sumAggregation('sales', 'price'))
 *     )
 *     .agg(
 *         // Metric embedded in sibling aggregation
 *         // Get the maximum value of `sales` aggregation in
 *         // `sales_per_month` histogram
 *         esb.maxBucketAggregation(
 *             'max_monthly_sales',
 *             'sales_per_month>sales'
 *         )
 *     )
 *     .size(0);
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} bucketsPath The relative path of metric to aggregate over
 *
 * @extends PipelineAggregationBase
 */
let MaxBucketAggregation$1 = class MaxBucketAggregation extends PipelineAggregationBase$c {
    // eslint-disable-next-line require-jsdoc
    constructor(name, bucketsPath) {
        super(name, 'max_bucket', ES_REF_URL$f, bucketsPath);
    }
};

var maxBucketAggregation$2 = MaxBucketAggregation$1;

const PipelineAggregationBase$b = pipelineAggregationBase;

const ES_REF_URL$e =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-min-bucket-aggregation.html';

/**
 * A sibling pipeline aggregation which identifies the bucket(s) with
 * the minimum value of a specified metric in a sibling aggregation and
 * outputs both the value and the key(s) of the bucket(s). The specified
 * metric must be numeric and the sibling aggregation must be a multi-bucket
 * aggregation.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-min-bucket-aggregation.html)
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .agg(
 *         esb.dateHistogramAggregation('sales_per_month', 'date')
 *             .interval('month')
 *             .agg(esb.sumAggregation('sales', 'price'))
 *     )
 *     .agg(
 *         // Metric embedded in sibling aggregation
 *         // Get the minimum value of `sales` aggregation in
 *         // `sales_per_month` histogram
 *         esb.minBucketAggregation(
 *             'min_monthly_sales',
 *             'sales_per_month>sales'
 *         )
 *     )
 *     .size(0);
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} bucketsPath The relative path of metric to aggregate over
 *
 * @extends PipelineAggregationBase
 */
let MinBucketAggregation$1 = class MinBucketAggregation extends PipelineAggregationBase$b {
    // eslint-disable-next-line require-jsdoc
    constructor(name, bucketsPath) {
        super(name, 'min_bucket', ES_REF_URL$e, bucketsPath);
    }
};

var minBucketAggregation$2 = MinBucketAggregation$1;

const PipelineAggregationBase$a = pipelineAggregationBase;

const ES_REF_URL$d =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-sum-bucket-aggregation.html';

/**
 * A sibling pipeline aggregation which calculates the sum across all bucket
 * of a specified metric in a sibling aggregation. The specified metric must
 * be numeric and the sibling aggregation must be a multi-bucket aggregation.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-sum-bucket-aggregation.html)
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} bucketsPath The relative path of metric to aggregate over
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .agg(
 *         esb.dateHistogramAggregation('sales_per_month', 'date')
 *             .interval('month')
 *             .agg(esb.sumAggregation('sales', 'price'))
 *     )
 *     .agg(
 *         // Get the sum of all the total monthly `sales` buckets
 *         esb.sumBucketAggregation(
 *             'sum_monthly_sales',
 *             'sales_per_month>sales'
 *         )
 *     )
 *     .size(0);
 *
 * @extends PipelineAggregationBase
 */
let SumBucketAggregation$1 = class SumBucketAggregation extends PipelineAggregationBase$a {
    // eslint-disable-next-line require-jsdoc
    constructor(name, bucketsPath) {
        super(name, 'sum_bucket', ES_REF_URL$d, bucketsPath);
    }
};

var sumBucketAggregation$2 = SumBucketAggregation$1;

const PipelineAggregationBase$9 = pipelineAggregationBase;

const ES_REF_URL$c =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-stats-bucket-aggregation.html';

/**
 * A sibling pipeline aggregation which calculates a variety of stats across
 * all bucket of a specified metric in a sibling aggregation. The specified
 * metric must be numeric and the sibling aggregation must be a multi-bucket
 * aggregation.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-stats-bucket-aggregation.html)
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .agg(
 *         esb.dateHistogramAggregation('sales_per_month', 'date')
 *             .interval('month')
 *             .agg(esb.sumAggregation('sales', 'price'))
 *     )
 *     .agg(
 *         // Calculates stats for monthly sales
 *         esb.statsBucketAggregation(
 *             'stats_monthly_sales',
 *             'sales_per_month>sales'
 *         )
 *     )
 *     .size(0);
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} bucketsPath The relative path of metric to aggregate over
 *
 * @extends PipelineAggregationBase
 */
let StatsBucketAggregation$1 = class StatsBucketAggregation extends PipelineAggregationBase$9 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, bucketsPath) {
        super(name, 'stats_bucket', ES_REF_URL$c, bucketsPath);
    }
};

var statsBucketAggregation$2 = StatsBucketAggregation$1;

const PipelineAggregationBase$8 = pipelineAggregationBase;

const ES_REF_URL$b =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-extended-stats-bucket-aggregation.html';

/**
 * A sibling pipeline aggregation which calculates a variety of stats across
 * all bucket of a specified metric in a sibling aggregation. The specified
 * metric must be numeric and the sibling aggregation must be a multi-bucket
 * aggregation.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-extended-stats-bucket-aggregation.html)
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .agg(
 *         esb.dateHistogramAggregation('sales_per_month', 'date')
 *             .interval('month')
 *             .agg(esb.sumAggregation('sales', 'price'))
 *     )
 *     .agg(
 *         // Calculates extended stats for monthly sales
 *         esb.extendedStatsBucketAggregation(
 *             'stats_monthly_sales',
 *             'sales_per_month>sales'
 *         )
 *     )
 *     .size(0);
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} bucketsPath The relative path of metric to aggregate over
 *
 * @extends PipelineAggregationBase
 */
let ExtendedStatsBucketAggregation$1 = class ExtendedStatsBucketAggregation extends PipelineAggregationBase$8 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, bucketsPath) {
        super(name, 'extended_stats_bucket', ES_REF_URL$b, bucketsPath);
    }

    /**
     * Sets the number of standard deviations above/below the mean to display.
     * Optional.
     *
     * @param {number} sigma Default is 2.
     * @returns {ExtendedStatsBucketAggregation} returns `this` so that calls can be chained
     */
    sigma(sigma) {
        this._aggsDef.sigma = sigma;
        return this;
    }
};

var extendedStatsBucketAggregation$2 = ExtendedStatsBucketAggregation$1;

const {
    util: { checkType: checkType$2 }
} = core;

const PipelineAggregationBase$7 = pipelineAggregationBase;

const ES_REF_URL$a =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-percentiles-bucket-aggregation.html';

/**
 * A sibling pipeline aggregation which calculates percentiles across all
 * bucket of a specified metric in a sibling aggregation. The specified
 * metric must be numeric and the sibling aggregation must be a multi-bucket
 * aggregation.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-percentiles-bucket-aggregation.html)
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .agg(
 *         esb.dateHistogramAggregation('sales_per_month', 'date')
 *             .interval('month')
 *             .agg(esb.sumAggregation('sales', 'price'))
 *     )
 *     .agg(
 *         // Calculates stats for monthly sales
 *         esb.percentilesBucketAggregation(
 *             'percentiles_monthly_sales',
 *             'sales_per_month>sales'
 *         ).percents([25.0, 50.0, 75.0])
 *     )
 *     .size(0);
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} bucketsPath The relative path of metric to aggregate over
 *
 * @extends PipelineAggregationBase
 */
let PercentilesBucketAggregation$1 = class PercentilesBucketAggregation extends PipelineAggregationBase$7 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, bucketsPath) {
        super(name, 'percentiles_bucket', ES_REF_URL$a, bucketsPath);
    }

    /**
     * Sets the list of percentiles to calculate
     *
     * @param {Array<number>} percents The list of percentiles to calculate
     * @returns {PercentilesBucketAggregation} returns `this` so that calls can be chained
     */
    percents(percents) {
        checkType$2(percents, Array);

        this._aggsDef.percents = percents;
        return this;
    }
};

var percentilesBucketAggregation$2 = PercentilesBucketAggregation$1;

const isNil$7 = lodash_isnil;

const {
    util: { invalidParam: invalidParam$3 },
    consts: { MODEL_SET }
} = core;

const PipelineAggregationBase$6 = pipelineAggregationBase;

const ES_REF_URL$9 =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-movavg-aggregation.html';

const invalidModelParam = invalidParam$3(ES_REF_URL$9, 'model', MODEL_SET);

/**
 * Given an ordered series of data, the Moving Average aggregation will
 * slide a window across the data and emit the average value of that window.
 *
 * `moving_avg` aggregations must be embedded inside of a histogram or
 * date_histogram aggregation.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-movavg-aggregation.html)
 *
 * @example
 * const agg = esb.movingAverageAggregation('the_movavg', 'the_sum')
 *     .model('holt')
 *     .window(5)
 *     .gapPolicy('insert_zeros')
 *     .settings({ alpha: 0.8 });
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .agg(
 *         esb.dateHistogramAggregation('my_date_histo', 'timestamp')
 *             .interval('day')
 *             .agg(esb.sumAggregation('the_sum', 'lemmings'))
 *             // Relative path to sibling metric `the_sum`
 *             .agg(esb.movingAverageAggregation('the_movavg', 'the_sum'))
 *     )
 *     .size(0);
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .agg(
 *         esb.dateHistogramAggregation('my_date_histo', 'timestamp')
 *             .interval('day')
 *             // Use the document count as it's input
 *             .agg(esb.movingAverageAggregation('the_movavg', '_count'))
 *     )
 *     .size(0);
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} bucketsPath The relative path of metric to aggregate over
 *
 * @extends PipelineAggregationBase
 */
let MovingAverageAggregation$1 = class MovingAverageAggregation extends PipelineAggregationBase$6 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, bucketsPath) {
        super(name, 'moving_avg', ES_REF_URL$9, bucketsPath);
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on MovingAverageAggregation
     */
    format() {
        console.log(`Please refer ${ES_REF_URL$9}`);
        throw new Error('format is not supported in MovingAverageAggregation');
    }

    /**
     * Sets the moving average weighting model that we wish to use. Optional.
     *
     * @example
     * const agg = esb.movingAverageAggregation('the_movavg', 'the_sum')
     *     .model('simple')
     *     .window(30);
     *
     * @example
     * const agg = esb.movingAverageAggregation('the_movavg', 'the_sum')
     *     .model('ewma')
     *     .window(30)
     *     .settings({ alpha: 0.8 });
     *
     * @param {string} model Can be `simple`, `linear`,
     * `ewma` (aka "single-exponential"), `holt` (aka "double exponential")
     * or `holt_winters` (aka "triple exponential").
     * Default is `simple`
     * @returns {MovingAverageAggregation} returns `this` so that calls can be chained
     */
    model(model) {
        if (isNil$7(model)) invalidModelParam(model);

        const modelLower = model.toLowerCase();
        if (!MODEL_SET.has(modelLower)) invalidModelParam(model);

        this._aggsDef.model = modelLower;
        return this;
    }

    /**
     * Sets the size of window to "slide" across the histogram. Optional.
     *
     * @example
     * const agg = esb.movingAverageAggregation('the_movavg', 'the_sum')
     *     .model('simple')
     *     .window(30)
     *
     * @param {number} window Default is 5
     * @returns {MovingAverageAggregation} returns `this` so that calls can be chained
     */
    window(window) {
        this._aggsDef.window = window;
        return this;
    }

    /**
     * If the model should be algorithmically minimized. Optional.
     * Applicable on EWMA, Holt-Linear, Holt-Winters.
     * Minimization is disabled by default for `ewma` and `holt_linear`,
     * while it is enabled by default for `holt_winters`.
     *
     * @example
     * const agg = esb.movingAverageAggregation('the_movavg', 'the_sum')
     *     .model('holt_winters')
     *     .window(30)
     *     .minimize(true)
     *     .settings({ period: 7 });
     *
     * @param {boolean} enable `false` for most models
     * @returns {MovingAverageAggregation} returns `this` so that calls can be chained
     */
    minimize(enable) {
        this._aggsDef.minimize = enable;
        return this;
    }

    /**
     * Model-specific settings, contents which differ depending on the model specified.
     * Optional.
     *
     * @example
     * const agg = esb.movingAverageAggregation('the_movavg', 'the_sum')
     *     .model('ewma')
     *     .window(30)
     *     .settings({ alpha: 0.8 });
     *
     * @param {Object} settings
     * @returns {MovingAverageAggregation} returns `this` so that calls can be chaineds
     */
    settings(settings) {
        this._aggsDef.settings = settings;
        return this;
    }

    /**
     * Enable "prediction" mode, which will attempt to extrapolate into the future given
     * the current smoothed, moving average
     *
     * @example
     * const agg = esb.movingAverageAggregation('the_movavg', 'the_sum')
     *     .model('simple')
     *     .window(30)
     *     .predict(10);
     *
     * @param {number} predict the number of predictions you would like appended to the
     * end of the series
     * @returns {MovingAverageAggregation} returns `this` so that calls can be chained
     */
    predict(predict) {
        this._aggsDef.predict = predict;
        return this;
    }
};

var movingAverageAggregation$2 = MovingAverageAggregation$1;

const isNil$6 = lodash_isnil;

const PipelineAggregationBase$5 = pipelineAggregationBase;

const ES_REF_URL$8 =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-movfn-aggregation.html';

/**
 * Given an ordered series of data, the Moving Function aggregation
 * will slide a window across the data and allow the user to specify
 * a custom script that is executed on each window of data.
 * For convenience, a number of common functions are predefined such as min/max, moving averages, etc.
 *
 * `moving_fn` aggregations must be embedded inside of a histogram or
 * date_histogram aggregation.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-movfn-aggregation.html)
 *
 * NOTE: Only available in Elasticsearch 6.4.0+.
 *
 * @example
 * const agg = esb.movingFunctionAggregation('the_movfn', 'the_sum')
 *     .model('holt')
 *     .window(5)
 *     .gapPolicy('insert_zeros')
 *     .settings({ alpha: 0.8 });
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .agg(
 *         esb.dateHistogramAggregation('my_date_histo', 'timestamp')
 *             .interval('day')
 *             .agg(esb.sumAggregation('the_sum', 'lemmings'))
 *             // Relative path to sibling metric `the_sum`
 *             .agg(esb.movingFunctionAggregation('the_movfn', 'the_sum'))
 *     )
 *     .size(0);
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .agg(
 *         esb.dateHistogramAggregation('my_date_histo', 'timestamp')
 *             .interval('day')
 *             // Use the document count as it's input
 *             .agg(esb.movingFunctionAggregation('the_movfn', '_count'))
 *     )
 *     .size(0);
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} bucketsPath The relative path of metric to aggregate over.
 * @param {string=} window The size of window to "slide" across the histogram.
 * @param {string=} script The script that should be executed on each window of data.
 *
 * @extends PipelineAggregationBase
 */
let MovingFunctionAggregation$1 = class MovingFunctionAggregation extends PipelineAggregationBase$5 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, bucketsPath, window, script) {
        super(name, 'moving_fn', ES_REF_URL$8, bucketsPath);

        if (!isNil$6(window)) this._aggsDef.window = window;
        if (!isNil$6(script)) this._aggsDef.script = script;
    }

    /**
     * Sets the size of window to "slide" across the histogram. Optional.
     *
     * @example
     * const agg = esb.movingFunctionAggregation('the_movfn', 'the_sum')
     *     .window(30)
     *
     * @param {number} window Default is 5
     * @returns {MovingFunctionAggregation} returns `this` so that calls can be chained
     */
    window(window) {
        this._aggsDef.window = window;
        return this;
    }

    /**
     * Sets shift of window position. Optional.
     *
     * @example
     * const agg = esb.movingFunctionAggregation('the_movfn', 'the_sum')
     *     .shift(30)
     *
     * @param {number} shift Default is 0
     * @returns {MovingFunctionAggregation} returns `this` so that calls can be chained
     */
    shift(shift) {
        this._aggsDef.shift = shift;
        return this;
    }

    /**
     * Sets the script that should be executed on each window of data. Required.
     *
     * @example
     * const agg = esb.movingFunctionAggregation('the_movfn', 'the_sum', "MovingFunctions.unweightedAvg(values)"")
     *     .script("MovingFunctions.unweightedAvg(values)")
     *
     * @param {string} script
     * @returns {MovingFunctionAggregation} returns `this` so that calls can be chained
     */
    script(script) {
        this._aggsDef.script = script;
        return this;
    }
};

var movingFunctionAggregation$2 = MovingFunctionAggregation$1;

const PipelineAggregationBase$4 = pipelineAggregationBase;

const ES_REF_URL$7 =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-cumulative-sum-aggregation.html';

/**
 * A parent pipeline aggregation which calculates the cumulative sum of
 * a specified metric in a parent histogram (or date_histogram) aggregation.
 * The specified metric must be numeric and the enclosing histogram must
 * have min_doc_count set to 0 (default for histogram aggregations).
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-cumulative-sum-aggregation.html)
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .agg(
 *         esb.dateHistogramAggregation('sales_per_month', 'date', 'month')
 *             .agg(esb.sumAggregation('sales', 'price'))
 *             .agg(esb.cumulativeSumAggregation('cumulative_sales', 'sales'))
 *     )
 *     .size(0);
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} bucketsPath The relative path of metric to aggregate over
 *
 * @extends PipelineAggregationBase
 */
let CumulativeSumAggregation$1 = class CumulativeSumAggregation extends PipelineAggregationBase$4 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, bucketsPath) {
        super(name, 'cumulative_sum', ES_REF_URL$7, bucketsPath);
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on CumulativeSumAggregation
     */
    gapPolicy() {
        console.log(`Please refer ${ES_REF_URL$7}`);
        throw new Error(
            'gapPolicy is not supported in CumulativeSumAggregation'
        );
    }
};

var cumulativeSumAggregation$2 = CumulativeSumAggregation$1;

const PipelineAggregationBase$3 = pipelineAggregationBase;

const ES_REF_URL$6 =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-bucket-script-aggregation.html';

/**
 * A parent pipeline aggregation which executes a script which can perform
 * per bucket computations on specified metrics in the parent multi-bucket
 * aggregation. The specified metric must be numeric and the script must
 * return a numeric value.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-bucket-script-aggregation.html)
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .agg(
 *         esb.dateHistogramAggregation('sales_per_month', 'date', 'month')
 *             .agg(esb.sumAggregation('total_sales', 'price'))
 *             .agg(
 *                 esb.filterAggregation('t-shirts')
 *                     .filter(esb.termQuery('type', 't-shirt'))
 *                     .agg(esb.sumAggregation('sales', 'price'))
 *             )
 *             .agg(
 *                 esb.bucketScriptAggregation('t-shirt-percentage')
 *                     .bucketsPath({
 *                         tShirtSales: 't-shirts>sales',
 *                         totalSales: 'total_sales'
 *                     })
 *                     .script('params.tShirtSales / params.totalSales * 100')
 *             )
 *     )
 *     .size(0);
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} bucketsPath The relative path of metric to aggregate over
 *
 * @extends PipelineAggregationBase
 */
let BucketScriptAggregation$1 = class BucketScriptAggregation extends PipelineAggregationBase$3 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, bucketsPath) {
        super(name, 'bucket_script', ES_REF_URL$6, bucketsPath);
    }

    /**
     * Sets script parameter for aggregation.
     *
     * @param {Script|string} script
     * @returns {BucketScriptAggregation} returns `this` so that calls can be chained
     * @throws {TypeError} If `script` is not an instance of `Script`
     */
    script(script) {
        this._aggsDef.script = script;
        return this;
    }
};

var bucketScriptAggregation$2 = BucketScriptAggregation$1;

const PipelineAggregationBase$2 = pipelineAggregationBase;

const ES_REF_URL$5 =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-bucket-selector-aggregation.html';

/**
 * A parent pipeline aggregation which executes a script which determines whether
 * the current bucket will be retained in the parent multi-bucket aggregation.
 * The specified metric must be numeric and the script must return a boolean value.
 * If the script language is expression then a numeric return value is permitted.
 * In this case 0.0 will be evaluated as false and all other values will evaluate to true.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-bucket-selector-aggregation.html)
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .agg(
 *         esb.dateHistogramAggregation('histo', 'date')
 *             .interval('day')
 *             .agg(esb.termsAggregation('categories', 'category'))
 *             .agg(
 *                 esb.bucketSelectorAggregation('min_bucket_selector')
 *                     .bucketsPath({ count: 'categories._bucket_count' })
 *                     .script(esb.script('inline', 'params.count != 0'))
 *             )
 *     )
 *     .size(0);
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .agg(
 *         esb.dateHistogramAggregation('sales_per_month', 'date')
 *             .interval('month')
 *             .agg(esb.sumAggregation('sales', 'price'))
 *             .agg(
 *                 esb.bucketSelectorAggregation('sales_bucket_filter')
 *                     .bucketsPath({ totalSales: 'total_sales' })
 *                     .script('params.totalSales > 200')
 *             )
 *     )
 *     .size(0);
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} bucketsPath The relative path of metric to aggregate over
 *
 * @extends PipelineAggregationBase
 */
let BucketSelectorAggregation$1 = class BucketSelectorAggregation extends PipelineAggregationBase$2 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, bucketsPath) {
        super(name, 'bucket_selector', ES_REF_URL$5, bucketsPath);
    }

    /**
     * @override
     * @throws {Error} This method cannot be called on BucketSelectorAggregation
     */
    format() {
        console.log(`Please refer ${ES_REF_URL$5}`);
        throw new Error('format is not supported in BucketSelectorAggregation');
    }

    /**
     * Sets script parameter for aggregation. Required.
     *
     * @param {Script|string} script
     * @returns {BucketSelectorAggregation} returns `this` so that calls can be chained
     * @throws {TypeError} If `script` is not an instance of `Script`
     */
    script(script) {
        this._aggsDef.script = script;
        return this;
    }
};

var bucketSelectorAggregation$2 = BucketSelectorAggregation$1;

const PipelineAggregationBase$1 = pipelineAggregationBase;

const ES_REF_URL$4 =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-serialdiff-aggregation.html';

/**
 * Serial differencing is a technique where values in a time series are
 * subtracted from itself at different time lags or periods.
 *
 * Serial differences are built by first specifying a `histogram` or `date_histogram` over a field.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-serialdiff-aggregation.html)
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .agg(
 *         esb.dateHistogramAggregation('my_date_histo', 'timestamp')
 *             .interval('day')
 *             .agg(esb.sumAggregation('the_sum', 'lemmings'))
 *             .agg(
 *                 esb.serialDifferencingAggregation(
 *                     'thirtieth_difference',
 *                     'the_sum'
 *                 ).lag(30)
 *             )
 *     )
 *     .size(0);
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 * @param {string=} bucketsPath The relative path of metric to aggregate over
 *
 * @extends PipelineAggregationBase
 */
let SerialDifferencingAggregation$1 = class SerialDifferencingAggregation extends PipelineAggregationBase$1 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, bucketsPath) {
        super(name, 'serial_diff', ES_REF_URL$4, bucketsPath);
    }

    /**
     * The historical bucket to subtract from the current value.
     * Optional.
     *
     * @param {number} lag Default is 1.
     * @returns {SerialDifferencingAggregation} returns `this` so that calls can be chained
     */
    lag(lag) {
        this._aggsDef.lag = lag;
        return this;
    }
};

var serialDifferencingAggregation$2 = SerialDifferencingAggregation$1;

const PipelineAggregationBase = pipelineAggregationBase;

const ES_REF_URL$3 =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-bucket-sort-aggregation.html';

/**
 * A parent pipeline aggregation which sorts the buckets of its parent
 * multi-bucket aggregation. Zero or more sort fields may be specified
 * together with the corresponding sort order. Each bucket may be sorted
 * based on its _key, _count or its sub-aggregations. In addition, parameters
 * from and size may be set in order to truncate the result buckets.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-pipeline-bucket-sort-aggregation.html)
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .agg(
 *         esb.bucketSortAggregation('sort')
 *             .sort([
 *                  esb.sort('user', 'desc')
 *              ])
 *              .from(5)
 *              .size(10)
 *         )
 *     );
 *
 * @param {string} name The name which will be used to refer to this aggregation.
 *
 * @extends PipelineAggregationBase
 */
let BucketSortAggregation$1 = class BucketSortAggregation extends PipelineAggregationBase {
    // eslint-disable-next-line require-jsdoc
    constructor(name) {
        super(name, 'bucket_sort', ES_REF_URL$3);
    }

    /**
     * Sets the list of fields to sort on. Optional.
     *
     * @param {Array<Sort>} sort The list of fields to sort on
     * @returns {BucketSortAggregation} returns `this` so that calls can be chained
     */
    sort(sort) {
        this._aggsDef.sort = sort;
        return this;
    }

    /**
     * Sets the value buckets in positions prior to which will be truncated. Optional.
     *
     * @param {number} from Buckets in positions prior to the set value will be truncated.
     * @returns {BucketSortAggregation} returns `this` so that calls can be chained
     */
    from(from) {
        this._aggsDef.from = from;
        return this;
    }

    /**
     * Sets the number of buckets to return. Optional.
     *
     * @param {number} size The number of buckets to return.
     * @returns {BucketSortAggregation} returns `this` so that calls can be chained
     */
    size(size) {
        this._aggsDef.size = size;
        return this;
    }
};

var bucketSortAggregation$2 = BucketSortAggregation$1;

pipelineAggregations.PipelineAggregationBase = pipelineAggregationBase;

pipelineAggregations.AvgBucketAggregation = avgBucketAggregation$2;
pipelineAggregations.DerivativeAggregation = derivativeAggregation$2;
pipelineAggregations.MaxBucketAggregation = maxBucketAggregation$2;
pipelineAggregations.MinBucketAggregation = minBucketAggregation$2;
pipelineAggregations.SumBucketAggregation = sumBucketAggregation$2;
pipelineAggregations.StatsBucketAggregation = statsBucketAggregation$2;
pipelineAggregations.ExtendedStatsBucketAggregation = extendedStatsBucketAggregation$2;
pipelineAggregations.PercentilesBucketAggregation = percentilesBucketAggregation$2;
pipelineAggregations.MovingAverageAggregation = movingAverageAggregation$2;
pipelineAggregations.MovingFunctionAggregation = movingFunctionAggregation$2;
pipelineAggregations.CumulativeSumAggregation = cumulativeSumAggregation$2;
pipelineAggregations.BucketScriptAggregation = bucketScriptAggregation$2;
pipelineAggregations.BucketSelectorAggregation = bucketSelectorAggregation$2;
pipelineAggregations.SerialDifferencingAggregation = serialDifferencingAggregation$2;
pipelineAggregations.BucketSortAggregation = bucketSortAggregation$2;

var matrixAggregations = {};

const isNil$5 = lodash_isnil;

const {
    Aggregation,
    util: { checkType: checkType$1 }
} = core;

/**
 * The `matrix_stats` aggregation is a numeric aggregation that computes
 * statistics over a set of document fields
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-matrix-stats-aggregation.html)
 *
 * @example
 * const agg = esb.matrixStatsAggregation('matrixstats', ['poverty', 'income']);
 *
 * @param {string} name A valid aggregation name
 * @param {Array=} fields Array of fields
 *
 * @extends Aggregation
 */
let MatrixStatsAggregation$1 = class MatrixStatsAggregation extends Aggregation {
    // eslint-disable-next-line require-jsdoc
    constructor(name, fields) {
        super(name, 'matrix_stats');

        if (!isNil$5(fields)) this.fields(fields);
    }

    /**
     * The `fields` setting defines the set of fields (as an array) for computing
     * the statistics.
     *
     * @example
     * const agg = esb.matrixStatsAggregation('matrixstats')
     *     .fields(['poverty', 'income']);
     *
     * @param {Array<string>} fields Array of fields
     * @returns {MatrixStatsAggregation} returns `this` so that calls can be chained
     */
    fields(fields) {
        checkType$1(fields, Array);

        this._aggsDef.fields = fields;
        return this;
    }

    /**
     * The `mode` parameter controls what array value the aggregation will use for
     * array or multi-valued fields
     * @param {string} mode One of `avg`, `min`, `max`, `sum` and `median`
     * @returns {MatrixStatsAggregation} returns `this` so that calls can be chained
     */
    mode(mode) {
        // TODO: Add a set in consts and validate input
        this._aggsDef.mode = mode;
        return this;
    }

    /**
     * The missing parameter defines how documents that are missing a value should
     * be treated. By default they will be ignored but it is also possible to treat
     * them as if they had a value.
     *
     * @example
     * const agg = esb.matrixStatsAggregation('matrixstats')
     *     .fields(['poverty', 'income'])
     *     .missing({ income: 50000 });
     *
     * @param {Object} missing Set of fieldname : value mappings to specify default
     * values per field
     * @returns {MatrixStatsAggregation} returns `this` so that calls can be chained
     */
    missing(missing) {
        this._aggsDef.missing = missing;
        return this;
    }
};

var matrixStatsAggregation$2 = MatrixStatsAggregation$1;

matrixAggregations.MatrixStatsAggregation = matrixStatsAggregation$2;

// Not used in favor of explicit exports.
// IDE seems to handle those better

// const _ = require('lodash');

// const { util: { constructorWrapper } } = require('../core');

// const metricsAggs = require('./metrics-aggregations'),
//     bucketAggs = require('./bucket-aggregations');

// /* === Metrics Aggregations === */
// for (const clsName in metricsAggs) {
//     if (!has(metricsAggs, clsName)) continue;

//     exports[clsName] = metricsAggs[clsName];
//     exports[_.lowerFirst(clsName)] = constructorWrapper(metricsAggs[clsName]);
// }

// /* === Bucket Aggregations === */
// for (const clsName in bucketAggs) {
//     if (!has(bucketAggs, clsName)) continue;

//     exports[clsName] = bucketAggs[clsName];
//     exports[_.lowerFirst(clsName)] = constructorWrapper(bucketAggs[clsName]);
// }

aggregations.metricsAggregations = metricsAggregations;

aggregations.bucketAggregations = bucketAggregations;

aggregations.pipelineAggregations = pipelineAggregations;

aggregations.matrixAggregations = matrixAggregations;

var suggesters = {};

const isNil$4 = lodash_isnil;

const { Suggester: Suggester$1 } = core;

/**
 * The `AnalyzedSuggesterBase` provides support for common options used
 * in `TermSuggester` and `PhraseSuggester`.
 *
 * **NOTE:** Instantiating this directly should not be required.
 * However, if you wish to add a custom implementation for whatever reason,
 * this class could be extended.
 *
 * @param {string} suggesterType The type of suggester.
 * Can be one of `term`, `phrase`
 * @param {string} name The name of the Suggester, an arbitrary identifier
 * @param {string=} field The field to fetch the candidate suggestions from.
 * @param {string=} txt A string to get suggestions for.
 *
 * @throws {Error} if `name` is empty
 * @throws {Error} if `suggesterType` is empty
 *
 * @extends Suggester
 */
let AnalyzedSuggesterBase$2 = class AnalyzedSuggesterBase extends Suggester$1 {
    // eslint-disable-next-line require-jsdoc
    constructor(suggesterType, name, field, txt) {
        super(suggesterType, name, field);

        if (!isNil$4(txt)) this._opts.text = txt;
    }

    /**
     * Sets the text to get suggestions for. If not set, the global
     * suggestion text will be used.
     *
     * @param {string} txt A string to get suggestions for.
     * @returns {AnalyzedSuggesterBase} returns `this` so that calls can be chained.
     */
    text(txt) {
        this._opts.text = txt;
        return this;
    }

    /**
     * Sets the analyzer to analyse the suggest text with. Defaults to
     * the search analyzer of the suggest field.
     *
     * @param {string} analyzer The analyzer to analyse the suggest text with.
     * @returns {AnalyzedSuggesterBase} returns `this` so that calls can be chained.
     */
    analyzer(analyzer) {
        this._suggestOpts.analyzer = analyzer;
        return this;
    }

    /**
     * Sets the maximum number of suggestions to be retrieved from each individual shard.
     * During the reduce phase only the top N suggestions are returned based on the `size`
     * option. Defaults to the `size` option. Setting this to a value higher than the `size`
     * can be useful in order to get a more accurate document frequency for spelling
     * corrections at the cost of performance. Due to the fact that terms are partitioned
     * amongst shards, the shard level document frequencies of spelling corrections
     * may not be precise. Increasing this will make these document frequencies
     * more precise.
     *
     * @param {number} size
     * @returns {AnalyzedSuggesterBase} returns `this` so that calls can be chained.
     */
    shardSize(size) {
        this._suggestOpts.shard_size = size;
        return this;
    }
};

var analyzedSuggesterBase = AnalyzedSuggesterBase$2;

const isNil$3 = lodash_isnil;

const {
    consts: { SUGGEST_MODE_SET: SUGGEST_MODE_SET$1, STRING_DISTANCE_SET },
    util: { invalidParam: invalidParam$2 }
} = core;

const AnalyzedSuggesterBase$1 = analyzedSuggesterBase;

const ES_REF_URL$2 =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters-term.html';

const invalidSortParam = invalidParam$2(
    ES_REF_URL$2,
    'sort',
    "'score' or 'frequency'"
);
const invalidSuggestModeParam$1 = invalidParam$2(
    ES_REF_URL$2,
    'suggest_mode',
    SUGGEST_MODE_SET$1
);
const invalidStringDistanceParam = invalidParam$2(
    ES_REF_URL$2,
    'string_distance',
    STRING_DISTANCE_SET
);

/**
 * The term suggester suggests terms based on edit distance.
 * The provided suggest text is analyzed before terms are suggested.
 * The suggested terms are provided per analyzed suggest text token.
 * The term suggester doesnt take the query into account that is part of request.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters-term.html)
 *
 * @example
 * const suggest = esb.termSuggester(
 *     'my-suggestion',
 *     'message',
 *     'tring out Elasticsearch'
 * );
 *
 * @param {string} name The name of the Suggester, an arbitrary identifier
 * @param {string=} field The field to fetch the candidate suggestions from.
 * @param {string=} txt A string to get suggestions for.
 *
 * @throws {Error} if `name` is empty
 *
 * @extends AnalyzedSuggesterBase
 */
let TermSuggester$1 = class TermSuggester extends AnalyzedSuggesterBase$1 {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field, txt) {
        super('term', name, field, txt);
    }

    /**
     * Sets the sort to control how suggestions should be sorted per
     * suggest text term.
     *
     * Two possible values:
     *   - `score`: Sort by score first, then document frequency and
     *     then the term itself.
     *   - `frequency`: Sort by document frequency first, then similarity
     *     score and then the term itself.
     *
     * @param {string} sort Can be `score` or `frequency`
     * @returns {TermSuggester} returns `this` so that calls can be chained.
     * @throws {Error} If `sort` is neither `score` nor `frequency`.
     */
    sort(sort) {
        if (isNil$3(sort)) invalidSortParam(sort);

        const sortLower = sort.toLowerCase();
        if (sortLower !== 'score' && sortLower !== 'frequency') {
            invalidSortParam(sort);
        }

        this._suggestOpts.sort = sortLower;
        return this;
    }

    /**
     * Sets the suggest mode which controls what suggestions are included
     * or controls for what suggest text terms, suggestions should be suggested.
     *
     * Three possible values can be specified:
     *   - `missing`: Only provide suggestions for suggest text terms that
     *     are not in the index. This is the default.
     *   - `popular`:  Only suggest suggestions that occur in more docs
     *     than the original suggest text term.
     *   - `always`: Suggest any matching suggestions based on terms in the suggest text.
     *
     * @param {string} mode Can be `missing`, `popular` or `always`
     * @returns {TermSuggester} returns `this` so that calls can be chained.
     * @throws {Error} If `mode` is not one of `missing`, `popular` or `always`.
     */
    suggestMode(mode) {
        if (isNil$3(mode)) invalidSuggestModeParam$1(mode);

        const modeLower = mode.toLowerCase();
        if (!SUGGEST_MODE_SET$1.has(modeLower)) {
            invalidSuggestModeParam$1(mode);
        }

        this._suggestOpts.suggest_mode = modeLower;
        return this;
    }

    /**
     * Sets the maximum edit distance candidate suggestions can have
     * in order to be considered as a suggestion. Can only be a value
     * between 1 and 2. Any other value result in an bad request
     * error being thrown. Defaults to 2.
     *
     * @param {number} maxEdits Value between 1 and 2. Defaults to 2.
     * @returns {TermSuggester} returns `this` so that calls can be chained.
     */
    maxEdits(maxEdits) {
        this._suggestOpts.max_edits = maxEdits;
        return this;
    }

    /**
     * Sets the number of minimal prefix characters that must match in order
     * to be a candidate suggestions. Defaults to 1.
     *
     * Increasing this number improves spellcheck performance.
     * Usually misspellings don't occur in the beginning of terms.
     *
     * @param {number} len The number of minimal prefix characters that must match in order
     * to be a candidate suggestions. Defaults to 1.
     * @returns {TermSuggester} returns `this` so that calls can be chained.
     */
    prefixLength(len) {
        this._suggestOpts.prefix_length = len;
        return this;
    }

    /**
     * Sets the minimum length a suggest text term must have in order to be included.
     * Defaults to 4.
     *
     * @param {number} len The minimum length a suggest text term must have in order
     * to be included. Defaults to 4.
     * @returns {TermSuggester} returns `this` so that calls can be chained.
     */
    minWordLength(len) {
        this._suggestOpts.min_word_length = len;
        return this;
    }

    /**
     * Sets factor that is used to multiply with the `shards_size` in order to inspect
     * more candidate spell corrections on the shard level.
     * Can improve accuracy at the cost of performance. Defaults to 5.
     *
     * @param {number} maxInspections Factor used to multiple with `shards_size` in
     * order to inspect more candidate spell corrections on the shard level.
     * Defaults to 5
     * @returns {TermSuggester} returns `this` so that calls can be chained.
     */
    maxInspections(maxInspections) {
        this._suggestOpts.max_inspections = maxInspections;
        return this;
    }

    /**
     * Sets the minimal threshold in number of documents a suggestion should appear in.
     * This can be specified as an absolute number or as a relative percentage of
     * number of documents. This can improve quality by only suggesting high
     * frequency terms. Defaults to 0f and is not enabled. If a value higher than 1
     * is specified then the number cannot be fractional. The shard level document
     * frequencies are used for this option.
     *
     * @param {number} limit Threshold in number of documents a suggestion
     * should appear in. Defaults to 0f and is not enabled.
     * @returns {TermSuggester} returns `this` so that calls can be chained.
     */
    minDocFreq(limit) {
        this._suggestOpts.min_doc_freq = limit;
        return this;
    }

    /**
     * Sets the maximum threshold in number of documents a suggest text token can
     * exist in order to be included. Can be a relative percentage number (e.g 0.4)
     * or an absolute number to represent document frequencies. If an value higher
     * than 1 is specified then fractional can not be specified. Defaults to 0.01f.
     * This can be used to exclude high frequency terms from being spellchecked.
     * High frequency terms are usually spelled correctly on top of this also
     * improves the spellcheck performance. The shard level document frequencies are
     * used for this option.
     *
     * @param {number} limit Maximum threshold in number of documents a suggest text
     * token can exist in order to be included. Defaults to 0.01f.
     * @returns {TermSuggester} returns `this` so that calls can be chained.
     */
    maxTermFreq(limit) {
        this._suggestOpts.max_term_freq = limit;
        return this;
    }

    /**
     * Sets the string distance implementation to use for comparing how similar
     * suggested terms are.
     *
     * Five possible values can be specified:
     *   - `internal`: The default based on `damerau_levenshtein` but highly optimized for
     *     comparing string distance for terms inside the index.
     *   - `damerau_levenshtein`: String distance algorithm based on Damerau-Levenshtein
     *     algorithm.
     *   - `levenstein`: String distance algorithm based on Levenstein edit distance
     *     algorithm.
     *   - `jarowinkler`: String distance algorithm based on Jaro-Winkler algorithm.
     *   - `ngram`: String distance algorithm based on character n-grams.
     *
     * @param {string} implMethod One of `internal`, `damerau_levenshtein`, `levenstein`,
     * `jarowinkler`, `ngram`
     * @returns {TermSuggester} returns `this` so that calls can be chained.
     * @throws {Error} If `implMethod` is not one of `internal`, `damerau_levenshtein`,
     * `levenstein`, `jarowinkler` or ngram`.
     */
    stringDistance(implMethod) {
        if (isNil$3(implMethod)) invalidStringDistanceParam(implMethod);

        const implMethodLower = implMethod.toLowerCase();
        if (!STRING_DISTANCE_SET.has(implMethodLower)) {
            invalidStringDistanceParam(implMethod);
        }

        this._suggestOpts.string_distance = implMethodLower;
        return this;
    }
};

var termSuggester$2 = TermSuggester$1;

const isNil$2 = lodash_isnil;

const {
    consts: { SUGGEST_MODE_SET },
    util: { invalidParam: invalidParam$1 }
} = core;

const ES_REF_URL$1 =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters-phrase.html#_direct_generators';

const invalidSuggestModeParam = invalidParam$1(
    ES_REF_URL$1,
    'suggest_mode',
    SUGGEST_MODE_SET
);

/**
 * The `phrase` suggester uses candidate generators to produce a list of possible
 * terms per term in the given text. A single candidate generator is similar
 * to a `term` suggester called for each individual term in the text. The output
 * of the generators is subsequently scored in combination with the candidates
 * from the other terms to for suggestion candidates.
 *
 * The Phrase suggest API accepts a list of generators under the key `direct_generator`
 * each of the generators in the list are called per term in the original text.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters-phrase.html#_direct_generators)
 *
 * @param {string=} field The field to fetch the candidate suggestions from.
 */
let DirectGenerator$1 = class DirectGenerator {
    // eslint-disable-next-line require-jsdoc
    constructor(field) {
        this._body = {};

        if (!isNil$2(field)) this._body.field = field;
    }

    /**
     * Sets field to fetch the candidate suggestions from. This is a required option
     * that either needs to be set globally or per suggestion.
     *
     * @param {string} field a valid field name
     * @returns {DirectGenerator} returns `this` so that calls can be chained
     */
    field(field) {
        this._body.field = field;
        return this;
    }

    /**
     * Sets the number of suggestions to return (defaults to `5`).
     *
     * @param {number} size
     * @returns {DirectGenerator} returns `this` so that calls can be chained.
     */
    size(size) {
        this._body.size = size;
        return this;
    }

    /**
     * Sets the suggest mode which controls what suggestions are included
     * or controls for what suggest text terms, suggestions should be suggested.
     *  All values other than `always` can be thought of as an optimization to
     * generate fewer suggestions to test on each shard and are not rechecked
     * when combining the suggestions generated on each shard. Thus `missing`
     * will generate suggestions for terms on shards that do not contain them
     * even other shards do contain them. Those should be filtered out
     * using `confidence`.
     *
     * Three possible values can be specified:
     *   - `missing`: Only provide suggestions for suggest text terms that
     *     are not in the index. This is the default.
     *   - `popular`:  Only suggest suggestions that occur in more docs
     *     than the original suggest text term.
     *   - `always`: Suggest any matching suggestions based on terms in the suggest text.
     *
     * @param {string} mode Can be `missing`, `popular` or `always`
     * @returns {DirectGenerator} returns `this` so that calls can be chained.
     * @throws {Error} If `mode` is not one of `missing`, `popular` or `always`.
     */
    suggestMode(mode) {
        if (isNil$2(mode)) invalidSuggestModeParam(mode);

        const modeLower = mode.toLowerCase();
        if (!SUGGEST_MODE_SET.has(modeLower)) {
            invalidSuggestModeParam(mode);
        }

        this._body.suggest_mode = modeLower;
        return this;
    }

    /**
     * Sets the maximum edit distance candidate suggestions can have
     * in order to be considered as a suggestion. Can only be a value
     * between 1 and 2. Any other value result in an bad request
     * error being thrown. Defaults to 2.
     *
     * @param {number} maxEdits Value between 1 and 2. Defaults to 2.
     * @returns {DirectGenerator} returns `this` so that calls can be chained.
     */
    maxEdits(maxEdits) {
        this._body.max_edits = maxEdits;
        return this;
    }

    /**
     * Sets the number of minimal prefix characters that must match in order
     * to be a candidate suggestions. Defaults to 1.
     *
     * Increasing this number improves spellcheck performance.
     * Usually misspellings don't occur in the beginning of terms.
     *
     * @param {number} len The number of minimal prefix characters that must match in order
     * to be a candidate suggestions. Defaults to 1.
     * @returns {DirectGenerator} returns `this` so that calls can be chained.
     */
    prefixLength(len) {
        this._body.prefix_length = len;
        return this;
    }

    /**
     * Sets the minimum length a suggest text term must have in order to be included.
     * Defaults to 4.
     *
     * @param {number} len The minimum length a suggest text term must have in order
     * to be included. Defaults to 4.
     * @returns {DirectGenerator} returns `this` so that calls can be chained.
     */
    minWordLength(len) {
        this._body.min_word_length = len;
        return this;
    }

    /**
     * Sets factor that is used to multiply with the `shards_size` in order to inspect
     * more candidate spell corrections on the shard level.
     * Can improve accuracy at the cost of performance. Defaults to 5.
     *
     * @param {number} maxInspections Factor used to multiple with `shards_size` in
     * order to inspect more candidate spell corrections on the shard level.
     * Defaults to 5
     * @returns {DirectGenerator} returns `this` so that calls can be chained.
     */
    maxInspections(maxInspections) {
        this._body.max_inspections = maxInspections;
        return this;
    }

    /**
     * Sets the minimal threshold in number of documents a suggestion should appear in.
     * This can be specified as an absolute number or as a relative percentage of
     * number of documents. This can improve quality by only suggesting high
     * frequency terms. Defaults to 0f and is not enabled. If a value higher than 1
     * is specified then the number cannot be fractional. The shard level document
     * frequencies are used for this option.
     *
     * @param {number} limit Threshold in number of documents a suggestion
     * should appear in. Defaults to 0f and is not enabled.
     * @returns {DirectGenerator} returns `this` so that calls can be chained.
     */
    minDocFreq(limit) {
        this._body.min_doc_freq = limit;
        return this;
    }

    /**
     * Sets the maximum threshold in number of documents a suggest text token can
     * exist in order to be included. Can be a relative percentage number (e.g 0.4)
     * or an absolute number to represent document frequencies. If an value higher
     * than 1 is specified then fractional can not be specified. Defaults to 0.01f.
     * This can be used to exclude high frequency terms from being spellchecked.
     * High frequency terms are usually spelled correctly on top of this also
     * improves the spellcheck performance. The shard level document frequencies are
     * used for this option.
     *
     * @param {number} limit Maximum threshold in number of documents a suggest text
     * token can exist in order to be included. Defaults to 0.01f.
     * @returns {DirectGenerator} returns `this` so that calls can be chained.
     */
    maxTermFreq(limit) {
        this._body.max_term_freq = limit;
        return this;
    }

    /**
     * Sets the filter (analyzer) that is applied to each of the tokens passed to this
     * candidate generator. This filter is applied to the original token before
     * candidates are generated.
     *
     * @param {string} filter a filter (analyzer) that is applied to each of the
     * tokens passed to this candidate generator.
     * @returns {DirectGenerator} returns `this` so that calls can be chained.
     */
    preFilter(filter) {
        this._body.pre_filter = filter;
        return this;
    }

    /**
     * Sets the filter (analyzer) that is applied to each of the generated tokens
     * before they are passed to the actual phrase scorer.
     *
     * @param {string} filter a filter (analyzer) that is applied to each of the
     * generated tokens before they are passed to the actual phrase scorer.
     * @returns {DirectGenerator} returns `this` so that calls can be chained.
     */
    postFilter(filter) {
        this._body.post_filter = filter;
        return this;
    }

    /**
     * Override default `toJSON` to return DSL representation for the `direct_generator`
     *
     * @override
     * @returns {Object} returns an Object which maps to the elasticsearch DSL
     */
    toJSON() {
        return this._body;
    }
};

var directGenerator$2 = DirectGenerator$1;

const isNil$1 = lodash_isnil;

const {
    consts: { SMOOTHING_MODEL_SET },
    util: { recursiveToJSON, invalidParam }
} = core;

const AnalyzedSuggesterBase = analyzedSuggesterBase;

const ES_REF_URL =
    'https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters-phrase.html';

const invalidSmoothingModeParam = invalidParam(
    ES_REF_URL,
    'smoothing',
    SMOOTHING_MODEL_SET
);

/**
 * The phrase suggester adds additional logic on top of the `term` suggester
 * to select entire corrected phrases instead of individual tokens weighted
 * based on `ngram-language` models. In practice this suggester will be able
 * to make better decisions about which tokens to pick based on co-occurrence
 * and frequencies.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters-phrase.html)
 *
 * @example
 * const suggest = esb.phraseSuggester(
 *     'simple_phrase',
 *     'title.trigram',
 *     'noble prize'
 * )
 *     .size(1)
 *     .gramSize(3)
 *     .directGenerator(esb.directGenerator('title.trigram').suggestMode('always'))
 *     .highlight('<em>', '</em>');
 *
 * @param {string} name The name of the Suggester, an arbitrary identifier
 * @param {string=} field The field to fetch the candidate suggestions from.
 * @param {string=} txt A string to get suggestions for.
 *
 * @throws {Error} if `name` is empty
 *
 * @extends AnalyzedSuggesterBase
 */
let PhraseSuggester$1 = class PhraseSuggester extends AnalyzedSuggesterBase {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field, txt) {
        super('phrase', name, field, txt);
    }

    /**
     * Sets max size of the n-grams (shingles) in the `field`. If the field
     * doesn't contain n-grams (shingles) this should be omitted or set to `1`.
     *
     * Note: Elasticsearch tries to detect the gram size based on
     * the specified `field`. If the field uses a `shingle` filter the `gram_size`
     * is set to the `max_shingle_size` if not explicitly set.
     * @param {number} size Max size of the n-grams (shingles) in the `field`.
     * @returns {PhraseSuggester} returns `this` so that calls can be chained.
     */
    gramSize(size) {
        this._suggestOpts.gram_size = size;
        return this;
    }

    /**
     * Sets the likelihood of a term being a misspelled even if the term exists
     * in the dictionary. The default is `0.95` corresponding to 5% of the
     * real words are misspelled.
     *
     * @param {number} factor Likelihood of a term being misspelled. Defaults to `0.95`
     * @returns {PhraseSuggester} returns `this` so that calls can be chained.
     */
    realWordErrorLikelihood(factor) {
        this._suggestOpts.real_word_error_likelihood = factor;
        return this;
    }

    /**
     * Sets the confidence level defines a factor applied to the input phrases score
     * which is used as a threshold for other suggest candidates. Only candidates
     * that score higher than the threshold will be included in the result.
     * For instance a confidence level of `1.0` will only return suggestions
     * that score higher than the input phrase. If set to `0.0` the top N candidates
     * are returned. The default is `1.0`.
     *
     * @param {number} level Factor applied to the input phrases score, used as
     * a threshold for other suggest candidates.
     * @returns {PhraseSuggester} returns `this` so that calls can be chained.
     */
    confidence(level) {
        this._suggestOpts.confidence = level;
        return this;
    }

    /**
     * Sets the maximum percentage of the terms that at most considered to be
     * misspellings in order to form a correction. This method accepts a float
     * value in the range `[0..1)` as a fraction of the actual query terms or a
     * number `>=1` as an absolute number of query terms. The default is set
     * to `1.0` which corresponds to that only corrections with at most
     * 1 misspelled term are returned. Note that setting this too high can
     * negatively impact performance. Low values like 1 or 2 are recommended
     * otherwise the time spend in suggest calls might exceed the time spend
     * in query execution.
     *
     * @param {number} limit The maximum percentage of the terms that at most considered
     * to be misspellings in order to form a correction.
     * @returns {PhraseSuggester} returns `this` so that calls can be chained.
     */
    maxErrors(limit) {
        this._suggestOpts.max_errors = limit;
        return this;
    }

    /**
     * Sets the separator that is used to separate terms in the bigram field.
     * If not set the whitespace character is used as a separator.
     *
     * @param {string} sep The separator that is used to separate terms in the
     * bigram field.
     * @returns {PhraseSuggester} returns `this` so that calls can be chained.
     */
    separator(sep) {
        this._suggestOpts.separator = sep;
        return this;
    }

    /**
     * Sets up suggestion highlighting. If not provided then no `highlighted` field
     * is returned. If provided must contain exactly `pre_tag` and `post_tag` which
     * are wrapped around the changed tokens. If multiple tokens in a row are changed
     * the entire phrase of changed tokens is wrapped rather than each token.
     *
     * @param {string} preTag Pre-tag to wrap token
     * @param {string} postTag Post-tag to wrap token
     * @returns {PhraseSuggester} returns `this` so that calls can be chained.
     */
    highlight(preTag, postTag) {
        this._suggestOpts.highlight = { pre_tag: preTag, post_tag: postTag };
        return this;
    }

    /**
     * Checks each suggestion against the specified `query` to prune suggestions
     * for which no matching docs exist in the index. The collate query for
     * a suggestion is run only on the local shard from which the suggestion
     * has been generated from. The `query` must be specified, and it is run
     * as a [`template` query](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-template-query.html).
     *
     * The current suggestion is automatically made available as the
     * `{{suggestion}}` variable, which should be used in your query.
     * Additionally, you can specify a `prune` to control if all phrase
     * suggestions will be returned, when set to `true` the suggestions will
     * have an additional option `collate_match`, which will be true if matching
     * documents for the phrase was found, `false` otherwise. The default value
     * for prune is `false`.
     *
     * @example
     * const suggest = esb.phraseSuggester('simple_phrase', 'title.trigram')
     *     .size(1)
     *     .directGenerator(
     *         esb.directGenerator('title.trigram')
     *             .suggestMode('always')
     *             .minWordLength(1)
     *     )
     *     .collate({
     *         query: {
     *             inline: {
     *                 match: {
     *                     '{{field_name}}': '{{suggestion}}'
     *                 }
     *             }
     *         },
     *         params: { field_name: 'title' },
     *         prune: true
     *     });
     *
     * @param {Object} opts The options for `collate`. Can include the following:
     *   - `query`: The `query` to prune suggestions for which
     *      no matching docs exist in the index. It is run as a `template` query.
     *   - `params`: The parameters to be passed to the template. The suggestion
     *      value will be added to the variables you specify.
     *   - `prune`: When set to `true`, the suggestions will
     *      have an additional option `collate_match`, which will be true if matching
     *      documents for the phrase was found, `false` otherwise. The default value
     *      for prune is `false`.
     * @returns {PhraseSuggester} returns `this` so that calls can be chained.
     */
    collate(opts) {
        // Add an instance check here?
        // I wanted to use `SearchTemplate` here since the syntaqx is deceptively
        // similar. But not quite the same.
        // Adding a builder object called collate doesn't make sense either.
        this._suggestOpts.collate = opts;
        return this;
    }

    /**
     * Sets the smoothing model to balance weight between infrequent grams
     * (grams (shingles) are not existing in the index) and frequent grams
     * (appear at least once in the index).
     *
     * Three possible values can be specified:
     *   - `stupid_backoff`: a simple backoff model that backs off to lower order
     *     n-gram models if the higher order count is 0 and discounts the lower order
     *     n-gram model by a constant factor. The default `discount` is `0.4`.
     *     Stupid Backoff is the default model
     *   - `laplace`: a smoothing model that uses an additive smoothing where a
     *     constant (typically `1.0` or smaller) is added to all counts to balance weights,
     *     The default `alpha` is `0.5`.
     *   - `linear_interpolation`: a smoothing model that takes the weighted mean of the
     *     unigrams, bigrams and trigrams based on user supplied weights (lambdas).
     *     Linear Interpolation doesnt have any default values.
     *     All parameters (`trigram_lambda`, `bigram_lambda`, `unigram_lambda`)
     *     must be supplied.
     *
     * @param {string} model One of `stupid_backoff`, `laplace`, `linear_interpolation`
     * @returns {PhraseSuggester} returns `this` so that calls can be chained.
     */
    smoothing(model) {
        if (isNil$1(model)) invalidSmoothingModeParam(model);

        const modelLower = model.toLowerCase();
        if (!SMOOTHING_MODEL_SET.has(modelLower)) {
            invalidSmoothingModeParam(model);
        }

        this._suggestOpts.smoothing = modelLower;
        return this;
    }

    /**
     * Sets the given list of candicate generators which produce a list of possible terms
     * per term in the given text. Each of the generators in the list are
     * called per term in the original text.
     *
     * The output of the generators is subsequently scored in combination with the
     * candidates from the other terms to for suggestion candidates.
     *
     * @example
     * const suggest = esb.phraseSuggester('simple_phrase', 'title.trigram')
     *     .size(1)
     *     .directGenerator([
     *         esb.directGenerator('title.trigram').suggestMode('always'),
     *         esb.directGenerator('title.reverse')
     *             .suggestMode('always')
     *             .preFilter('reverse')
     *             .postFilter('reverse')
     *     ]);
     *
     * @param {Array<DirectGenerator>|DirectGenerator} dirGen Array of `DirectGenerator`
     * instances or a single instance of `DirectGenerator`
     * @returns {PhraseSuggester} returns `this` so that calls can be chained.
     */
    directGenerator(dirGen) {
        // TODO: Do instance checks on `dirGen`
        this._suggestOpts.direct_generator = Array.isArray(dirGen)
            ? dirGen
            : [dirGen];

        return this;
    }

    /**
     * Override default `toJSON` to return DSL representation for the `phrase suggester`
     *
     * @override
     * @returns {Object} returns an Object which maps to the elasticsearch DSL
     */
    toJSON() {
        return recursiveToJSON(this._body);
    }
};

var phraseSuggester$2 = PhraseSuggester$1;

const isObject = lodash_isobject;

const {
    Suggester,
    util: { setDefault }
} = core;

/**
 * The completion suggester provides auto-complete/search-as-you-type
 * functionality. This is a navigational feature to guide users to relevant
 * results as they are typing, improving search precision. It is not meant
 * for spell correction or did-you-mean functionality like the term or
 * phrase suggesters.
 *
 * Ideally, auto-complete functionality should be as fast as a user types to
 * provide instant feedback relevant to what a user has already typed in.
 * Hence, completion suggester is optimized for speed. The suggester uses
 * data structures that enable fast lookups, but are costly to build
 * and are stored in-memory.
 *
 * Elasticsearch reference
 *   - [Completion Suggester](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-suggesters-completion.html)
 *   - [Context Suggester](https://www.elastic.co/guide/en/elasticsearch/reference/current/suggester-context.html)
 *
 * @example
 * const suggest = esb.completionSuggester('song-suggest', 'suggest').prefix('nir');
 *
 * @example
 * const suggest = new esb.CompletionSuggester('place_suggestion', 'suggest')
 *     .prefix('tim')
 *     .size(10)
 *     .contexts('place_type', ['cafe', 'restaurants']);
 *
 * @param {string} name The name of the Suggester, an arbitrary identifier
 * @param {string=} field The field to fetch the candidate suggestions from.
 *
 * @throws {Error} if `name` is empty
 *
 * @extends Suggester
 */
let CompletionSuggester$1 = class CompletionSuggester extends Suggester {
    // eslint-disable-next-line require-jsdoc
    constructor(name, field) {
        super('completion', name, field);
    }

    /**
     * Sets the `prefix` for the `CompletionSuggester` query.
     *
     * @param {string} prefix
     * @returns {CompletionSuggester} returns `this` so that calls can be chained.
     */
    prefix(prefix) {
        this._opts.prefix = prefix;
        return this;
    }

    /**
     * Sets whether duplicate suggestions should be filtered out (defaults to false).
     *
     * NOTE: This option was added in elasticsearch v6.1.
     *
     * @param {boolean} skip Enable/disable skipping duplicates
     * @returns {CompletionSuggester} returns `this` so that calls can be chained.
     */
    skipDuplicates(skip = true) {
        this._suggestOpts.skip_duplicates = skip;
        return this;
    }

    /**
     * Check that the object property `this._suggestOpts.fuzzy` is an object.
     * Set empty object if required.
     *
     * @private
     */
    _checkFuzzy() {
        if (!isObject(this._suggestOpts.fuzzy)) {
            this._suggestOpts.fuzzy = {};
        }
    }

    /**
     * Sets the `fuzzy` parameter. Can be customised with specific fuzzy parameters.
     *
     * @param {boolean|Object=} fuzzy Enable/disable `fuzzy` using boolean or
     * object(with params)
     * @returns {CompletionSuggester} returns `this` so that calls can be chained.
     */
    fuzzy(fuzzy = true) {
        this._suggestOpts.fuzzy = fuzzy;
        return this;
    }

    /**
     * Sets the `fuzziness` parameter which is interpreted as a Levenshtein Edit Distance
     * the number of one character changes that need to be made to one string to make it
     * the same as another string.
     *
     * @example
     * const suggest = esb.completionSuggester('song-suggest', 'suggest')
     *     .prefix('nor')
     *     .fuzziness(2);
     *
     * @param {number|string} factor Can be specified either as a number, or the maximum
     * number of edits, or as `AUTO` which generates an edit distance based on the length
     * of the term.
     * @returns {CompletionSuggester} returns `this` so that calls can be chained.
     */
    fuzziness(factor) {
        this._checkFuzzy();

        this._suggestOpts.fuzzy.fuzziness = factor;
        return this;
    }

    /**
     * Transpositions (`ab`  `ba`) are allowed by default but can be disabled
     * by setting `transpositions` to false.
     *
     * @param {boolean} enable
     * @returns {CompletionSuggester} returns `this` so that calls can be chained.
     */
    transpositions(enable) {
        this._checkFuzzy();

        this._suggestOpts.fuzzy.transpositions = enable;
        return this;
    }

    /**
     * Sets the minimum length of the input before fuzzy suggestions are returned,
     * defaults 3
     *
     * @param {number} len Minimum length of the input before fuzzy suggestions
     * are returned, defaults 3
     * @returns {CompletionSuggester} returns `this` so that calls can be chained.
     */
    minLength(len) {
        this._checkFuzzy();

        this._suggestOpts.fuzzy.min_length = len;
        return this;
    }

    /**
     * The number of initial characters which will not be "fuzzified".
     * This helps to reduce the number of terms which must be examined. Defaults to `1`.
     *
     * @param {number} len Characters to skip fuzzy for. Defaults to `1`.
     * @returns {CompletionSuggester} returns `this` so that calls can be chained.
     */
    prefixLength(len) {
        this._checkFuzzy();

        this._suggestOpts.fuzzy.prefix_length = len;
        return this;
    }

    /**
     * If `true`, all measurements (like fuzzy edit distance, transpositions,
     * and lengths) are measured in Unicode code points instead of in bytes.
     * This is slightly slower than raw bytes, so it is set to `false` by default.
     *
     * @param {boolean} enable Measure in Unicode code points instead of in bytes.
     * `false` by default.
     * @returns {CompletionSuggester} returns `this` so that calls can be chained.
     */
    unicodeAware(enable) {
        this._checkFuzzy();

        this._suggestOpts.fuzzy.unicode_aware = enable;
        return this;
    }

    /**
     * Sets the regular expression for completion suggester which supports regex queries.
     *
     * @example
     * const suggest = esb.completionSuggester('song-suggest', 'suggest')
     *     .regex('n[ever|i]r');
     *
     * @param {string} expr Regular expression
     * @returns {CompletionSuggester} returns `this` so that calls can be chained.
     */
    regex(expr) {
        this._opts.regex = expr;
        return this;
    }

    /**
     * Set special flags. Possible flags are `ALL` (default),
     * `ANYSTRING`, `COMPLEMENT`, `EMPTY`, `INTERSECTION`, `INTERVAL`, or `NONE`.
     *
     * @param {string} flags `|` separated flags. Possible flags are `ALL` (default),
     * `ANYSTRING`, `COMPLEMENT`, `EMPTY`, `INTERSECTION`, `INTERVAL`, or `NONE`.
     * @returns {CompletionSuggester} returns `this` so that calls can be chained.
     */
    flags(flags) {
        setDefault(this._suggestOpts, 'regex', {});

        this._suggestOpts.regex.flags = flags;
        return this;
    }

    /**
     * Limit on how many automaton states regexp queries are allowed to create.
     * This protects against too-difficult (e.g. exponentially hard) regexps.
     * Defaults to 10000. You can raise this limit to allow more complex regular
     * expressions to execute.
     *
     * @param {number} limit
     * @returns {CompletionSuggester} returns `this` so that calls can be chained.
     */
    maxDeterminizedStates(limit) {
        setDefault(this._suggestOpts, 'regex', {});

        this._suggestOpts.regex.max_determinized_states = limit;
        return this;
    }

    /**
     * The completion suggester considers all documents in the index, but it is often
     * desirable to serve suggestions filtered and/or boosted by some criteria.
     *
     * To achieve suggestion filtering and/or boosting, you can add context mappings
     * while configuring a completion field. You can define multiple context mappings
     * for a completion field. Every context mapping has a unique name and a type.
     *
     * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/suggester-context.html)
     *
     * @example
     * const suggest = new esb.CompletionSuggester('place_suggestion', 'suggest')
     *     .prefix('tim')
     *     .size(10)
     *     .contexts('place_type', [
     *         { context: 'cafe' },
     *         { context: 'restaurants', boost: 2 }
     *     ]);
     *
     * @example
     * // Suggestions can be filtered and boosted with respect to how close they
     * // are to one or more geo points. The following filters suggestions that
     * // fall within the area represented by the encoded geohash of a geo point:
     * const suggest = new esb.CompletionSuggester('place_suggestion', 'suggest')
     *     .prefix('tim')
     *     .size(10)
     *     .contexts('location', { lat: 43.662, lon: -79.38 });
     *
     * @example
     * // Suggestions that are within an area represented by a geohash can also be
     * // boosted higher than others
     * const suggest = new esb.CompletionSuggester('place_suggestion', 'suggest')
     *     .prefix('tim')
     *     .size(10)
     *     .contexts('location', [
     *         {
     *             lat: 43.6624803,
     *             lon: -79.3863353,
     *             precision: 2
     *         },
     *         {
     *             context: {
     *                 lat: 43.6624803,
     *                 lon: -79.3863353
     *             },
     *             boost: 2
     *         }
     *     ]);
     *
     * @param {string} name
     * @param {Array|Object} ctx
     * @returns {CompletionSuggester} returns `this` so that calls can be chained.
     */
    contexts(name, ctx) {
        // This whole feature is bizzare!
        // Not very happy with the implementation.
        setDefault(this._suggestOpts, 'contexts', {});

        this._suggestOpts.contexts[name] = ctx;
        return this;
    }
};

var completionSuggester$2 = CompletionSuggester$1;

suggesters.AnalyzedSuggesterBase = analyzedSuggesterBase;

suggesters.TermSuggester = termSuggester$2;
suggesters.DirectGenerator = directGenerator$2;
suggesters.PhraseSuggester = phraseSuggester$2;
suggesters.CompletionSuggester = completionSuggester$2;

var recipes$1 = {};

const isNil = lodash_isnil;

const {
    MatchAllQuery: MatchAllQuery$1,
    termLevelQueries: { ExistsQuery: ExistsQuery$1 },
    compoundQueries: {
        BoolQuery: BoolQuery$1,
        FunctionScoreQuery: FunctionScoreQuery$1,
        scoreFunctions: { RandomScoreFunction: RandomScoreFunction$1 }
    },
    fullTextQueries: { NeuralQuery: NeuralQuery$1, MultiMatchQuery: MultiMatchQuery$1 }
} = queries;

const {
    Query,
    util: { checkType }
} = core;

/**
 * Recipe for the now removed `missing` query.
 *
 * Can be accessed using `esb.recipes.missingQuery` OR `esb.cookMissingQuery`.
 *
 * [Elasticsearch refererence](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-exists-query.html#_literal_missing_literal_query)
 *
 * @example
 * const qry = esb.cookMissingQuery('user');
 *
 * qry.toJSON();
 * {
 *   "bool": {
 *     "must_not": {
 *       "exists": {
 *         "field": "user"
 *       }
 *     }
 *   }
 * }
 *
 * @param {string} field The field which should be missing the value.
 * @returns {BoolQuery} A boolean query with a `must_not` `exists` clause is returned.
 */
recipes$1.missingQuery = function missingQuery(field) {
    return new BoolQuery$1().mustNot(new ExistsQuery$1(field));
};

/**
 * Recipe for random sort query. Takes a query and returns the same
 * wrapped in a random scoring query.
 *
 * Can be accessed using `esb.recipes.randomSortQuery` OR `esb.cookRandomSortQuery`.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-function-score-query.html#function-random)
 *
 * @example
 * const reqBody = esb.requestBodySearch()
 *     .query(esb.cookRandomSortQuery(esb.rangeQuery('age').gte(10)))
 *     .size(100);
 *
 * reqBody.toJSON();
 * {
 *   "query": {
 *     "function_score": {
 *       "query": {
 *         "range": { "age": { "gte": 10 } }
 *       },
 *       "random_score": {}
 *     }
 *   },
 *   "size": 100
 * }
 *
 * @param {Query=} query The query to fetch documents for. Defaults to `match_all` query.
 * @param {number=} seed A seed value for the random score function.
 * @returns {FunctionScoreQuery} A `function_score` query with random sort applied
 * @throws {TypeError} If `query` is not an instance of `Query`.
 */
recipes$1.randomSortQuery = function randomSortQuery(
    query = new MatchAllQuery$1(),
    seed
) {
    checkType(query, Query);
    const func = new RandomScoreFunction$1();
    return new FunctionScoreQuery$1()
        .query(query)
        .function(isNil(seed) ? func : func.seed(seed));
};

/**
 * Recipe for constructing a filter query using `bool` query.
 * Optionally, scoring can be enabled.
 *
 * Can be accessed using `esb.recipes.filterQuery` OR `esb.cookFilterQuery`.
 *
 * [Elasticsearch reference](https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-bool-query.html)
 *
 * @example
 * const boolQry = esb.cookFilterQuery(esb.termQuery('status', 'active'), true);
 * boolQry.toJSON();
 * {
 *   "bool": {
 *     "must": { "match_all": {} },
 *     "filter": {
 *       "term": { "status": "active" }
 *     }
 *   }
 * }
 *
 * @param {Query} query The query to fetch documents for.
 * @param {boolean=} scoring Optional flag for enabling/disabling scoring. Disabled by default.
 * If enabled, a score of `1.0` will be assigned to all documents.
 * @returns {BoolQuery} A `bool` query with a `filter` clause is returned.
 * @throws {TypeError} If `query` is not an instance of `Query`.
 */
recipes$1.filterQuery = function filterQuery(query, scoring = false) {
    checkType(query, Query);

    const boolQry = new BoolQuery$1().filter(query);
    return scoring === true ? boolQry.must(new MatchAllQuery$1()) : boolQry;
};

recipes$1.withSemantic = function withSemantic(query, fields) {
    return new BoolQuery$1().should(
        fields.map(field => new NeuralQuery$1(field, query))
    );
};

recipes$1.withNeural = function withNeural(query, fields) {
    return new BoolQuery$1().should(
        fields.map(field => new NeuralQuery$1(field, query)),
        new MultiMatchQuery$1(fields, query)
    );
};

/* eslint-disable max-lines */

const {
    RequestBodySearch,
    Highlight,
    Script,
    GeoPoint,
    GeoShape,
    IndexedShape,
    Sort,
    Rescore,
    InnerHits,
    SearchTemplate,
    util: { constructorWrapper }
} = core;

const {
    MatchAllQuery,
    MatchNoneQuery,
    fullTextQueries: {
        MatchQuery,
        MatchPhraseQuery,
        MatchPhrasePrefixQuery,
        MultiMatchQuery,
        CommonTermsQuery,
        QueryStringQuery,
        SimpleQueryStringQuery,
        NeuralQuery
    },
    termLevelQueries: {
        TermQuery,
        TermsQuery,
        TermsSetQuery,
        RangeQuery,
        ExistsQuery,
        PrefixQuery,
        WildcardQuery,
        RegexpQuery,
        FuzzyQuery,
        TypeQuery,
        IdsQuery
    },
    compoundQueries: {
        ConstantScoreQuery,
        BoolQuery,
        DisMaxQuery,
        FunctionScoreQuery,
        BoostingQuery,
        scoreFunctions: {
            ScriptScoreFunction,
            WeightScoreFunction,
            RandomScoreFunction,
            FieldValueFactorFunction,
            DecayScoreFunction
        }
    },
    joiningQueries: {
        NestedQuery,
        HasChildQuery,
        HasParentQuery,
        ParentIdQuery
    },
    geoQueries: {
        GeoShapeQuery,
        GeoBoundingBoxQuery,
        GeoDistanceQuery,
        GeoPolygonQuery
    },
    specializedQueries: {
        MoreLikeThisQuery,
        ScriptQuery,
        PercolateQuery,
        DistanceFeatureQuery
    },
    spanQueries: {
        SpanTermQuery,
        SpanMultiTermQuery,
        SpanFirstQuery,
        SpanNearQuery,
        SpanOrQuery,
        SpanNotQuery,
        SpanContainingQuery,
        SpanWithinQuery,
        SpanFieldMaskingQuery
    }
} = queries;

const {
    metricsAggregations: {
        AvgAggregation,
        CardinalityAggregation,
        ExtendedStatsAggregation,
        GeoBoundsAggregation,
        GeoCentroidAggregation,
        MaxAggregation,
        MinAggregation,
        PercentilesAggregation,
        PercentileRanksAggregation,
        ScriptedMetricAggregation,
        StatsAggregation,
        SumAggregation,
        TopHitsAggregation,
        ValueCountAggregation
    },
    bucketAggregations: {
        AdjacencyMatrixAggregation,
        ChildrenAggregation,
        CompositeAggregation,
        DateHistogramAggregation,
        AutoDateHistogramAggregation,
        VariableWidthHistogramAggregation,
        DateRangeAggregation,
        DiversifiedSamplerAggregation,
        FilterAggregation,
        FiltersAggregation,
        GeoDistanceAggregation,
        GeoHashGridAggregation,
        GeoHexGridAggregation,
        GeoTileGridAggregation,
        GlobalAggregation,
        HistogramAggregation,
        IpRangeAggregation,
        MissingAggregation,
        NestedAggregation,
        ParentAggregation,
        RangeAggregation,
        RareTermsAggregation,
        ReverseNestedAggregation,
        SamplerAggregation,
        SignificantTermsAggregation,
        SignificantTextAggregation,
        TermsAggregation
    },
    pipelineAggregations: {
        AvgBucketAggregation,
        DerivativeAggregation,
        MaxBucketAggregation,
        MinBucketAggregation,
        SumBucketAggregation,
        StatsBucketAggregation,
        ExtendedStatsBucketAggregation,
        PercentilesBucketAggregation,
        MovingAverageAggregation,
        MovingFunctionAggregation,
        CumulativeSumAggregation,
        BucketScriptAggregation,
        BucketSelectorAggregation,
        SerialDifferencingAggregation,
        BucketSortAggregation
    },
    matrixAggregations: { MatrixStatsAggregation }
} = aggregations;

const {
    TermSuggester,
    DirectGenerator,
    PhraseSuggester,
    CompletionSuggester
} = suggesters;

const recipes = recipes$1;

src.RequestBodySearch = RequestBodySearch;
src.requestBodySearch = constructorWrapper(RequestBodySearch);

/* ============ ============ ============ */
/* ============== Queries =============== */
/* ============ ============ ============ */
src.MatchAllQuery = MatchAllQuery;
var matchAllQuery$1 = src.matchAllQuery = constructorWrapper(MatchAllQuery);

src.MatchNoneQuery = MatchNoneQuery;
var matchNoneQuery$1 = src.matchNoneQuery = constructorWrapper(MatchNoneQuery);

/* ============ ============ ============ */
/* ========== Full Text Queries ========= */
/* ============ ============ ============ */
src.MatchQuery = MatchQuery;
var matchQuery$1 = src.matchQuery = constructorWrapper(MatchQuery);

src.MatchPhraseQuery = MatchPhraseQuery;
var matchPhraseQuery$1 = src.matchPhraseQuery = constructorWrapper(MatchPhraseQuery);

src.MatchPhrasePrefixQuery = MatchPhrasePrefixQuery;
var matchPhrasePrefixQuery$1 = src.matchPhrasePrefixQuery = constructorWrapper(MatchPhrasePrefixQuery);

src.MultiMatchQuery = MultiMatchQuery;
var multiMatchQuery$1 = src.multiMatchQuery = constructorWrapper(MultiMatchQuery);

src.CommonTermsQuery = CommonTermsQuery;
var commonTermsQuery$1 = src.commonTermsQuery = constructorWrapper(CommonTermsQuery);

src.QueryStringQuery = QueryStringQuery;
var queryStringQuery$1 = src.queryStringQuery = constructorWrapper(QueryStringQuery);

src.SimpleQueryStringQuery = SimpleQueryStringQuery;
var simpleQueryStringQuery$1 = src.simpleQueryStringQuery = constructorWrapper(SimpleQueryStringQuery);

src.NeuralQuery = NeuralQuery;
var neuralQuery$1 = src.neuralQuery = constructorWrapper(NeuralQuery);

/* ============ ============ ============ */
/* ========= Term Level Queries ========= */
/* ============ ============ ============ */
src.TermQuery = TermQuery;
var termQuery$1 = src.termQuery = constructorWrapper(TermQuery);

src.TermsQuery = TermsQuery;
var termsQuery$1 = src.termsQuery = constructorWrapper(TermsQuery);

src.TermsSetQuery = TermsSetQuery;
var termsSetQuery$1 = src.termsSetQuery = constructorWrapper(TermsSetQuery);

src.RangeQuery = RangeQuery;
var rangeQuery$1 = src.rangeQuery = constructorWrapper(RangeQuery);

src.ExistsQuery = ExistsQuery;
var existsQuery$1 = src.existsQuery = constructorWrapper(ExistsQuery);

src.PrefixQuery = PrefixQuery;
var prefixQuery$1 = src.prefixQuery = constructorWrapper(PrefixQuery);

src.WildcardQuery = WildcardQuery;
var wildcardQuery$1 = src.wildcardQuery = constructorWrapper(WildcardQuery);

src.RegexpQuery = RegexpQuery;
var regexpQuery$1 = src.regexpQuery = constructorWrapper(RegexpQuery);

src.FuzzyQuery = FuzzyQuery;
var fuzzyQuery$1 = src.fuzzyQuery = constructorWrapper(FuzzyQuery);

src.TypeQuery = TypeQuery;
var typeQuery$1 = src.typeQuery = constructorWrapper(TypeQuery);

src.IdsQuery = IdsQuery;
var idsQuery$1 = src.idsQuery = constructorWrapper(IdsQuery);

/* ============ ============ ============ */
/* ========== Compound Queries ========== */
/* ============ ============ ============ */
src.ConstantScoreQuery = ConstantScoreQuery;
var constantScoreQuery$1 = src.constantScoreQuery = constructorWrapper(ConstantScoreQuery);

src.BoolQuery = BoolQuery;
var boolQuery$1 = src.boolQuery = constructorWrapper(BoolQuery);

src.DisMaxQuery = DisMaxQuery;
var disMaxQuery$1 = src.disMaxQuery = constructorWrapper(DisMaxQuery);

src.FunctionScoreQuery = FunctionScoreQuery;
var functionScoreQuery$1 = src.functionScoreQuery = constructorWrapper(FunctionScoreQuery);

src.BoostingQuery = BoostingQuery;
var boostingQuery$1 = src.boostingQuery = constructorWrapper(BoostingQuery);

/* ============ ============ ============ */
/* =========== Joining Queries ========== */
/* ============ ============ ============ */
src.NestedQuery = NestedQuery;
var nestedQuery$1 = src.nestedQuery = constructorWrapper(NestedQuery);

src.HasChildQuery = HasChildQuery;
var hasChildQuery$1 = src.hasChildQuery = constructorWrapper(HasChildQuery);

src.HasParentQuery = HasParentQuery;
var hasParentQuery$1 = src.hasParentQuery = constructorWrapper(HasParentQuery);

src.ParentIdQuery = ParentIdQuery;
var parentIdQuery$1 = src.parentIdQuery = constructorWrapper(ParentIdQuery);

/* ============ ============ ============ */
/* ============ Geo Queries ============= */
/* ============ ============ ============ */
src.GeoShapeQuery = GeoShapeQuery;
var geoShapeQuery$1 = src.geoShapeQuery = constructorWrapper(GeoShapeQuery);

src.GeoBoundingBoxQuery = GeoBoundingBoxQuery;
var geoBoundingBoxQuery$1 = src.geoBoundingBoxQuery = constructorWrapper(GeoBoundingBoxQuery);

src.GeoDistanceQuery = GeoDistanceQuery;
var geoDistanceQuery$1 = src.geoDistanceQuery = constructorWrapper(GeoDistanceQuery);

src.GeoPolygonQuery = GeoPolygonQuery;
var geoPolygonQuery$1 = src.geoPolygonQuery = constructorWrapper(GeoPolygonQuery);

/* ============ ============ ============ */
/* ======== Specialized Queries ========= */
/* ============ ============ ============ */
src.MoreLikeThisQuery = MoreLikeThisQuery;
var moreLikeThisQuery$1 = src.moreLikeThisQuery = constructorWrapper(MoreLikeThisQuery);

src.ScriptQuery = ScriptQuery;
var scriptQuery$1 = src.scriptQuery = constructorWrapper(ScriptQuery);

src.PercolateQuery = PercolateQuery;
var percolateQuery$1 = src.percolateQuery = constructorWrapper(PercolateQuery);

src.DistanceFeatureQuery = DistanceFeatureQuery;
var distanceFeatureQuery$1 = src.distanceFeatureQuery = constructorWrapper(DistanceFeatureQuery);

/* ============ ============ ============ */
/* ============ Span Queries ============ */
/* ============ ============ ============ */
src.SpanTermQuery = SpanTermQuery;
var spanTermQuery$1 = src.spanTermQuery = constructorWrapper(SpanTermQuery);

src.SpanMultiTermQuery = SpanMultiTermQuery;
var spanMultiTermQuery$1 = src.spanMultiTermQuery = constructorWrapper(SpanMultiTermQuery);

src.SpanFirstQuery = SpanFirstQuery;
var spanFirstQuery$1 = src.spanFirstQuery = constructorWrapper(SpanFirstQuery);

src.SpanNearQuery = SpanNearQuery;
var spanNearQuery$1 = src.spanNearQuery = constructorWrapper(SpanNearQuery);

src.SpanOrQuery = SpanOrQuery;
var spanOrQuery$1 = src.spanOrQuery = constructorWrapper(SpanOrQuery);

src.SpanNotQuery = SpanNotQuery;
var spanNotQuery$1 = src.spanNotQuery = constructorWrapper(SpanNotQuery);

src.SpanContainingQuery = SpanContainingQuery;
var spanContainingQuery$1 = src.spanContainingQuery = constructorWrapper(SpanContainingQuery);

src.SpanWithinQuery = SpanWithinQuery;
var spanWithinQuery$1 = src.spanWithinQuery = constructorWrapper(SpanWithinQuery);

src.SpanFieldMaskingQuery = SpanFieldMaskingQuery;
var spanFieldMaskingQuery$1 = src.spanFieldMaskingQuery = constructorWrapper(SpanFieldMaskingQuery);
/* ============ ============ ============ */
/* ======== Metrics Aggregations ======== */
/* ============ ============ ============ */
src.AvgAggregation = AvgAggregation;
var avgAggregation$1 = src.avgAggregation = constructorWrapper(AvgAggregation);

src.CardinalityAggregation = CardinalityAggregation;
var cardinalityAggregation$1 = src.cardinalityAggregation = constructorWrapper(CardinalityAggregation);

src.ExtendedStatsAggregation = ExtendedStatsAggregation;
var extendedStatsAggregation$1 = src.extendedStatsAggregation = constructorWrapper(ExtendedStatsAggregation);

src.GeoBoundsAggregation = GeoBoundsAggregation;
var geoBoundsAggregation$1 = src.geoBoundsAggregation = constructorWrapper(GeoBoundsAggregation);

src.GeoCentroidAggregation = GeoCentroidAggregation;
var geoCentroidAggregation$1 = src.geoCentroidAggregation = constructorWrapper(GeoCentroidAggregation);

src.MaxAggregation = MaxAggregation;
var maxAggregation$1 = src.maxAggregation = constructorWrapper(MaxAggregation);

src.MinAggregation = MinAggregation;
var minAggregation$1 = src.minAggregation = constructorWrapper(MinAggregation);

src.PercentilesAggregation = PercentilesAggregation;
var percentilesAggregation$1 = src.percentilesAggregation = constructorWrapper(PercentilesAggregation);

src.PercentileRanksAggregation = PercentileRanksAggregation;
var percentileRanksAggregation$1 = src.percentileRanksAggregation = constructorWrapper(
    PercentileRanksAggregation
);

src.ScriptedMetricAggregation = ScriptedMetricAggregation;
var scriptedMetricAggregation$1 = src.scriptedMetricAggregation = constructorWrapper(
    ScriptedMetricAggregation
);

src.StatsAggregation = StatsAggregation;
var statsAggregation$1 = src.statsAggregation = constructorWrapper(StatsAggregation);

src.SumAggregation = SumAggregation;
var sumAggregation$1 = src.sumAggregation = constructorWrapper(SumAggregation);

src.TopHitsAggregation = TopHitsAggregation;
var topHitsAggregation$1 = src.topHitsAggregation = constructorWrapper(TopHitsAggregation);

src.ValueCountAggregation = ValueCountAggregation;
var valueCountAggregation$1 = src.valueCountAggregation = constructorWrapper(ValueCountAggregation);

/* ============ ============ ============ */
/* ========= Bucket Aggregations ======== */
/* ============ ============ ============ */
src.AdjacencyMatrixAggregation = AdjacencyMatrixAggregation;
var adjacencyMatrixAggregation$1 = src.adjacencyMatrixAggregation = constructorWrapper(
    AdjacencyMatrixAggregation
);

src.ChildrenAggregation = ChildrenAggregation;
var childrenAggregation$1 = src.childrenAggregation = constructorWrapper(ChildrenAggregation);

src.CompositeAggregation = CompositeAggregation;
var compositeAggregation$1 = src.compositeAggregation = constructorWrapper(CompositeAggregation);

src.DateHistogramAggregation = DateHistogramAggregation;
var dateHistogramAggregation$1 = src.dateHistogramAggregation = constructorWrapper(DateHistogramAggregation);

src.AutoDateHistogramAggregation = AutoDateHistogramAggregation;
var autoDateHistogramAggregation$1 = src.autoDateHistogramAggregation = constructorWrapper(
    AutoDateHistogramAggregation
);

src.VariableWidthHistogramAggregation = VariableWidthHistogramAggregation;
var variableWidthHistogramAggregation$1 = src.variableWidthHistogramAggregation = constructorWrapper(
    VariableWidthHistogramAggregation
);

src.DateRangeAggregation = DateRangeAggregation;
var dateRangeAggregation$1 = src.dateRangeAggregation = constructorWrapper(DateRangeAggregation);

src.DiversifiedSamplerAggregation = DiversifiedSamplerAggregation;
var diversifiedSamplerAggregation$1 = src.diversifiedSamplerAggregation = constructorWrapper(
    DiversifiedSamplerAggregation
);

src.FilterAggregation = FilterAggregation;
var filterAggregation$1 = src.filterAggregation = constructorWrapper(FilterAggregation);

src.FiltersAggregation = FiltersAggregation;
var filtersAggregation$1 = src.filtersAggregation = constructorWrapper(FiltersAggregation);

src.GeoDistanceAggregation = GeoDistanceAggregation;
var geoDistanceAggregation$1 = src.geoDistanceAggregation = constructorWrapper(GeoDistanceAggregation);

src.GeoHashGridAggregation = GeoHashGridAggregation;
var geoHashGridAggregation$1 = src.geoHashGridAggregation = constructorWrapper(GeoHashGridAggregation);

src.GeoHexGridAggregation = GeoHexGridAggregation;
var geoHexGridAggregation$1 = src.geoHexGridAggregation = constructorWrapper(GeoHexGridAggregation);

src.GeoTileGridAggregation = GeoTileGridAggregation;
var geoTileGridAggregation$1 = src.geoTileGridAggregation = constructorWrapper(GeoTileGridAggregation);

src.GlobalAggregation = GlobalAggregation;
var globalAggregation$1 = src.globalAggregation = constructorWrapper(GlobalAggregation);

src.HistogramAggregation = HistogramAggregation;
var histogramAggregation$1 = src.histogramAggregation = constructorWrapper(HistogramAggregation);

src.IpRangeAggregation = IpRangeAggregation;
var ipRangeAggregation$1 = src.ipRangeAggregation = constructorWrapper(IpRangeAggregation);

src.MissingAggregation = MissingAggregation;
var missingAggregation$1 = src.missingAggregation = constructorWrapper(MissingAggregation);

src.NestedAggregation = NestedAggregation;
var nestedAggregation$1 = src.nestedAggregation = constructorWrapper(NestedAggregation);

src.ParentAggregation = ParentAggregation;
var parentAggregation$1 = src.parentAggregation = constructorWrapper(ParentAggregation);

src.RangeAggregation = RangeAggregation;
var rangeAggregation$1 = src.rangeAggregation = constructorWrapper(RangeAggregation);

src.RareTermsAggregation = RareTermsAggregation;
var rareTermsAggregation$1 = src.rareTermsAggregation = constructorWrapper(RareTermsAggregation);

src.ReverseNestedAggregation = ReverseNestedAggregation;
var reverseNestedAggregation$1 = src.reverseNestedAggregation = constructorWrapper(ReverseNestedAggregation);

src.SamplerAggregation = SamplerAggregation;
var samplerAggregation$1 = src.samplerAggregation = constructorWrapper(SamplerAggregation);

src.SignificantTermsAggregation = SignificantTermsAggregation;
var significantTermsAggregation$1 = src.significantTermsAggregation = constructorWrapper(
    SignificantTermsAggregation
);

src.SignificantTextAggregation = SignificantTextAggregation;
var significantTextAggregation$1 = src.significantTextAggregation = constructorWrapper(
    SignificantTextAggregation
);

src.TermsAggregation = TermsAggregation;
var termsAggregation$1 = src.termsAggregation = constructorWrapper(TermsAggregation);

/* ============ ============ ============ */
/* ======== Pipeline Aggregations ======= */
/* ============ ============ ============ */
src.AvgBucketAggregation = AvgBucketAggregation;
var avgBucketAggregation$1 = src.avgBucketAggregation = constructorWrapper(AvgBucketAggregation);

src.DerivativeAggregation = DerivativeAggregation;
var derivativeAggregation$1 = src.derivativeAggregation = constructorWrapper(DerivativeAggregation);

src.MaxBucketAggregation = MaxBucketAggregation;
var maxBucketAggregation$1 = src.maxBucketAggregation = constructorWrapper(MaxBucketAggregation);

src.MinBucketAggregation = MinBucketAggregation;
var minBucketAggregation$1 = src.minBucketAggregation = constructorWrapper(MinBucketAggregation);

src.BucketSortAggregation = BucketSortAggregation;
var bucketSortAggregation$1 = src.bucketSortAggregation = constructorWrapper(BucketSortAggregation);

src.SumBucketAggregation = SumBucketAggregation;
var sumBucketAggregation$1 = src.sumBucketAggregation = constructorWrapper(SumBucketAggregation);

src.StatsBucketAggregation = StatsBucketAggregation;
var statsBucketAggregation$1 = src.statsBucketAggregation = constructorWrapper(StatsBucketAggregation);

src.ExtendedStatsBucketAggregation = ExtendedStatsBucketAggregation;
var extendedStatsBucketAggregation$1 = src.extendedStatsBucketAggregation = constructorWrapper(
    ExtendedStatsBucketAggregation
);

src.PercentilesBucketAggregation = PercentilesBucketAggregation;
var percentilesBucketAggregation$1 = src.percentilesBucketAggregation = constructorWrapper(
    PercentilesBucketAggregation
);

src.MovingAverageAggregation = MovingAverageAggregation;
var movingAverageAggregation$1 = src.movingAverageAggregation = constructorWrapper(MovingAverageAggregation);

src.MovingFunctionAggregation = MovingFunctionAggregation;
var movingFunctionAggregation$1 = src.movingFunctionAggregation = constructorWrapper(
    MovingFunctionAggregation
);

src.CumulativeSumAggregation = CumulativeSumAggregation;
var cumulativeSumAggregation$1 = src.cumulativeSumAggregation = constructorWrapper(CumulativeSumAggregation);

src.BucketScriptAggregation = BucketScriptAggregation;
var bucketScriptAggregation$1 = src.bucketScriptAggregation = constructorWrapper(BucketScriptAggregation);

src.BucketSelectorAggregation = BucketSelectorAggregation;
var bucketSelectorAggregation$1 = src.bucketSelectorAggregation = constructorWrapper(
    BucketSelectorAggregation
);

src.SerialDifferencingAggregation = SerialDifferencingAggregation;
var serialDifferencingAggregation$1 = src.serialDifferencingAggregation = constructorWrapper(
    SerialDifferencingAggregation
);

/* ============ ============ ============ */
/* ========= Matrix Aggregations ======== */
/* ============ ============ ============ */
src.MatrixStatsAggregation = MatrixStatsAggregation;
var matrixStatsAggregation$1 = src.matrixStatsAggregation = constructorWrapper(MatrixStatsAggregation);

/* ============ ============ ============ */
/* ========== Score Functions =========== */
/* ============ ============ ============ */
src.ScriptScoreFunction = ScriptScoreFunction;
var scriptScoreFunction$1 = src.scriptScoreFunction = constructorWrapper(ScriptScoreFunction);

src.WeightScoreFunction = WeightScoreFunction;
var weightScoreFunction$1 = src.weightScoreFunction = constructorWrapper(WeightScoreFunction);

src.RandomScoreFunction = RandomScoreFunction;
var randomScoreFunction$1 = src.randomScoreFunction = constructorWrapper(RandomScoreFunction);

src.FieldValueFactorFunction = FieldValueFactorFunction;
var fieldValueFactorFunction$1 = src.fieldValueFactorFunction = constructorWrapper(FieldValueFactorFunction);

src.DecayScoreFunction = DecayScoreFunction;
var decayScoreFunction$1 = src.decayScoreFunction = constructorWrapper(DecayScoreFunction);

/* ============ ============ ============ */
/* ============= Suggesters ============= */
/* ============ ============ ============ */

src.TermSuggester = TermSuggester;
var termSuggester$1 = src.termSuggester = constructorWrapper(TermSuggester);

src.DirectGenerator = DirectGenerator;
var directGenerator$1 = src.directGenerator = constructorWrapper(DirectGenerator);

src.PhraseSuggester = PhraseSuggester;
var phraseSuggester$1 = src.phraseSuggester = constructorWrapper(PhraseSuggester);

src.CompletionSuggester = CompletionSuggester;
var completionSuggester$1 = src.completionSuggester = constructorWrapper(CompletionSuggester);

/* ============ ============ ============ */
/* ============== Recipes =============== */
/* ============ ============ ============ */

/**
 * Helper recipes for common query use cases.
 *
 * If you have any recipes, please do share or better yet, create a [pull request](https://help.github.com/articles/creating-a-pull-request-from-a-fork/).
 *
 * Recipes:
 * - [`missingQuery`](/#missingquery)
 * - [`randomSortQuery`](/#randomsortquery)
 * - [`filterQuery`](/#filterquery)
 *
 * These can be accessed under the `recipes` namespace or
 * using the `cook[Recipe Name]` alias for ease of use.
 *
 * @example
 * // `recipes` namespace
 * const qry = esb.recipes.missingQuery('user');
 *
 * @example
 * // `cookMissingQuery` alias
 * const qry = esb.cookMissingQuery('user');
 */
var recipes_1 = src.recipes = recipes;
src.cookMissingQuery = recipes.missingQuery;
src.cookRandomSortQuery = recipes.randomSortQuery;
src.cookFilterQuery = recipes.filterQuery;

/* ============ ============ ============ */
/* ============ Miscellaneous =========== */
/* ============ ============ ============ */
src.Highlight = Highlight;
var highlight$1 = src.highlight = constructorWrapper(Highlight);

src.Script = Script;
var script$1 = src.script = constructorWrapper(Script);

src.GeoPoint = GeoPoint;
var geoPoint$1 = src.geoPoint = constructorWrapper(GeoPoint);

src.GeoShape = GeoShape;
var geoShape$1 = src.geoShape = constructorWrapper(GeoShape);

src.IndexedShape = IndexedShape;
var indexedShape$1 = src.indexedShape = constructorWrapper(IndexedShape);

src.Sort = Sort;
var sort$1 = src.sort = constructorWrapper(Sort);

src.Rescore = Rescore;
var rescore$1 = src.rescore = constructorWrapper(Rescore);

src.InnerHits = InnerHits;
var innerHits$1 = src.innerHits = constructorWrapper(InnerHits);

src.SearchTemplate = SearchTemplate;
var searchTemplate$1 = src.searchTemplate = constructorWrapper(SearchTemplate);

src.prettyPrint = function prettyPrint(obj) {
    console.log(JSON.stringify(obj, null, 2));
};

const matchAllQuery = (/* unused pure expression or super */ null && (matchAllQuery$1));
const matchNoneQuery = (/* unused pure expression or super */ null && (matchNoneQuery$1));
const matchQuery = (/* unused pure expression or super */ null && (matchQuery$1));
const matchPhraseQuery = (/* unused pure expression or super */ null && (matchPhraseQuery$1));
const matchPhrasePrefixQuery = (/* unused pure expression or super */ null && (matchPhrasePrefixQuery$1));
const multiMatchQuery = (/* unused pure expression or super */ null && (multiMatchQuery$1));
const commonTermsQuery = (/* unused pure expression or super */ null && (commonTermsQuery$1));
const queryStringQuery = (/* unused pure expression or super */ null && (queryStringQuery$1));
const simpleQueryStringQuery = (/* unused pure expression or super */ null && (simpleQueryStringQuery$1));
const neuralQuery = (/* unused pure expression or super */ null && (neuralQuery$1));
const termQuery = (/* unused pure expression or super */ null && (termQuery$1));
const termsQuery = (/* unused pure expression or super */ null && (termsQuery$1));
const termsSetQuery = (/* unused pure expression or super */ null && (termsSetQuery$1));
const rangeQuery = (/* unused pure expression or super */ null && (rangeQuery$1));
const existsQuery = (/* unused pure expression or super */ null && (existsQuery$1));
const prefixQuery = (/* unused pure expression or super */ null && (prefixQuery$1));
const wildcardQuery = (/* unused pure expression or super */ null && (wildcardQuery$1));
const regexpQuery = (/* unused pure expression or super */ null && (regexpQuery$1));
const fuzzyQuery = (/* unused pure expression or super */ null && (fuzzyQuery$1));
const typeQuery = (/* unused pure expression or super */ null && (typeQuery$1));
const idsQuery = (/* unused pure expression or super */ null && (idsQuery$1));
const constantScoreQuery = (/* unused pure expression or super */ null && (constantScoreQuery$1));
const boolQuery = (/* unused pure expression or super */ null && (boolQuery$1));
const disMaxQuery = (/* unused pure expression or super */ null && (disMaxQuery$1));
const functionScoreQuery = (/* unused pure expression or super */ null && (functionScoreQuery$1));
const boostingQuery = (/* unused pure expression or super */ null && (boostingQuery$1));
const nestedQuery = (/* unused pure expression or super */ null && (nestedQuery$1));
const hasChildQuery = (/* unused pure expression or super */ null && (hasChildQuery$1));
const hasParentQuery = (/* unused pure expression or super */ null && (hasParentQuery$1));
const parentIdQuery = (/* unused pure expression or super */ null && (parentIdQuery$1));
const geoShapeQuery = (/* unused pure expression or super */ null && (geoShapeQuery$1));
const geoBoundingBoxQuery = (/* unused pure expression or super */ null && (geoBoundingBoxQuery$1));
const geoDistanceQuery = (/* unused pure expression or super */ null && (geoDistanceQuery$1));
const geoPolygonQuery = (/* unused pure expression or super */ null && (geoPolygonQuery$1));
const moreLikeThisQuery = (/* unused pure expression or super */ null && (moreLikeThisQuery$1));
const scriptQuery = (/* unused pure expression or super */ null && (scriptQuery$1));
const percolateQuery = (/* unused pure expression or super */ null && (percolateQuery$1));
const distanceFeatureQuery = (/* unused pure expression or super */ null && (distanceFeatureQuery$1));
const spanTermQuery = (/* unused pure expression or super */ null && (spanTermQuery$1));
const spanMultiTermQuery = (/* unused pure expression or super */ null && (spanMultiTermQuery$1));
const spanFirstQuery = (/* unused pure expression or super */ null && (spanFirstQuery$1));
const spanNearQuery = (/* unused pure expression or super */ null && (spanNearQuery$1));
const spanOrQuery = (/* unused pure expression or super */ null && (spanOrQuery$1));
const spanNotQuery = (/* unused pure expression or super */ null && (spanNotQuery$1));
const spanContainingQuery = (/* unused pure expression or super */ null && (spanContainingQuery$1));
const spanWithinQuery = (/* unused pure expression or super */ null && (spanWithinQuery$1));
const spanFieldMaskingQuery = (/* unused pure expression or super */ null && (spanFieldMaskingQuery$1));
const avgAggregation = (/* unused pure expression or super */ null && (avgAggregation$1));
const cardinalityAggregation = (/* unused pure expression or super */ null && (cardinalityAggregation$1));
const extendedStatsAggregation = (/* unused pure expression or super */ null && (extendedStatsAggregation$1));
const geoBoundsAggregation = (/* unused pure expression or super */ null && (geoBoundsAggregation$1));
const geoCentroidAggregation = (/* unused pure expression or super */ null && (geoCentroidAggregation$1));
const maxAggregation = (/* unused pure expression or super */ null && (maxAggregation$1));
const minAggregation = (/* unused pure expression or super */ null && (minAggregation$1));
const percentilesAggregation = (/* unused pure expression or super */ null && (percentilesAggregation$1));
const percentileRanksAggregation = (/* unused pure expression or super */ null && (percentileRanksAggregation$1));
const scriptedMetricAggregation = (/* unused pure expression or super */ null && (scriptedMetricAggregation$1));
const statsAggregation = (/* unused pure expression or super */ null && (statsAggregation$1));
const sumAggregation = (/* unused pure expression or super */ null && (sumAggregation$1));
const topHitsAggregation = (/* unused pure expression or super */ null && (topHitsAggregation$1));
const valueCountAggregation = (/* unused pure expression or super */ null && (valueCountAggregation$1));
const adjacencyMatrixAggregation = (/* unused pure expression or super */ null && (adjacencyMatrixAggregation$1));
const childrenAggregation = (/* unused pure expression or super */ null && (childrenAggregation$1));
const compositeAggregation = (/* unused pure expression or super */ null && (compositeAggregation$1));
const dateHistogramAggregation = (/* unused pure expression or super */ null && (dateHistogramAggregation$1));
const autoDateHistogramAggregation = (/* unused pure expression or super */ null && (autoDateHistogramAggregation$1));
const variableWidthHistogramAggregation = (/* unused pure expression or super */ null && (variableWidthHistogramAggregation$1));
const dateRangeAggregation = (/* unused pure expression or super */ null && (dateRangeAggregation$1));
const diversifiedSamplerAggregation = (/* unused pure expression or super */ null && (diversifiedSamplerAggregation$1));
const filterAggregation = (/* unused pure expression or super */ null && (filterAggregation$1));
const filtersAggregation = (/* unused pure expression or super */ null && (filtersAggregation$1));
const geoDistanceAggregation = (/* unused pure expression or super */ null && (geoDistanceAggregation$1));
const geoHashGridAggregation = (/* unused pure expression or super */ null && (geoHashGridAggregation$1));
const geoHexGridAggregation = (/* unused pure expression or super */ null && (geoHexGridAggregation$1));
const geoTileGridAggregation = (/* unused pure expression or super */ null && (geoTileGridAggregation$1));
const globalAggregation = (/* unused pure expression or super */ null && (globalAggregation$1));
const histogramAggregation = (/* unused pure expression or super */ null && (histogramAggregation$1));
const ipRangeAggregation = (/* unused pure expression or super */ null && (ipRangeAggregation$1));
const missingAggregation = (/* unused pure expression or super */ null && (missingAggregation$1));
const nestedAggregation = (/* unused pure expression or super */ null && (nestedAggregation$1));
const parentAggregation = (/* unused pure expression or super */ null && (parentAggregation$1));
const rangeAggregation = (/* unused pure expression or super */ null && (rangeAggregation$1));
const rareTermsAggregation = (/* unused pure expression or super */ null && (rareTermsAggregation$1));
const reverseNestedAggregation = (/* unused pure expression or super */ null && (reverseNestedAggregation$1));
const samplerAggregation = (/* unused pure expression or super */ null && (samplerAggregation$1));
const significantTermsAggregation = (/* unused pure expression or super */ null && (significantTermsAggregation$1));
const significantTextAggregation = (/* unused pure expression or super */ null && (significantTextAggregation$1));
const termsAggregation = (/* unused pure expression or super */ null && (termsAggregation$1));
const avgBucketAggregation = (/* unused pure expression or super */ null && (avgBucketAggregation$1));
const derivativeAggregation = (/* unused pure expression or super */ null && (derivativeAggregation$1));
const maxBucketAggregation = (/* unused pure expression or super */ null && (maxBucketAggregation$1));
const minBucketAggregation = (/* unused pure expression or super */ null && (minBucketAggregation$1));
const bucketSortAggregation = (/* unused pure expression or super */ null && (bucketSortAggregation$1));
const sumBucketAggregation = (/* unused pure expression or super */ null && (sumBucketAggregation$1));
const statsBucketAggregation = (/* unused pure expression or super */ null && (statsBucketAggregation$1));
const extendedStatsBucketAggregation = (/* unused pure expression or super */ null && (extendedStatsBucketAggregation$1));
const percentilesBucketAggregation = (/* unused pure expression or super */ null && (percentilesBucketAggregation$1));
const movingAverageAggregation = (/* unused pure expression or super */ null && (movingAverageAggregation$1));
const movingFunctionAggregation = (/* unused pure expression or super */ null && (movingFunctionAggregation$1));
const cumulativeSumAggregation = (/* unused pure expression or super */ null && (cumulativeSumAggregation$1));
const bucketScriptAggregation = (/* unused pure expression or super */ null && (bucketScriptAggregation$1));
const bucketSelectorAggregation = (/* unused pure expression or super */ null && (bucketSelectorAggregation$1));
const serialDifferencingAggregation = (/* unused pure expression or super */ null && (serialDifferencingAggregation$1));
const matrixStatsAggregation = (/* unused pure expression or super */ null && (matrixStatsAggregation$1));
const scriptScoreFunction = (/* unused pure expression or super */ null && (scriptScoreFunction$1));
const weightScoreFunction = (/* unused pure expression or super */ null && (weightScoreFunction$1));
const randomScoreFunction = (/* unused pure expression or super */ null && (randomScoreFunction$1));
const fieldValueFactorFunction = (/* unused pure expression or super */ null && (fieldValueFactorFunction$1));
const decayScoreFunction = (/* unused pure expression or super */ null && (decayScoreFunction$1));
const termSuggester = (/* unused pure expression or super */ null && (termSuggester$1));
const directGenerator = (/* unused pure expression or super */ null && (directGenerator$1));
const phraseSuggester = (/* unused pure expression or super */ null && (phraseSuggester$1));
const completionSuggester = (/* unused pure expression or super */ null && (completionSuggester$1));
const highlight = (/* unused pure expression or super */ null && (highlight$1));
const script = (/* unused pure expression or super */ null && (script$1));
const geoPoint = (/* unused pure expression or super */ null && (geoPoint$1));
const geoShape = (/* unused pure expression or super */ null && (geoShape$1));
const indexedShape = (/* unused pure expression or super */ null && (indexedShape$1));
const sort = (/* unused pure expression or super */ null && (sort$1));
const rescore = (/* unused pure expression or super */ null && (rescore$1));
const innerHits = (/* unused pure expression or super */ null && (innerHits$1));
const searchTemplate = (/* unused pure expression or super */ null && (searchTemplate$1));
const withNeural = recipes_1.withNeural;
const withSemantic = recipes_1.withSemantic;


//# sourceMappingURL=index-6bd0eeff.js.map

;// CONCATENATED MODULE: ../../clients/typescript/dist/index.esm.js




const SearchContext = (0,react_.createContext)(undefined);

const SearchProvider = ({ apiKey, url, children, }) => {
    return (react_default().createElement(SearchContext.Provider, { value: { apiKey, url } }, children));
};

/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */

/** Used as the `TypeError` message for "Functions" methods. */
var index_esm_FUNC_ERROR_TEXT = 'Expected a function';

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** `Object#toString` result references. */
var index_esm_symbolTag = '[object Symbol]';

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/** Detect free variable `global` from Node.js. */
var index_esm_freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

/** Detect free variable `self`. */
var index_esm_freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var index_esm_root = index_esm_freeGlobal || index_esm_freeSelf || Function('return this')();

/** Used for built-in method references. */
var index_esm_objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var index_esm_objectToString = index_esm_objectProto.toString;

/* Built-in method references for those with the same name as other `lodash` methods. */
var index_esm_nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return index_esm_root.Date.now();
};

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(index_esm_FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (index_esm_isObject$1(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? index_esm_nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function index_esm_isObject$1(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function index_esm_isObjectLike(value) {
  return !!value && typeof value == 'object';
}

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function index_esm_isSymbol(value) {
  return typeof value == 'symbol' ||
    (index_esm_isObjectLike(value) && index_esm_objectToString.call(value) == index_esm_symbolTag);
}

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (index_esm_isSymbol(value)) {
    return NAN;
  }
  if (index_esm_isObject$1(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = index_esm_isObject$1(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

var lodash_debounce = debounce;

var debounce$1 = /*@__PURE__*/getDefaultExportFromCjs(lodash_debounce);

// eslint-lint-disable-next-line @typescript-eslint/naming-convention
class HTTPError extends Error {
    constructor(response, request, options) {
        const code = (response.status || response.status === 0) ? response.status : '';
        const title = response.statusText || '';
        const status = `${code} ${title}`.trim();
        const reason = status ? `status code ${status}` : 'an unknown error';
        super(`Request failed with ${reason}`);
        Object.defineProperty(this, "response", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "request", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.name = 'HTTPError';
        this.response = response;
        this.request = request;
        this.options = options;
    }
}

class TimeoutError extends Error {
    constructor(request) {
        super('Request timed out');
        Object.defineProperty(this, "request", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.name = 'TimeoutError';
        this.request = request;
    }
}

// eslint-disable-next-line @typescript-eslint/ban-types
const index_esm_isObject = (value) => value !== null && typeof value === 'object';

const validateAndMerge = (...sources) => {
    for (const source of sources) {
        if ((!index_esm_isObject(source) || Array.isArray(source)) && typeof source !== 'undefined') {
            throw new TypeError('The `options` argument must be an object');
        }
    }
    return deepMerge({}, ...sources);
};
const mergeHeaders = (source1 = {}, source2 = {}) => {
    const result = new globalThis.Headers(source1);
    const isHeadersInstance = source2 instanceof globalThis.Headers;
    const source = new globalThis.Headers(source2);
    for (const [key, value] of source.entries()) {
        if ((isHeadersInstance && value === 'undefined') || value === undefined) {
            result.delete(key);
        }
        else {
            result.set(key, value);
        }
    }
    return result;
};
// TODO: Make this strongly-typed (no `any`).
const deepMerge = (...sources) => {
    let returnValue = {};
    let headers = {};
    for (const source of sources) {
        if (Array.isArray(source)) {
            if (!Array.isArray(returnValue)) {
                returnValue = [];
            }
            returnValue = [...returnValue, ...source];
        }
        else if (index_esm_isObject(source)) {
            for (let [key, value] of Object.entries(source)) {
                if (index_esm_isObject(value) && key in returnValue) {
                    value = deepMerge(returnValue[key], value);
                }
                returnValue = { ...returnValue, [key]: value };
            }
            if (index_esm_isObject(source.headers)) {
                headers = mergeHeaders(headers, source.headers);
                returnValue.headers = headers;
            }
        }
    }
    return returnValue;
};

const supportsRequestStreams = (() => {
    let duplexAccessed = false;
    let hasContentType = false;
    const supportsReadableStream = typeof globalThis.ReadableStream === 'function';
    const supportsRequest = typeof globalThis.Request === 'function';
    if (supportsReadableStream && supportsRequest) {
        hasContentType = new globalThis.Request('https://a.com', {
            body: new globalThis.ReadableStream(),
            method: 'POST',
            // @ts-expect-error - Types are outdated.
            get duplex() {
                duplexAccessed = true;
                return 'half';
            },
        }).headers.has('Content-Type');
    }
    return duplexAccessed && !hasContentType;
})();
const supportsAbortController = typeof globalThis.AbortController === 'function';
const supportsResponseStreams = typeof globalThis.ReadableStream === 'function';
const supportsFormData = typeof globalThis.FormData === 'function';
const requestMethods = ['get', 'post', 'put', 'patch', 'head', 'delete'];
const responseTypes = {
    json: 'application/json',
    text: 'text/*',
    formData: 'multipart/form-data',
    arrayBuffer: '*/*',
    blob: '*/*',
};
// The maximum value of a 32bit int (see issue #117)
const maxSafeTimeout = 2147483647;
const stop = Symbol('stop');

const normalizeRequestMethod = (input) => requestMethods.includes(input) ? input.toUpperCase() : input;
const retryMethods = ['get', 'put', 'head', 'delete', 'options', 'trace'];
const retryStatusCodes = [408, 413, 429, 500, 502, 503, 504];
const retryAfterStatusCodes = [413, 429, 503];
const defaultRetryOptions = {
    limit: 2,
    methods: retryMethods,
    statusCodes: retryStatusCodes,
    afterStatusCodes: retryAfterStatusCodes,
    maxRetryAfter: Number.POSITIVE_INFINITY,
    backoffLimit: Number.POSITIVE_INFINITY,
};
const normalizeRetryOptions = (retry = {}) => {
    if (typeof retry === 'number') {
        return {
            ...defaultRetryOptions,
            limit: retry,
        };
    }
    if (retry.methods && !Array.isArray(retry.methods)) {
        throw new Error('retry.methods must be an array');
    }
    if (retry.statusCodes && !Array.isArray(retry.statusCodes)) {
        throw new Error('retry.statusCodes must be an array');
    }
    return {
        ...defaultRetryOptions,
        ...retry,
        afterStatusCodes: retryAfterStatusCodes,
    };
};

// `Promise.race()` workaround (#91)
async function timeout(request, abortController, options) {
    return new Promise((resolve, reject) => {
        const timeoutId = setTimeout(() => {
            if (abortController) {
                abortController.abort();
            }
            reject(new TimeoutError(request));
        }, options.timeout);
        void options
            .fetch(request)
            .then(resolve)
            .catch(reject)
            .then(() => {
            clearTimeout(timeoutId);
        });
    });
}

// DOMException is supported on most modern browsers and Node.js 18+.
// @see https://developer.mozilla.org/en-US/docs/Web/API/DOMException#browser_compatibility
const isDomExceptionSupported = Boolean(globalThis.DOMException);
// TODO: When targeting Node.js 18, use `signal.throwIfAborted()` (https://developer.mozilla.org/en-US/docs/Web/API/AbortSignal/throwIfAborted)
function composeAbortError(signal) {
    /*
    NOTE: Use DomException with AbortError name as specified in MDN docs (https://developer.mozilla.org/en-US/docs/Web/API/AbortController/abort)
    > When abort() is called, the fetch() promise rejects with an Error of type DOMException, with name AbortError.
    */
    if (isDomExceptionSupported) {
        return new DOMException(signal?.reason ?? 'The operation was aborted.', 'AbortError');
    }
    // DOMException not supported. Fall back to use of error and override name.
    const error = new Error(signal?.reason ?? 'The operation was aborted.');
    error.name = 'AbortError';
    return error;
}

// https://github.com/sindresorhus/delay/tree/ab98ae8dfcb38e1593286c94d934e70d14a4e111
async function delay(ms, { signal }) {
    return new Promise((resolve, reject) => {
        if (signal) {
            if (signal.aborted) {
                reject(composeAbortError(signal));
                return;
            }
            signal.addEventListener('abort', handleAbort, { once: true });
        }
        function handleAbort() {
            reject(composeAbortError(signal));
            clearTimeout(timeoutId);
        }
        const timeoutId = setTimeout(() => {
            signal?.removeEventListener('abort', handleAbort);
            resolve();
        }, ms);
    });
}

class Ky {
    // eslint-disable-next-line @typescript-eslint/promise-function-async
    static create(input, options) {
        const ky = new Ky(input, options);
        const fn = async () => {
            if (ky._options.timeout > maxSafeTimeout) {
                throw new RangeError(`The \`timeout\` option cannot be greater than ${maxSafeTimeout}`);
            }
            // Delay the fetch so that body method shortcuts can set the Accept header
            await Promise.resolve();
            let response = await ky._fetch();
            for (const hook of ky._options.hooks.afterResponse) {
                // eslint-disable-next-line no-await-in-loop
                const modifiedResponse = await hook(ky.request, ky._options, ky._decorateResponse(response.clone()));
                if (modifiedResponse instanceof globalThis.Response) {
                    response = modifiedResponse;
                }
            }
            ky._decorateResponse(response);
            if (!response.ok && ky._options.throwHttpErrors) {
                let error = new HTTPError(response, ky.request, ky._options);
                for (const hook of ky._options.hooks.beforeError) {
                    // eslint-disable-next-line no-await-in-loop
                    error = await hook(error);
                }
                throw error;
            }
            // If `onDownloadProgress` is passed, it uses the stream API internally
            /* istanbul ignore next */
            if (ky._options.onDownloadProgress) {
                if (typeof ky._options.onDownloadProgress !== 'function') {
                    throw new TypeError('The `onDownloadProgress` option must be a function');
                }
                if (!supportsResponseStreams) {
                    throw new Error('Streams are not supported in your environment. `ReadableStream` is missing.');
                }
                return ky._stream(response.clone(), ky._options.onDownloadProgress);
            }
            return response;
        };
        const isRetriableMethod = ky._options.retry.methods.includes(ky.request.method.toLowerCase());
        const result = (isRetriableMethod ? ky._retry(fn) : fn());
        for (const [type, mimeType] of Object.entries(responseTypes)) {
            result[type] = async () => {
                // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
                ky.request.headers.set('accept', ky.request.headers.get('accept') || mimeType);
                const awaitedResult = await result;
                const response = awaitedResult.clone();
                if (type === 'json') {
                    if (response.status === 204) {
                        return '';
                    }
                    const arrayBuffer = await response.clone().arrayBuffer();
                    const responseSize = arrayBuffer.byteLength;
                    if (responseSize === 0) {
                        return '';
                    }
                    if (options.parseJson) {
                        return options.parseJson(await response.text());
                    }
                }
                return response[type]();
            };
        }
        return result;
    }
    // eslint-disable-next-line complexity
    constructor(input, options = {}) {
        Object.defineProperty(this, "request", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "abortController", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_retryCount", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: 0
        });
        Object.defineProperty(this, "_input", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        Object.defineProperty(this, "_options", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this._input = input;
        this._options = {
            // TODO: credentials can be removed when the spec change is implemented in all browsers. Context: https://www.chromestatus.com/feature/4539473312350208
            credentials: this._input.credentials || 'same-origin',
            ...options,
            headers: mergeHeaders(this._input.headers, options.headers),
            hooks: deepMerge({
                beforeRequest: [],
                beforeRetry: [],
                beforeError: [],
                afterResponse: [],
            }, options.hooks),
            method: normalizeRequestMethod(options.method ?? this._input.method),
            // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing
            prefixUrl: String(options.prefixUrl || ''),
            retry: normalizeRetryOptions(options.retry),
            throwHttpErrors: options.throwHttpErrors !== false,
            timeout: typeof options.timeout === 'undefined' ? 10000 : options.timeout,
            fetch: options.fetch ?? globalThis.fetch.bind(globalThis),
        };
        if (typeof this._input !== 'string' && !(this._input instanceof URL || this._input instanceof globalThis.Request)) {
            throw new TypeError('`input` must be a string, URL, or Request');
        }
        if (this._options.prefixUrl && typeof this._input === 'string') {
            if (this._input.startsWith('/')) {
                throw new Error('`input` must not begin with a slash when using `prefixUrl`');
            }
            if (!this._options.prefixUrl.endsWith('/')) {
                this._options.prefixUrl += '/';
            }
            this._input = this._options.prefixUrl + this._input;
        }
        if (supportsAbortController) {
            this.abortController = new globalThis.AbortController();
            if (this._options.signal) {
                const originalSignal = this._options.signal;
                this._options.signal.addEventListener('abort', () => {
                    this.abortController.abort(originalSignal.reason);
                });
            }
            this._options.signal = this.abortController.signal;
        }
        if (supportsRequestStreams) {
            // @ts-expect-error - Types are outdated.
            this._options.duplex = 'half';
        }
        this.request = new globalThis.Request(this._input, this._options);
        if (this._options.searchParams) {
            // eslint-disable-next-line unicorn/prevent-abbreviations
            const textSearchParams = typeof this._options.searchParams === 'string'
                ? this._options.searchParams.replace(/^\?/, '')
                : new URLSearchParams(this._options.searchParams).toString();
            // eslint-disable-next-line unicorn/prevent-abbreviations
            const searchParams = '?' + textSearchParams;
            const url = this.request.url.replace(/(?:\?.*?)?(?=#|$)/, searchParams);
            // To provide correct form boundary, Content-Type header should be deleted each time when new Request instantiated from another one
            if (((supportsFormData && this._options.body instanceof globalThis.FormData)
                || this._options.body instanceof URLSearchParams) && !(this._options.headers && this._options.headers['content-type'])) {
                this.request.headers.delete('content-type');
            }
            // The spread of `this.request` is required as otherwise it misses the `duplex` option for some reason and throws.
            this.request = new globalThis.Request(new globalThis.Request(url, { ...this.request }), this._options);
        }
        if (this._options.json !== undefined) {
            this._options.body = JSON.stringify(this._options.json);
            this.request.headers.set('content-type', this._options.headers.get('content-type') ?? 'application/json');
            this.request = new globalThis.Request(this.request, { body: this._options.body });
        }
    }
    _calculateRetryDelay(error) {
        this._retryCount++;
        if (this._retryCount < this._options.retry.limit && !(error instanceof TimeoutError)) {
            if (error instanceof HTTPError) {
                if (!this._options.retry.statusCodes.includes(error.response.status)) {
                    return 0;
                }
                const retryAfter = error.response.headers.get('Retry-After');
                if (retryAfter && this._options.retry.afterStatusCodes.includes(error.response.status)) {
                    let after = Number(retryAfter);
                    if (Number.isNaN(after)) {
                        after = Date.parse(retryAfter) - Date.now();
                    }
                    else {
                        after *= 1000;
                    }
                    if (typeof this._options.retry.maxRetryAfter !== 'undefined' && after > this._options.retry.maxRetryAfter) {
                        return 0;
                    }
                    return after;
                }
                if (error.response.status === 413) {
                    return 0;
                }
            }
            const BACKOFF_FACTOR = 0.3;
            return Math.min(this._options.retry.backoffLimit, BACKOFF_FACTOR * (2 ** (this._retryCount - 1)) * 1000);
        }
        return 0;
    }
    _decorateResponse(response) {
        if (this._options.parseJson) {
            response.json = async () => this._options.parseJson(await response.text());
        }
        return response;
    }
    async _retry(fn) {
        try {
            return await fn();
            // eslint-disable-next-line @typescript-eslint/no-implicit-any-catch
        }
        catch (error) {
            const ms = Math.min(this._calculateRetryDelay(error), maxSafeTimeout);
            if (ms !== 0 && this._retryCount > 0) {
                await delay(ms, { signal: this._options.signal });
                for (const hook of this._options.hooks.beforeRetry) {
                    // eslint-disable-next-line no-await-in-loop
                    const hookResult = await hook({
                        request: this.request,
                        options: this._options,
                        error: error,
                        retryCount: this._retryCount,
                    });
                    // If `stop` is returned from the hook, the retry process is stopped
                    if (hookResult === stop) {
                        return;
                    }
                }
                return this._retry(fn);
            }
            throw error;
        }
    }
    async _fetch() {
        for (const hook of this._options.hooks.beforeRequest) {
            // eslint-disable-next-line no-await-in-loop
            const result = await hook(this.request, this._options);
            if (result instanceof Request) {
                this.request = result;
                break;
            }
            if (result instanceof Response) {
                return result;
            }
        }
        if (this._options.timeout === false) {
            return this._options.fetch(this.request.clone());
        }
        return timeout(this.request.clone(), this.abortController, this._options);
    }
    /* istanbul ignore next */
    _stream(response, onDownloadProgress) {
        const totalBytes = Number(response.headers.get('content-length')) || 0;
        let transferredBytes = 0;
        if (response.status === 204) {
            if (onDownloadProgress) {
                onDownloadProgress({ percent: 1, totalBytes, transferredBytes }, new Uint8Array());
            }
            return new globalThis.Response(null, {
                status: response.status,
                statusText: response.statusText,
                headers: response.headers,
            });
        }
        return new globalThis.Response(new globalThis.ReadableStream({
            async start(controller) {
                const reader = response.body.getReader();
                if (onDownloadProgress) {
                    onDownloadProgress({ percent: 0, transferredBytes: 0, totalBytes }, new Uint8Array());
                }
                async function read() {
                    const { done, value } = await reader.read();
                    if (done) {
                        controller.close();
                        return;
                    }
                    if (onDownloadProgress) {
                        transferredBytes += value.byteLength;
                        const percent = totalBytes === 0 ? 0 : transferredBytes / totalBytes;
                        onDownloadProgress({ percent, transferredBytes, totalBytes }, value);
                    }
                    controller.enqueue(value);
                    await read();
                }
                await read();
            },
        }), {
            status: response.status,
            statusText: response.statusText,
            headers: response.headers,
        });
    }
}

/*! MIT License  Sindre Sorhus */
const createInstance = (defaults) => {
    // eslint-disable-next-line @typescript-eslint/promise-function-async
    const ky = (input, options) => Ky.create(input, validateAndMerge(defaults, options));
    for (const method of requestMethods) {
        // eslint-disable-next-line @typescript-eslint/promise-function-async
        ky[method] = (input, options) => Ky.create(input, validateAndMerge(defaults, options, { method }));
    }
    ky.create = (newDefaults) => createInstance(validateAndMerge(newDefaults));
    ky.extend = (newDefaults) => createInstance(validateAndMerge(defaults, newDefaults));
    ky.stop = stop;
    return ky;
};
const ky = createInstance();
var ky$1 = ky;

class Database {
    constructor(args) {
        this.host = args.host;
        this.user = args.user;
        this.password = args.password;
        this.port = args.port;
        this.dbName = args.dbName;
    }
}
class Table {
    constructor(args) {
        var _a;
        this.table = args.table;
        this.columns = args.columns;
        this.schema = (_a = args.schema) !== null && _a !== void 0 ? _a : "public";
        this.transform = args.transform;
        this.relationship = args.relationship;
        if (args.children)
            this.children = args.children.map((child) => new Table(child));
    }
    toSchema() {
        const schema = {
            table: this.table,
            columns: this.columns,
            schema: this.schema,
        };
        if (this.transform)
            schema.transform = this.transform;
        if (this.relationship)
            schema.relationship = this.relationship;
        if (this.children)
            schema.children = this.children.map((child) => child.toSchema());
        return schema;
    }
}
class Index {
    constructor(indexName, apiKey, url) {
        this.indexName = indexName;
        this.apiKey = apiKey;
        this.url = url;
        this.headers = {
            Authorization: `Bearer ${this.apiKey}`,
            "Content-Type": "application/json",
        };
    }
    async addSource(database, table) {
        const source = {
            index_name: this.indexName,
            source_host: database.host,
            source_user: database.user,
            source_password: database.password,
            source_port: database.port,
            source_dbname: database.dbName,
        };
        const pgsyncSchema = {
            database: database.dbName,
            index: this.indexName,
            nodes: table.toSchema(),
        };
        const json = {
            source,
            pgsync_schema: pgsyncSchema,
        };
        console.log(`Preparing to sync index ${this.indexName} with table ${table.table}. This may take some time if your table is large...`);
        await ky$1
            .post(`${this.url}/index/add_source`, {
            headers: this.headers,
            json: json,
            timeout: false,
        })
            .catch(async (err) => {
            throw new Error(await err.response.text());
        });
    }
    async search(search) {
        const json = {
            dsl: search.toJSON(),
            index_name: this.indexName,
        };
        return await ky$1
            .post(`${this.url}/index/search`, {
            headers: this.headers,
            json: json,
            timeout: false,
        })
            .then((response) => response.json())
            .catch(async (err) => {
            throw new Error(await err.response.text());
        });
    }
    async upsert(documents, ids) {
        const json = { index_name: this.indexName, documents: documents, ids: ids };
        await ky$1
            .post(`${this.url}/index/upsert`, {
            headers: this.headers,
            json: json,
            timeout: false,
        })
            .catch(async (err) => {
            throw new Error(await err.response.text());
        });
    }
    async createField(fieldName, fieldType) {
        const json = {
            index_name: this.indexName,
            field_name: fieldName,
            field_type: fieldType,
        };
        await ky$1
            .post(`${this.url}/index/field/create`, {
            headers: this.headers,
            json: json,
            timeout: false,
        })
            .catch(async (err) => {
            throw new Error(await err.response.text());
        });
    }
    async vectorize(fieldNames) {
        const json = {
            index_name: this.indexName,
            field_names: fieldNames,
        };
        await ky$1
            .post(`${this.url}/index/vectorize`, {
            headers: this.headers,
            json: json,
            timeout: false,
        })
            .catch(async (err) => {
            throw new Error(await err.response.text());
        });
    }
}

class Client {
    constructor(apiKey, url) {
        this.apiKey = apiKey;
        this.url = url;
    }
    async getIndex(indexName) {
        return await ky$1
            .get(`${this.url}/index/${indexName}`, {
            headers: {
                Authorization: `Bearer ${this.apiKey}`,
            },
        })
            .then((response) => {
            if (response.ok)
                return new Index(indexName, this.apiKey, this.url);
        });
    }
    async createIndex(indexName) {
        return await ky$1
            .post(`${this.url}/index/create`, {
            headers: {
                Authorization: `Bearer ${this.apiKey}`,
                "Content-Type": "application/json",
            },
            json: { index_name: indexName },
            timeout: false,
        })
            .then((response) => {
            if (response.ok)
                return new Index(indexName, this.apiKey, this.url);
        });
    }
    async deleteIndex(indexName) {
        await ky$1
            .post(`${this.url}/index/delete`, {
            headers: {
                Authorization: `Bearer ${this.apiKey}`,
                "Content-Type": "application/json",
            },
            json: { index_name: indexName },
            timeout: false,
        })
            .catch(async (err) => {
            throw new Error(await err.response.text());
        });
    }
    async listIndices() {
        return await ky$1
            .get(`${this.url}/client/indices`, {
            headers: {
                Authorization: `Bearer ${this.apiKey}`,
            },
            timeout: false,
        })
            .json()
            .catch(async (err) => {
            throw new Error(await err.response.text());
        });
    }
    async describeIndex(indexName) {
        return await ky$1
            .get(`${this.url}/index/${indexName}`, {
            headers: {
                Authorization: `Bearer ${this.apiKey}`,
            },
            timeout: false,
        })
            .json()
            .catch(async (err) => {
            throw new Error(await err.response.text());
        });
    }
}

const useSearch = ({ indexName, query, throttle }) => {
    const context = (0,react_.useContext)(SearchContext);
    const [data, setData] = (0,react_.useState)();
    const [error, setError] = (0,react_.useState)();
    const [index, setIndex] = (0,react_.useState)();
    if (!(context === null || context === void 0 ? void 0 : context.apiKey) || !(context === null || context === void 0 ? void 0 : context.url)) {
        throw new Error("apiKey and url must be set in SearchProvider");
    }
    const client = new Client(context.apiKey, context.url);
    const prevQueryRef = (0,react_.useRef)();
    const jsonQuery = query === null || query === void 0 ? void 0 : query.toJSON();
    const search = () => {
        const stringifiedQuery = JSON.stringify(jsonQuery);
        if (prevQueryRef.current !== stringifiedQuery &&
            index !== undefined &&
            query !== undefined) {
            setError(undefined);
            index
                .search(query)
                .then((res) => setData(res))
                .catch((err) => setError(err));
            prevQueryRef.current = stringifiedQuery;
        }
        else if (query === undefined) {
            setError(undefined);
            setData(undefined);
        }
    };
    const searchWithDebounce = debounce$1(() => {
        search();
    }, throttle !== null && throttle !== void 0 ? throttle : 1000);
    (0,react_.useEffect)(() => {
        client
            .getIndex(indexName)
            .then((index) => setIndex(index))
            .catch((err) => setError(err));
    }, []);
    (0,react_.useEffect)(() => {
        if (!jsonQuery)
            return;
        searchWithDebounce();
        return () => {
            searchWithDebounce.cancel();
        };
    }, [indexName, jsonQuery]);
    return { data, error };
};

const Search = src.requestBodySearch;


//# sourceMappingURL=index.esm.js.map

;// CONCATENATED MODULE: ../../clients/typescript/dist/helpers/index.esm.js

//# sourceMappingURL=index.esm.js.map

;// CONCATENATED MODULE: ./app/search.tsx








const index = "retake-docs" ?? 0;
const columns =  true ? JSON.parse("[\"title\", \"content\"]") : 0;
const SearchComponent = ()=>{
    const [searchQuery, setSearchQuery] = (0,react_.useState)("");
    const query = searchQuery !== "" ? Search().query(withNeural(searchQuery, columns)) : undefined;
    const { data, error } = useSearch({
        indexName: index,
        query: query,
        throttle: 100
    });
    const hits = data?.hits?.hits;
    const filtered = hits?.filter((hit)=>hit.score >= 0.9);
    const results = filtered?.length ? filtered : hits?.slice(0, Math.min(5, hits.length));
    console.log(results);
    if (error) {
        return /*#__PURE__*/ jsx_runtime_.jsx(dist/* Card */.Zb, {
            children: /*#__PURE__*/ (0,jsx_runtime_.jsxs)(dist/* Text */.xv, {
                children: [
                    "An unexpected error occured: ",
                    error.toString()
                ]
            })
        });
    }
    return /*#__PURE__*/ jsx_runtime_.jsx(transition/* Transition */.u.Root, {
        show: true,
        as: react_.Fragment,
        afterLeave: ()=>setSearchQuery(""),
        appear: true,
        children: /*#__PURE__*/ (0,jsx_runtime_.jsxs)(dialog/* Dialog */.V, {
            as: "div",
            className: "relative z-10",
            onClose: ()=>{},
            children: [
                /*#__PURE__*/ jsx_runtime_.jsx(transition/* Transition */.u.Child, {
                    as: react_.Fragment,
                    enter: "ease-out duration-300",
                    enterFrom: "opacity-0",
                    enterTo: "opacity-100",
                    leave: "ease-in duration-200",
                    leaveFrom: "opacity-100",
                    leaveTo: "opacity-0",
                    children: /*#__PURE__*/ jsx_runtime_.jsx("div", {
                        className: "fixed inset-0 bg-gray-500 bg-opacity-25 transition-opacity"
                    })
                }),
                /*#__PURE__*/ jsx_runtime_.jsx("div", {
                    className: "fixed inset-0 z-10 overflow-y-auto p-4 sm:p-6 md:p-20",
                    children: /*#__PURE__*/ jsx_runtime_.jsx(transition/* Transition */.u.Child, {
                        as: react_.Fragment,
                        enter: "ease-out duration-300",
                        enterFrom: "opacity-0 scale-95",
                        enterTo: "opacity-100 scale-100",
                        leave: "ease-in duration-200",
                        leaveFrom: "opacity-100 scale-100",
                        leaveTo: "opacity-0 scale-95",
                        children: /*#__PURE__*/ jsx_runtime_.jsx(dialog/* Dialog */.V.Panel, {
                            className: "mx-auto max-w-2xl transform divide-y divide-gray-100 overflow-hidden rounded bg-white shadow-2xl transition-all",
                            children: /*#__PURE__*/ (0,jsx_runtime_.jsxs)(combobox/* Combobox */.h, {
                                children: [
                                    /*#__PURE__*/ (0,jsx_runtime_.jsxs)("div", {
                                        className: "relative",
                                        children: [
                                            /*#__PURE__*/ jsx_runtime_.jsx(MagnifyingGlassIcon/* default */.Z, {
                                                className: "pointer-events-none absolute left-4 top-3.5 h-5 w-5 text-gray-400",
                                                "aria-hidden": "true"
                                            }),
                                            /*#__PURE__*/ jsx_runtime_.jsx(combobox/* Combobox */.h.Input, {
                                                className: "h-12 w-full border-0 bg-transparent pl-11 pr-4 text-gray-900 placeholder:text-gray-400 ring-0 outline-0 sm:text-sm",
                                                placeholder: "Search...",
                                                onChange: (event)=>setSearchQuery(event.target.value)
                                            })
                                        ]
                                    }),
                                    results?.length > 0 && searchQuery !== "" && /*#__PURE__*/ jsx_runtime_.jsx(combobox/* Combobox */.h.Options, {
                                        static: true,
                                        className: "max-h-96 scroll-py-3 overflow-y-auto p-3",
                                        children: results.map((item, index)=>/*#__PURE__*/ jsx_runtime_.jsx(combobox/* Combobox */.h.Option, {
                                                value: item,
                                                className: ({ active })=>classnames_default()("flex cursor-default select-none rounded p-3", active && "bg-gray-100"),
                                                children: ({ active })=>/*#__PURE__*/ (0,jsx_runtime_.jsxs)(jsx_runtime_.Fragment, {
                                                        children: [
                                                            /*#__PURE__*/ jsx_runtime_.jsx("div", {
                                                                className: "flex h-10 w-10 flex-none items-center justify-center rounded bg-gray-100",
                                                                children: /*#__PURE__*/ jsx_runtime_.jsx(HashtagIcon/* default */.Z, {
                                                                    className: "h-3 w-3 text-gray-400",
                                                                    "aria-hidden": "true"
                                                                })
                                                            }),
                                                            /*#__PURE__*/ (0,jsx_runtime_.jsxs)("div", {
                                                                className: "ml-4 flex-auto",
                                                                children: [
                                                                    /*#__PURE__*/ jsx_runtime_.jsx("p", {
                                                                        className: classnames_default()("text-sm font-medium", active ? "text-gray-900" : "text-gray-700"),
                                                                        children: item._source.title
                                                                    }),
                                                                    /*#__PURE__*/ jsx_runtime_.jsx("p", {
                                                                        className: classnames_default()("text-sm", active ? "text-gray-700" : "text-gray-500"),
                                                                        children: item._source.content?.slice(0, Math.min(100, item._source.content.length)) ?? ""
                                                                    })
                                                                ]
                                                            })
                                                        ]
                                                    })
                                            }, index))
                                    }),
                                    searchQuery !== "" && results?.length === 0 && /*#__PURE__*/ (0,jsx_runtime_.jsxs)("div", {
                                        className: "px-6 py-14 text-center text-sm sm:px-14",
                                        children: [
                                            /*#__PURE__*/ jsx_runtime_.jsx(ExclamationCircleIcon/* default */.Z, {
                                                type: "outline",
                                                name: "exclamation-circle",
                                                className: "mx-auto h-6 w-6 text-gray-400"
                                            }),
                                            /*#__PURE__*/ jsx_runtime_.jsx("p", {
                                                className: "mt-4 font-semibold text-gray-900",
                                                children: "No results found"
                                            }),
                                            /*#__PURE__*/ jsx_runtime_.jsx("p", {
                                                className: "mt-2 text-gray-500",
                                                children: "No components found for this search term. Please try again."
                                            })
                                        ]
                                    })
                                ]
                            })
                        })
                    })
                })
            ]
        })
    });
};
/* harmony default export */ const search = (SearchComponent);

;// CONCATENATED MODULE: ./app/page.tsx
/* __next_internal_client_entry_do_not_use__ default auto */ 


const Page = ()=>{
    return /*#__PURE__*/ jsx_runtime_.jsx(SearchProvider, {
        apiKey: "641d89a358818294c03eb3abe477a5a9e9f413f62c1fea8645bb10bda64a8c9c" ?? 0,
        url: "http://a15490a5e2ba845dea8135f04c6dec87-dc447a4836969dd1.elb.us-west-1.amazonaws.com/user/4124f15e71d34832923bd95c5f1b2245/api" ?? 0,
        children: /*#__PURE__*/ jsx_runtime_.jsx("div", {
            className: "w-full h-screen p-12 bg-black",
            children: /*#__PURE__*/ jsx_runtime_.jsx(search, {})
        })
    });
};
/* harmony default export */ const page = (Page);


/***/ }),

/***/ 75200:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ RootLayout),
/* harmony export */   metadata: () => (/* binding */ metadata)
/* harmony export */ });
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(56786);
/* harmony import */ var react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var next_font_google_target_css_path_app_layout_tsx_import_Inter_arguments_subsets_latin_variableName_inter___WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(91673);
/* harmony import */ var next_font_google_target_css_path_app_layout_tsx_import_Inter_arguments_subsets_latin_variableName_inter___WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_font_google_target_css_path_app_layout_tsx_import_Inter_arguments_subsets_latin_variableName_inter___WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _globals_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(92817);
/* harmony import */ var _globals_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_globals_css__WEBPACK_IMPORTED_MODULE_1__);



const metadata = {
    title: "Retake Demo App",
    description: "Demo app for Retake Search"
};
function RootLayout({ children }) {
    return /*#__PURE__*/ react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx("html", {
        lang: "en",
        children: /*#__PURE__*/ react_jsx_runtime__WEBPACK_IMPORTED_MODULE_0__.jsx("body", {
            className: (next_font_google_target_css_path_app_layout_tsx_import_Inter_arguments_subsets_latin_variableName_inter___WEBPACK_IMPORTED_MODULE_2___default().className),
            children: children
        })
    });
}


/***/ }),

/***/ 725:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   $$typeof: () => (/* binding */ $$typeof),
/* harmony export */   __esModule: () => (/* binding */ __esModule),
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17814);

const proxy = (0,next_dist_build_webpack_loaders_next_flight_loader_module_proxy__WEBPACK_IMPORTED_MODULE_0__.createProxy)(String.raw`/Users/mingying/Retake/retake/examples/mdx/app/page.tsx`)

// Accessing the __esModule property and exporting $$typeof are required here.
// The __esModule getter forces the proxy target to create the default export
// and the $$typeof value is for rendering logic to determine if the module
// is a client boundary.
const { __esModule, $$typeof } = proxy;
const __default__ = proxy.default;


/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__default__);

/***/ }),

/***/ 92817:
/***/ (() => {



/***/ })

};
;

// load runtime
var __webpack_require__ = require("../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, [795], () => (__webpack_exec__(9792)));
module.exports = __webpack_exports__;

})();