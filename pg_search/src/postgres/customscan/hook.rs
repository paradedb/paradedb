// Copyright (c) 2023-2025 ParadeDB, Inc.
//
// This file is part of ParadeDB - Postgres for Search and Analytics
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

use crate::api::HashMap;
use crate::gucs;
use crate::postgres::customscan::builders::custom_path::{CustomPathBuilder, Flags};
use crate::postgres::customscan::pdbscan::join_qual_inspect::{
    extract_join_search_predicates, JoinSearchPredicates,
};
use crate::postgres::customscan::pdbscan::privdat::PrivateData;
use crate::postgres::customscan::pdbscan::{bms_iter, get_rel_name, get_rel_name_from_rti_list};
use crate::postgres::customscan::CustomScan;
use crate::postgres::rel_get_bm25_index;
use once_cell::sync::Lazy;
use pgrx::{pg_guard, pg_sys, warning, PgMemoryContexts};
use std::collections::hash_map::Entry;

pub fn register_rel_pathlist<CS: CustomScan + 'static>(_: CS) {
    unsafe {
        static mut PREV_HOOKS: Lazy<HashMap<std::any::TypeId, pg_sys::set_rel_pathlist_hook_type>> =
            Lazy::new(Default::default);

        #[pg_guard]
        extern "C-unwind" fn __priv_callback<CS: CustomScan + 'static>(
            root: *mut pg_sys::PlannerInfo,
            rel: *mut pg_sys::RelOptInfo,
            rti: pg_sys::Index,
            rte: *mut pg_sys::RangeTblEntry,
        ) {
            unsafe {
                #[allow(static_mut_refs)]
                if let Some(Some(prev_hook)) = PREV_HOOKS.get(&std::any::TypeId::of::<CS>()) {
                    (*prev_hook)(root, rel, rti, rte);
                }

                paradedb_rel_pathlist_callback::<CS>(root, rel, rti, rte);
            }
        }

        #[allow(static_mut_refs)]
        match PREV_HOOKS.entry(std::any::TypeId::of::<CS>()) {
            Entry::Occupied(_) => panic!("{} is already registered", std::any::type_name::<CS>()),
            Entry::Vacant(entry) => entry.insert(pg_sys::set_rel_pathlist_hook),
        };

        pg_sys::set_rel_pathlist_hook = Some(__priv_callback::<CS>);

        pg_sys::RegisterCustomScanMethods(CS::custom_scan_methods())
    }
}

pub fn register_join_pathlist<CS: CustomScan + 'static>(_: CS) {
    unsafe {
        static mut PREV_JOIN_HOOKS: Lazy<
            HashMap<std::any::TypeId, pg_sys::set_join_pathlist_hook_type>,
        > = Lazy::new(Default::default);

        #[pg_guard]
        extern "C-unwind" fn __priv_join_callback<CS: CustomScan + 'static>(
            root: *mut pg_sys::PlannerInfo,
            joinrel: *mut pg_sys::RelOptInfo,
            outerrel: *mut pg_sys::RelOptInfo,
            innerrel: *mut pg_sys::RelOptInfo,
            jointype: pg_sys::JoinType::Type,
            extra: *mut pg_sys::JoinPathExtraData,
        ) {
            unsafe {
                #[allow(static_mut_refs)]
                if let Some(Some(prev_hook)) = PREV_JOIN_HOOKS.get(&std::any::TypeId::of::<CS>()) {
                    (*prev_hook)(root, joinrel, outerrel, innerrel, jointype, extra);
                }

                paradedb_join_pathlist_callback::<CS>(
                    root, joinrel, outerrel, innerrel, jointype, extra,
                );
            }
        }

        #[allow(static_mut_refs)]
        match PREV_JOIN_HOOKS.entry(std::any::TypeId::of::<CS>()) {
            Entry::Occupied(_) => panic!(
                "{} join hook is already registered",
                std::any::type_name::<CS>()
            ),
            Entry::Vacant(entry) => entry.insert(pg_sys::set_join_pathlist_hook),
        };

        pg_sys::set_join_pathlist_hook = Some(__priv_join_callback::<CS>);
    }
}

/// Check if this join step involves composite relations that we can't handle
unsafe fn involves_composite_relations(
    outerrel: *mut pg_sys::RelOptInfo,
    innerrel: *mut pg_sys::RelOptInfo,
) -> bool {
    // Check if either side has multiple base relations (indicating intermediate results)
    let outer_relid_count = pg_sys::bms_num_members((*outerrel).relids);
    let inner_relid_count = pg_sys::bms_num_members((*innerrel).relids);

    // If either side has more than one relation, it's a composite relation
    outer_relid_count > 1 || inner_relid_count > 1
}

/// Although this hook function can be used to examine, modify, or remove paths generated by the
/// core system, a custom scan provider will typically confine itself to generating CustomPath
/// objects and adding them to rel using add_path. The custom scan provider is responsible for
/// initializing the CustomPath object, which is declared like this:
#[pg_guard]
pub extern "C-unwind" fn paradedb_rel_pathlist_callback<CS: CustomScan>(
    root: *mut pg_sys::PlannerInfo,
    rel: *mut pg_sys::RelOptInfo,
    rti: pg_sys::Index,
    rte: *mut pg_sys::RangeTblEntry,
) {
    unsafe {
        if !gucs::enable_custom_scan() {
            return;
        }

        if let Some(mut path) =
            CS::rel_pathlist_callback(CustomPathBuilder::new::<CS>(root, rel, rti, rte))
        {
            let forced = path.flags & Flags::Force as u32 != 0;
            path.flags ^= Flags::Force as u32; // make sure to clear this flag because it's special to us

            let mut custom_path = PgMemoryContexts::CurrentMemoryContext
                .copy_ptr_into(&mut path, std::mem::size_of_val(&path));

            if (*custom_path).path.parallel_aware {
                // add the partial path since the user-generated plan is parallel aware
                pg_sys::add_partial_path(rel, custom_path.cast());

                // remove all the existing possible paths
                (*rel).pathlist = std::ptr::null_mut();

                // then make another copy of it, increase its costs really, really high and
                // submit it as a regular path too, immediately after clearing out all the other
                // existing possible paths.
                //
                // We don't want postgres to choose this path, but we have to have at least one
                // non-partial path available for it to consider
                let copy = PgMemoryContexts::CurrentMemoryContext
                    .copy_ptr_into(&mut path, std::mem::size_of_val(&path));
                (*copy).path.parallel_aware = false;
                (*copy).path.total_cost = 1000000000.0;
                (*copy).path.startup_cost = 1000000000.0;

                // will be added down below
                custom_path = copy.cast();
            } else if forced {
                // remove all the existing possible paths
                (*rel).pathlist = std::ptr::null_mut();
            }

            // add this path for consideration
            pg_sys::add_path(rel, custom_path.cast());
        }
    }
}

/// Join pathlist callback for custom join optimization
#[pg_guard]
pub extern "C-unwind" fn paradedb_join_pathlist_callback<CS: CustomScan>(
    root: *mut pg_sys::PlannerInfo,
    joinrel: *mut pg_sys::RelOptInfo,
    outerrel: *mut pg_sys::RelOptInfo,
    innerrel: *mut pg_sys::RelOptInfo,
    jointype: pg_sys::JoinType::Type,
    extra: *mut pg_sys::JoinPathExtraData,
) {
    unsafe {
        if !gucs::enable_custom_scan() {
            return;
        }

        // Check if custom join feature is enabled
        if !gucs::is_custom_join_enabled() {
            return;
        }

        warning!(
            "ParadeDB: Join pathlist callback called - jointype: {:?}, outer relids: {:?}, inner relids: {:?}",
            jointype,
            get_rel_name_from_rti_list((*outerrel).relids, root),
            get_rel_name_from_rti_list((*innerrel).relids, root),
        );

        // CRITICAL: Only handle direct joins between base relations
        // Reject joins involving composite relations (intermediate results)
        if involves_composite_relations(outerrel, innerrel) {
            warning!(
                "ParadeDB: Rejecting join with composite relations - we only handle direct base relation joins"
            );
            return;
        }

        // Check join type - only support INNER joins for now
        if jointype != pg_sys::JoinType::JOIN_INNER {
            warning!(
                "ParadeDB: Skipping join - only INNER joins supported currently, got: {:?}",
                jointype
            );
            return;
        }

        // Enhanced feasibility check: Check if we have any relations with BM25 indexes
        // This handles both base relations and composite relations containing base relations
        let outer_has_bm25 = has_any_bm25_index(root, outerrel);
        let inner_has_bm25 = has_any_bm25_index(root, innerrel);

        if !outer_has_bm25 && !inner_has_bm25 {
            warning!("ParadeDB: Skipping join - no BM25 indexes found in either relation");
            return;
        }

        warning!(
            "ParadeDB: Join feasibility check - outer has BM25: {}, inner has BM25: {}",
            outer_has_bm25,
            inner_has_bm25
        );

        // Analyze search predicates in the join BEFORE making final feasibility decision
        let search_predicates =
            extract_join_search_predicates(root, joinrel, outerrel, innerrel, extra);

        if let Some(ref predicates) = search_predicates {
            warning!(
                "ParadeDB: Found search predicates - outer: {}, inner: {}, bilateral: {}",
                predicates.outer_predicates.len(),
                predicates.inner_predicates.len(),
                predicates.has_bilateral_search()
            );

            // Check: ensure at least one side actually uses the search operator
            let outer_has_search = predicates
                .outer_predicates
                .iter()
                .any(|p| p.uses_search_operator);
            let inner_has_search = predicates
                .inner_predicates
                .iter()
                .any(|p| p.uses_search_operator);

            if !outer_has_search && !inner_has_search {
                warning!(
                    "ParadeDB: Skipping custom join - no search operators found (outer: {}, inner: {})",
                    outer_has_search,
                    inner_has_search
                );
                return;
            }

            // Final feasibility check: We need at least one side with both BM25 index AND search predicates
            let outer_feasible = outer_has_bm25 && outer_has_search;
            let inner_feasible = inner_has_bm25 && inner_has_search;

            if !outer_feasible && !inner_feasible {
                warning!(
                    "ParadeDB: Skipping join - no side has both BM25 index and search predicates (outer: BM25={}, search={}; inner: BM25={}, search={})",
                    outer_has_bm25,
                    outer_has_search,
                    inner_has_bm25,
                    inner_has_search
                );
                return;
            }

            warning!(
                "ParadeDB: Join is feasible - outer feasible: {}, inner feasible: {}",
                outer_feasible,
                inner_feasible
            );

            // Log details about the search predicates
            for pred in &predicates.outer_predicates {
                warning!(
                    "ParadeDB: Outer predicate for {} - uses_search: {}",
                    pred.relname,
                    pred.uses_search_operator
                );
            }
            for pred in &predicates.inner_predicates {
                warning!(
                    "ParadeDB: Inner predicate for {} - uses_search: {}",
                    pred.relname,
                    pred.uses_search_operator
                );
            }

            if predicates.has_bilateral_search() {
                warning!("ParadeDB: Bilateral search detected - proceeding with custom join path");
            } else {
                warning!("ParadeDB: Unilateral search detected - proceeding with custom join path");
            }
        } else {
            warning!("ParadeDB: No search predicates found in join - skipping custom join");
            return;
        }

        // Create custom join path
        let custom_path = create_search_join_path::<CS>(
            root,
            joinrel,
            outerrel,
            innerrel,
            jointype,
            extra,
            search_predicates.as_ref(),
        );
        if let Some(path) = custom_path {
            warning!("ParadeDB: Created custom join path, adding to joinrel");
            pg_sys::add_path(joinrel, path.cast());
        } else {
            warning!("ParadeDB: Failed to create custom join path");
        }
    }
}

/// Check if a RelOptInfo represents a base relation (not a join)
unsafe fn is_base_relation(rel: *mut pg_sys::RelOptInfo) -> bool {
    (*rel).reloptkind == pg_sys::RelOptKind::RELOPT_BASEREL
}

/// Check if a base relation has a BM25 index
unsafe fn has_bm25_index(root: *mut pg_sys::PlannerInfo, rel: *mut pg_sys::RelOptInfo) -> bool {
    for rti in bms_iter((*rel).relids) {
        // Get the RTE for this relation
        let rte = pg_sys::rt_fetch(rti, (*(*root).parse).rtable);

        if (*rte).rtekind == pg_sys::RTEKind::RTE_RELATION {
            let relid = (*rte).relid;
            warning!(
                "ParadeDB: Checking relation {} (rti {}) for BM25 index",
                get_rel_name(relid),
                rti
            );

            // Use the existing function to check for BM25 index
            if let Some((_, _)) = rel_get_bm25_index(relid) {
                warning!(
                    "ParadeDB: Found BM25 index for relation {}",
                    get_rel_name(relid)
                );
                return true;
            } else {
                warning!(
                    "ParadeDB: No BM25 index found for relation {}",
                    get_rel_name(relid)
                );
            }
        } else {
            warning!(
                "ParadeDB: RTE {} is not a relation (kind: {:?})",
                rti,
                (*rte).rtekind
            );
        }
    }

    false
}

/// Check if any relation in a RelOptInfo (base or composite) has a BM25 index
/// This handles both base relations and composite relations (joins)
unsafe fn has_any_bm25_index(root: *mut pg_sys::PlannerInfo, rel: *mut pg_sys::RelOptInfo) -> bool {
    let mut found_bm25 = false;
    let mut checked_relations = Vec::new();

    for rti in bms_iter((*rel).relids) {
        // Get the RTE for this relation
        let rte = pg_sys::rt_fetch(rti, (*(*root).parse).rtable);

        if (*rte).rtekind == pg_sys::RTEKind::RTE_RELATION {
            let relid = (*rte).relid;
            let relname = get_rel_name(relid);
            checked_relations.push(relname.clone());

            // Use the existing function to check for BM25 index
            if let Some((_, _)) = rel_get_bm25_index(relid) {
                warning!(
                    "ParadeDB: Found BM25 index for relation {} (rti {})",
                    relname,
                    rti
                );
                found_bm25 = true;
            }
        }
    }

    if !checked_relations.is_empty() {
        warning!(
            "ParadeDB: Checked relations {:?} for BM25 indexes, found: {}",
            checked_relations,
            found_bm25
        );
    }

    found_bm25
}

/// Create a custom join path for search optimization
unsafe fn create_search_join_path<CS: CustomScan>(
    root: *mut pg_sys::PlannerInfo,
    joinrel: *mut pg_sys::RelOptInfo,
    outerrel: *mut pg_sys::RelOptInfo,
    innerrel: *mut pg_sys::RelOptInfo,
    jointype: pg_sys::JoinType::Type,
    extra: *mut pg_sys::JoinPathExtraData,
    search_predicates: Option<&JoinSearchPredicates>,
) -> Option<*mut pg_sys::CustomPath> {
    // For join paths, we need to create a CustomPath with scanrelid = 0
    // This indicates it's a join node, not a scan node

    // Create a dummy RTE for the join (scanrelid = 0 means no specific relation)
    let dummy_rte = std::ptr::null_mut();

    // Build the custom path for the join
    let mut builder: CustomPathBuilder<CS::PrivateData> =
        CustomPathBuilder::new::<CS>(root, joinrel, 0, dummy_rte);

    // Store the search predicates in the private data
    let private_data = unsafe { &mut *(builder.custom_private() as *mut _ as *mut PrivateData) };
    private_data.set_join_search_predicates(search_predicates.cloned());

    // CRITICAL: Store the relation OIDs from the join structure
    // This eliminates the need to infer missing relations during execution
    let outer_relids = extract_relation_oids_from_reloptinfo(root, outerrel);
    let inner_relids = extract_relation_oids_from_reloptinfo(root, innerrel);

    warning!(
        "ParadeDB: Storing join relation OIDs - outer: {:?}, inner: {:?}",
        outer_relids
            .iter()
            .map(|oid| get_rel_name(*oid))
            .collect::<Vec<_>>(),
        inner_relids
            .iter()
            .map(|oid| get_rel_name(*oid))
            .collect::<Vec<_>>()
    );

    // Store ALL relation OIDs from each side (handles both base and composite relations)
    private_data.set_join_outer_relids(outer_relids);
    private_data.set_join_inner_relids(inner_relids);

    // Set basic cost estimates for the join
    // For now, use simple heuristics - this will be refined in later milestones
    let outer_rows = (*outerrel).rows;
    let inner_rows = (*innerrel).rows;

    // Estimate join selectivity (conservative estimate for now)
    let join_selectivity = 0.1; // 10% selectivity
    let estimated_rows = (outer_rows * inner_rows * join_selectivity).max(1.0);

    // Cost model: startup cost + per-tuple processing cost
    let startup_cost = 100.0; // Fixed startup cost for join setup
    let per_tuple_cost = 0.01; // Cost per tuple processed
    let total_cost = startup_cost + (estimated_rows * per_tuple_cost);

    builder = builder
        .set_rows(estimated_rows)
        .set_startup_cost(startup_cost)
        .set_total_cost(total_cost)
        .set_flag(Flags::Projection); // We'll handle projection ourselves

    warning!(
        "ParadeDB: Join path estimates - rows: {:.0}, startup_cost: {:.2}, total_cost: {:.2}",
        estimated_rows,
        startup_cost,
        total_cost
    );

    let mut custom_path = builder.build();

    // CRITICAL: For join nodes, we need to ensure the path target is set correctly
    // The joinrel should already have the correct reltarget that includes columns from both relations
    custom_path.path.pathtarget = (*joinrel).reltarget;

    // Allocate the path in the current memory context
    let path_ptr = PgMemoryContexts::CurrentMemoryContext
        .copy_ptr_into(&mut custom_path, std::mem::size_of_val(&custom_path));

    Some(path_ptr)
}

/// Extract relation OIDs from a RelOptInfo structure
unsafe fn extract_relation_oids_from_reloptinfo(
    root: *mut pg_sys::PlannerInfo,
    rel: *mut pg_sys::RelOptInfo,
) -> Vec<pg_sys::Oid> {
    let mut relids = Vec::new();

    for rti in bms_iter((*rel).relids) {
        let rte = pg_sys::rt_fetch(rti, (*(*root).parse).rtable);
        if (*rte).rtekind == pg_sys::RTEKind::RTE_RELATION {
            relids.push((*rte).relid);
        }
    }

    relids
}
