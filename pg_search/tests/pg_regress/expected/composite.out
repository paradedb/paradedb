-- Composite Type Tests for pg_search
-- Tests basic functionality, features, and error cases
\i common/composite_setup.sql
-- Setup for composite type tests
CREATE EXTENSION IF NOT EXISTS pg_search;
-- Disable parallel workers for deterministic results
SET max_parallel_workers_per_gather = 0;
-- Create a schema for composite tests
DROP SCHEMA IF EXISTS composite_test CASCADE;
CREATE SCHEMA composite_test;
SET search_path TO composite_test, public;
------------------------------------------------------------
-- TEST: Basic composite type indexing
------------------------------------------------------------
-- Create composite type
CREATE TYPE product_info AS (
    name TEXT,
    description TEXT,
    price NUMERIC
);
-- Create table with composite type in index
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name TEXT,
    description TEXT,
    price NUMERIC
);
-- Create index using composite type expression
CREATE INDEX idx_products
ON products
USING bm25 (id, (ROW(name, description, price)::product_info))
WITH (key_field='id');
-- Insert test data
INSERT INTO products (name, description, price) VALUES ('Widget', 'A useful widget', 19.99);
INSERT INTO products (name, description, price) VALUES ('Gadget', 'An amazing gadget', 29.99);
INSERT INTO products (name, description, price) VALUES ('Gizmo', 'A fantastic gizmo', 39.99);
-- Query on composite field - search by name
SELECT COUNT(*) FROM products WHERE id @@@ paradedb.parse('name:Widget');
 count 
-------
     1
(1 row)

-- Query on composite field - search by description
SELECT COUNT(*) FROM products WHERE id @@@ paradedb.parse('description:amazing');
 count 
-------
     1
(1 row)

------------------------------------------------------------
-- TEST: Composite type with more than 32 fields
------------------------------------------------------------
-- Create composite type with 35 text fields
CREATE TYPE large_composite AS (
    field_1 TEXT, field_2 TEXT, field_3 TEXT, field_4 TEXT, field_5 TEXT,
    field_6 TEXT, field_7 TEXT, field_8 TEXT, field_9 TEXT, field_10 TEXT,
    field_11 TEXT, field_12 TEXT, field_13 TEXT, field_14 TEXT, field_15 TEXT,
    field_16 TEXT, field_17 TEXT, field_18 TEXT, field_19 TEXT, field_20 TEXT,
    field_21 TEXT, field_22 TEXT, field_23 TEXT, field_24 TEXT, field_25 TEXT,
    field_26 TEXT, field_27 TEXT, field_28 TEXT, field_29 TEXT, field_30 TEXT,
    field_31 TEXT, field_32 TEXT, field_33 TEXT, field_34 TEXT, field_35 TEXT
);
CREATE TABLE large_table (
    id SERIAL PRIMARY KEY,
    field_1 TEXT, field_2 TEXT, field_3 TEXT, field_4 TEXT, field_5 TEXT,
    field_6 TEXT, field_7 TEXT, field_8 TEXT, field_9 TEXT, field_10 TEXT,
    field_11 TEXT, field_12 TEXT, field_13 TEXT, field_14 TEXT, field_15 TEXT,
    field_16 TEXT, field_17 TEXT, field_18 TEXT, field_19 TEXT, field_20 TEXT,
    field_21 TEXT, field_22 TEXT, field_23 TEXT, field_24 TEXT, field_25 TEXT,
    field_26 TEXT, field_27 TEXT, field_28 TEXT, field_29 TEXT, field_30 TEXT,
    field_31 TEXT, field_32 TEXT, field_33 TEXT, field_34 TEXT, field_35 TEXT
);
CREATE INDEX idx_large ON large_table USING bm25 (id, (ROW(
    field_1, field_2, field_3, field_4, field_5,
    field_6, field_7, field_8, field_9, field_10,
    field_11, field_12, field_13, field_14, field_15,
    field_16, field_17, field_18, field_19, field_20,
    field_21, field_22, field_23, field_24, field_25,
    field_26, field_27, field_28, field_29, field_30,
    field_31, field_32, field_33, field_34, field_35
)::large_composite)) WITH (key_field='id');
INSERT INTO large_table (field_1, field_20, field_35) VALUES ('alpha', 'beta', 'gamma');
SELECT COUNT(*) FROM large_table WHERE id @@@ paradedb.parse('field_1:alpha');
 count 
-------
     1
(1 row)

SELECT COUNT(*) FROM large_table WHERE id @@@ paradedb.parse('field_35:gamma');
 count 
-------
     1
(1 row)

------------------------------------------------------------
-- TEST: Composite type with 100 fields
------------------------------------------------------------
-- Create composite type with 100 text fields (abbreviated for readability)
DO $$
DECLARE
    type_def TEXT := 'CREATE TYPE huge_composite AS (';
    table_def TEXT := 'CREATE TABLE huge_table (id SERIAL PRIMARY KEY';
    index_cols TEXT := '';
BEGIN
    FOR i IN 1..100 LOOP
        type_def := type_def || format('f%s TEXT', lpad(i::text, 3, '0'));
        table_def := table_def || format(', f%s TEXT', lpad(i::text, 3, '0'));
        index_cols := index_cols || format('f%s', lpad(i::text, 3, '0'));
        IF i < 100 THEN
            type_def := type_def || ', ';
            index_cols := index_cols || ', ';
        END IF;
    END LOOP;
    type_def := type_def || ')';
    table_def := table_def || ')';

    EXECUTE type_def;
    EXECUTE table_def;
    EXECUTE format('CREATE INDEX idx_huge ON huge_table USING bm25 (id, (ROW(%s)::huge_composite)) WITH (key_field=''id'')', index_cols);
END $$;
INSERT INTO huge_table (f001, f050, f100) VALUES ('first_field', 'middle_field', 'last_field');
SELECT COUNT(*) FROM huge_table WHERE id @@@ paradedb.parse('f001:first_field');
 count 
-------
     1
(1 row)

SELECT COUNT(*) FROM huge_table WHERE id @@@ paradedb.parse('f050:middle_field');
 count 
-------
     1
(1 row)

SELECT COUNT(*) FROM huge_table WHERE id @@@ paradedb.parse('f100:last_field');
 count 
-------
     1
(1 row)

------------------------------------------------------------
-- TEST: Anonymous ROW expressions are rejected (ERROR expected)
------------------------------------------------------------
CREATE TABLE anon_test (
    id SERIAL PRIMARY KEY,
    a TEXT,
    b TEXT
);
-- This should fail: anonymous ROW without type cast
\set ON_ERROR_STOP off
CREATE INDEX idx_anon_test ON anon_test USING bm25 (id, ROW(a, b)) WITH (key_field='id');
ERROR:  syntax error at or near "(" at character 60
\set ON_ERROR_STOP on
DROP TABLE anon_test;
------------------------------------------------------------
-- TEST: Nested composites are rejected (ERROR expected)
-- NOTE: Domain over composite test removed because error message contains
-- dynamic OID that varies between runs, causing flaky tests.
------------------------------------------------------------
CREATE TYPE inner_composite AS (
    inner_field TEXT
);
CREATE TYPE outer_composite AS (
    outer_field TEXT,
    nested inner_composite
);
CREATE TABLE nested_test (
    id SERIAL PRIMARY KEY,
    field1 TEXT,
    field2 inner_composite
);
-- This should fail: nested composite
\set ON_ERROR_STOP off
CREATE INDEX idx_nested_test ON nested_test USING bm25 (id, (ROW(field1, field2)::outer_composite)) WITH (key_field='id');
ERROR:  Nested composite types are not supported for BM25 indexes.
\set ON_ERROR_STOP on
DROP TABLE nested_test;
DROP TYPE outer_composite;
DROP TYPE inner_composite;
------------------------------------------------------------
-- TEST: Domain over composite is rejected (ERROR expected)
-- Uses DO block to mask dynamic OID in error message
------------------------------------------------------------
CREATE TYPE base_composite AS (
    field1 TEXT,
    field2 TEXT
);
CREATE DOMAIN composite_domain AS base_composite;
CREATE TABLE domain_test (
    id SERIAL PRIMARY KEY,
    data composite_domain
);
-- Use function to catch error and return standardized message
CREATE OR REPLACE FUNCTION test_domain_rejection() RETURNS TEXT AS $$
BEGIN
    EXECUTE 'CREATE INDEX idx_domain_test ON domain_test USING bm25 (id, data) WITH (key_field=''id'')';
    RETURN 'UNEXPECTED: No error raised for domain over composite';
EXCEPTION
    WHEN OTHERS THEN
        IF SQLERRM LIKE '%invalid postgres oid%' THEN
            RETURN 'OK: Domain over composite correctly rejected';
        ELSE
            RETURN 'UNEXPECTED ERROR: ' || SQLERRM;
        END IF;
END;
$$ LANGUAGE plpgsql;
SELECT test_domain_rejection() AS domain_test_result;
              domain_test_result              
----------------------------------------------
 OK: Domain over composite correctly rejected
(1 row)

DROP FUNCTION test_domain_rejection();
DROP TABLE domain_test;
DROP DOMAIN composite_domain;
DROP TYPE base_composite;
------------------------------------------------------------
-- TEST: Duplicate field names between composites rejected (ERROR expected)
------------------------------------------------------------
CREATE TYPE comp_a AS (shared_name TEXT, unique_a TEXT);
CREATE TYPE comp_b AS (shared_name TEXT, unique_b TEXT);
CREATE TABLE dup_comp_test (
    id SERIAL PRIMARY KEY,
    a_field TEXT,
    b_field TEXT,
    c_field TEXT,
    d_field TEXT
);
-- This should fail: 'shared_name' appears in both composites
\set ON_ERROR_STOP off
CREATE INDEX idx_dup_comp ON dup_comp_test USING bm25 (
    id,
    (ROW(a_field, b_field)::comp_a),
    (ROW(c_field, d_field)::comp_b)
) WITH (key_field='id');
ERROR:  indexed attribute shared_name defined more than once
\set ON_ERROR_STOP on
DROP TABLE dup_comp_test;
DROP TYPE comp_a;
DROP TYPE comp_b;
------------------------------------------------------------
-- TEST: Duplicate field with regular column rejected (ERROR expected)
------------------------------------------------------------
CREATE TYPE dup_field_comp AS (name TEXT, other TEXT);
CREATE TABLE dup_field_test (
    id SERIAL PRIMARY KEY,
    name TEXT,
    description TEXT
);
-- This should fail: 'name' appears both as column and composite field
\set ON_ERROR_STOP off
CREATE INDEX idx_dup_field ON dup_field_test USING bm25 (
    id,
    name,
    (ROW(name, description)::dup_field_comp)
) WITH (key_field='id');
ERROR:  indexed attribute name defined more than once
\set ON_ERROR_STOP on
DROP TABLE dup_field_test;
DROP TYPE dup_field_comp;
------------------------------------------------------------
-- TEST: NULL handling in composite fields
------------------------------------------------------------
CREATE TYPE nullable_comp AS (name TEXT, description TEXT, price NUMERIC);
CREATE TABLE nullable_test (
    id SERIAL PRIMARY KEY,
    name TEXT,
    description TEXT,
    price NUMERIC
);
CREATE INDEX idx_nullable ON nullable_test USING bm25 (
    id, (ROW(name, description, price)::nullable_comp)
) WITH (key_field='id');
-- Insert with NULL fields
INSERT INTO nullable_test (name, description, price) VALUES ('Product A', 'Has description', 10.00);
INSERT INTO nullable_test (name, description, price) VALUES ('Product B', NULL, 20.00);
INSERT INTO nullable_test (name, description, price) VALUES ('Product C', 'Another desc', NULL);
-- Should find non-NULL fields
SELECT COUNT(*) FROM nullable_test WHERE id @@@ paradedb.parse('name:"Product C"');
 count 
-------
     1
(1 row)

------------------------------------------------------------
-- TEST: REINDEX with composite types
------------------------------------------------------------
CREATE TYPE reindex_comp AS (name TEXT, description TEXT, price NUMERIC);
CREATE TABLE reindex_test (
    id SERIAL PRIMARY KEY,
    name TEXT,
    description TEXT,
    price NUMERIC
);
CREATE INDEX idx_reindex ON reindex_test USING bm25 (
    id, (ROW(name, description, price)::reindex_comp)
) WITH (key_field='id');
INSERT INTO reindex_test (name, description, price) VALUES ('Widget', 'A useful widget', 19.99);
-- Perform REINDEX
REINDEX INDEX idx_reindex;
-- Verify data is still searchable after REINDEX
SELECT COUNT(*) FROM reindex_test WHERE id @@@ paradedb.parse('name:Widget');
 count 
-------
     1
(1 row)

------------------------------------------------------------
-- TEST: Large values in composite fields
------------------------------------------------------------
CREATE TYPE large_val_comp AS (title TEXT, content TEXT, metadata TEXT);
CREATE TABLE large_val_test (
    id SERIAL PRIMARY KEY,
    title TEXT,
    content TEXT,
    metadata TEXT
);
CREATE INDEX idx_large_val ON large_val_test USING bm25 (
    id, (ROW(title, content, metadata)::large_val_comp)
) WITH (key_field='id');
-- Insert with large text values
INSERT INTO large_val_test (title, content, metadata) VALUES (
    'Large Document',
    repeat('This is a large content block. ', 100),
    repeat('metadata value ', 50)
);
SELECT COUNT(*) FROM large_val_test WHERE id @@@ paradedb.parse('title:Large');
 count 
-------
     1
(1 row)

SELECT COUNT(*) FROM large_val_test;
 count 
-------
     1
(1 row)

------------------------------------------------------------
-- TEST: Full pipeline with complex queries
------------------------------------------------------------
CREATE TYPE full_pipeline_comp AS (name TEXT, description TEXT, category TEXT, tags TEXT);
CREATE TABLE full_pipeline_test (
    id SERIAL PRIMARY KEY,
    name TEXT,
    description TEXT,
    category TEXT,
    tags TEXT
);
CREATE INDEX idx_full_pipeline ON full_pipeline_test USING bm25 (
    id, (ROW(name, description, category, tags)::full_pipeline_comp)
) WITH (key_field='id');
INSERT INTO full_pipeline_test (name, description, category, tags) VALUES
    ('Laptop', 'Powerful laptop computer', 'Electronics', 'computer tech'),
    ('Mouse', 'Wireless mouse', 'Electronics', 'computer accessories'),
    ('Book', 'Programming guide', 'Books', 'computer education'),
    ('Chair', 'Ergonomic office chair', 'Furniture', 'office comfort'),
    ('Desk', 'Standing desk', 'Furniture', 'office workspace');
-- Test search on each field
SELECT COUNT(*) FROM full_pipeline_test WHERE id @@@ paradedb.parse('name:Laptop');
 count 
-------
     1
(1 row)

SELECT COUNT(*) FROM full_pipeline_test WHERE id @@@ paradedb.parse('description:Wireless');
 count 
-------
     1
(1 row)

SELECT COUNT(*) FROM full_pipeline_test WHERE id @@@ paradedb.parse('category:Electronics');
 count 
-------
     2
(1 row)

SELECT COUNT(*) FROM full_pipeline_test WHERE id @@@ paradedb.parse('tags:office');
 count 
-------
     2
(1 row)

-- Test complex queries with OR and AND
SELECT COUNT(*) FROM full_pipeline_test WHERE id @@@ paradedb.boolean(
    should := ARRAY[paradedb.term('category', 'books'), paradedb.term('tags', 'computer')]
);
 count 
-------
     3
(1 row)

SELECT COUNT(*) FROM full_pipeline_test WHERE id @@@ paradedb.boolean(
    must := ARRAY[paradedb.term('category', 'electronics'), paradedb.term('tags', 'accessories')]
);
 count 
-------
     1
(1 row)

-- Verify total rows
SELECT COUNT(*) FROM full_pipeline_test;
 count 
-------
     5
(1 row)

------------------------------------------------------------
-- TEST: Multiple composites with distinct field names
------------------------------------------------------------
CREATE TYPE multi_comp_a AS (title TEXT, body TEXT);
CREATE TYPE multi_comp_b AS (author TEXT, category TEXT);
CREATE TABLE multi_comp_test (
    id SERIAL PRIMARY KEY,
    title TEXT,
    body TEXT,
    author TEXT,
    category TEXT
);
CREATE INDEX idx_multi_comp ON multi_comp_test USING bm25 (
    id,
    (ROW(title, body)::multi_comp_a),
    (ROW(author, category)::multi_comp_b)
) WITH (key_field='id');
INSERT INTO multi_comp_test (title, body, author, category) VALUES
    ('PostgreSQL Guide', 'Learn about databases', 'Alice', 'tech'),
    ('Cooking Tips', 'How to make pasta', 'Bob', 'food');
-- Search works on fields from BOTH composites
SELECT COUNT(*) FROM multi_comp_test WHERE id @@@ paradedb.parse('title:PostgreSQL');
 count 
-------
     1
(1 row)

SELECT COUNT(*) FROM multi_comp_test WHERE id @@@ paradedb.parse('body:pasta');
 count 
-------
     1
(1 row)

SELECT COUNT(*) FROM multi_comp_test WHERE id @@@ paradedb.parse('author:Alice');
 count 
-------
     1
(1 row)

SELECT COUNT(*) FROM multi_comp_test WHERE id @@@ paradedb.parse('category:food');
 count 
-------
     1
(1 row)

-- Cross-composite search
SELECT COUNT(*) FROM multi_comp_test WHERE id @@@ paradedb.boolean(
    must := ARRAY[paradedb.term('title', 'guide'), paradedb.term('author', 'alice')]
);
 count 
-------
     1
(1 row)

------------------------------------------------------------
-- TEST: Complex hybrid index (composite + regular columns)
------------------------------------------------------------
CREATE TYPE hybrid_comp_a AS (description TEXT, notes TEXT);
CREATE TYPE hybrid_comp_b AS (tags TEXT, keywords TEXT);
CREATE TABLE hybrid_test (
    id SERIAL PRIMARY KEY,
    name TEXT,
    description TEXT,
    notes TEXT,
    category TEXT,
    tags TEXT,
    keywords TEXT
);
CREATE INDEX idx_hybrid ON hybrid_test USING bm25 (
    id,
    name,
    (ROW(description, notes)::hybrid_comp_a),
    category,
    (ROW(tags, keywords)::hybrid_comp_b)
) WITH (key_field='id');
INSERT INTO hybrid_test (name, description, notes, category, tags, keywords) VALUES
    ('Widget', 'A useful widget', 'Some notes here', 'tools', 'gadget,useful', 'tool widget'),
    ('Gizmo', 'An amazing gizmo', 'More notes', 'electronics', 'device,tech', 'electronic gizmo');
-- Test regular column
SELECT COUNT(*) FROM hybrid_test WHERE id @@@ paradedb.parse('name:Widget');
 count 
-------
     1
(1 row)

-- Test first composite field
SELECT COUNT(*) FROM hybrid_test WHERE id @@@ paradedb.parse('description:amazing');
 count 
-------
     1
(1 row)

-- Test second regular column
SELECT COUNT(*) FROM hybrid_test WHERE id @@@ paradedb.parse('category:tools');
 count 
-------
     1
(1 row)

-- Test second composite field
SELECT COUNT(*) FROM hybrid_test WHERE id @@@ paradedb.parse('tags:tech');
 count 
-------
     1
(1 row)

-- Test cross-type query
SELECT COUNT(*) FROM hybrid_test WHERE id @@@ paradedb.boolean(
    must := ARRAY[paradedb.term('name', 'widget'), paradedb.term('description', 'useful')]
);
 count 
-------
     1
(1 row)

------------------------------------------------------------
-- TEST: Mixed expressions (columns + IMMUTABLE functions)
------------------------------------------------------------
CREATE TYPE article_search AS (
    title TEXT,
    body TEXT,
    title_upper TEXT
);
CREATE TABLE articles (
    id SERIAL PRIMARY KEY,
    title TEXT,
    body TEXT,
    created_at TIMESTAMP
);
-- Mix simple columns (title, body) with expression (upper - IMMUTABLE function)
CREATE INDEX idx_articles
ON articles
USING bm25 (
    id,
    (ROW(title, body, upper(title))::article_search)
)
WITH (key_field='id');
INSERT INTO articles (title, body, created_at) VALUES
    ('First Post', 'This is the first post', '2024-01-15'),
    ('Second Post', 'This is the second post', '2024-02-20');
-- Search by title (simple column)
SELECT COUNT(*) AS title_search FROM articles WHERE id @@@ paradedb.parse('title:First');
 title_search 
--------------
            1
(1 row)

-- Search by title_upper (expression result - uppercase)
SELECT COUNT(*) AS title_upper_search FROM articles WHERE id @@@ paradedb.parse('title_upper:FIRST');
 title_upper_search 
--------------------
                  1
(1 row)

------------------------------------------------------------
-- TEST: Mixed data sizes (empty, small, medium, large, NULL)
------------------------------------------------------------
CREATE TYPE mixed_composite AS (
    small TEXT,
    medium TEXT,
    large TEXT
);
CREATE TABLE mixed_data (
    id SERIAL PRIMARY KEY,
    small TEXT,
    medium TEXT,
    large TEXT
);
CREATE INDEX idx_mixed
ON mixed_data
USING bm25 (id, (ROW(small, medium, large)::mixed_composite))
WITH (key_field='id');
-- Test with mixed sizes: empty, small, medium, large, NULL
INSERT INTO mixed_data (small, medium, large) VALUES
    ('', 'medium text here', NULL),
    ('tiny', NULL, 'this is a much longer text that goes on and on'),
    (NULL, NULL, NULL);
-- Verify all rows were indexed
SELECT COUNT(*) AS mixed_total FROM mixed_data;
 mixed_total 
-------------
           3
(1 row)

-- Verify searchable non-NULL values
SELECT COUNT(*) AS found_medium FROM mixed_data WHERE id @@@ paradedb.parse('medium:medium');
 found_medium 
--------------
            1
(1 row)

SELECT COUNT(*) AS found_tiny FROM mixed_data WHERE id @@@ paradedb.parse('small:tiny');
 found_tiny 
------------
          1
(1 row)

------------------------------------------------------------
-- TEST: Composite fields exist in index schema
------------------------------------------------------------
CREATE TYPE verify_composite AS (
    first_field TEXT,
    second_field TEXT
);
CREATE TABLE verify_table (
    id SERIAL PRIMARY KEY,
    first_field TEXT,
    second_field TEXT
);
CREATE INDEX verify_idx
ON verify_table
USING bm25 (id, (ROW(first_field, second_field)::verify_composite))
WITH (key_field='id');
-- Verify the composite fields exist in the index schema
SELECT EXISTS (SELECT 1 FROM paradedb.schema('verify_idx') WHERE name = 'first_field') AS first_field_exists;
 first_field_exists 
--------------------
 t
(1 row)

SELECT EXISTS (SELECT 1 FROM paradedb.schema('verify_idx') WHERE name = 'second_field') AS second_field_exists;
 second_field_exists 
---------------------
 t
(1 row)

-- Verify they work by indexing and searching
INSERT INTO verify_table (first_field, second_field) VALUES ('hello', 'world');
SELECT COUNT(*) AS first_field_search FROM verify_table WHERE id @@@ paradedb.parse('first_field:hello');
 first_field_search 
--------------------
                  1
(1 row)

SELECT COUNT(*) AS second_field_search FROM verify_table WHERE id @@@ paradedb.parse('second_field:world');
 second_field_search 
---------------------
                   1
(1 row)

------------------------------------------------------------
-- TEST: Comprehensive schema verification with search
------------------------------------------------------------
CREATE TYPE product_schema AS (
    product_name TEXT,
    product_desc TEXT,
    product_price NUMERIC
);
CREATE TABLE products_schema (
    id SERIAL PRIMARY KEY,
    product_name TEXT,
    product_desc TEXT,
    product_price NUMERIC
);
CREATE INDEX idx_products_schema
ON products_schema
USING bm25 (id, (ROW(product_name, product_desc, product_price)::product_schema))
WITH (key_field='id');
-- Query the index schema to verify composite fields exist
SELECT EXISTS (
    SELECT 1 FROM paradedb.schema('idx_products_schema')
    WHERE name IN ('product_name', 'product_desc', 'product_price')
) AS fields_exist;
 fields_exist 
--------------
 t
(1 row)

-- Verify all three fields are present
SELECT COUNT(*) AS field_count FROM paradedb.schema('idx_products_schema')
WHERE name IN ('product_name', 'product_desc', 'product_price');
 field_count 
-------------
           3
(1 row)

-- Insert data and verify it's searchable on each field
INSERT INTO products_schema (product_name, product_desc, product_price) VALUES ('TestProduct', 'TestDescription', 99.99);
-- Search each field to prove it was indexed
SELECT COUNT(*) AS name_search FROM products_schema WHERE id @@@ paradedb.parse('product_name:TestProduct');
 name_search 
-------------
           1
(1 row)

SELECT COUNT(*) AS desc_search FROM products_schema WHERE id @@@ paradedb.parse('product_desc:TestDescription');
 desc_search 
-------------
           1
(1 row)

------------------------------------------------------------
-- TEST: Tokenizer types in composite fields (pdb.simple)
------------------------------------------------------------
CREATE TYPE tokenized_fields AS (
    title TEXT,
    title_simple pdb.simple
);
CREATE TABLE tokenized_test (
    id SERIAL PRIMARY KEY,
    title TEXT
);
CREATE INDEX idx_tokenized ON tokenized_test USING bm25 (
    id,
    (ROW(title, title)::tokenized_fields)
) WITH (key_field='id');
INSERT INTO tokenized_test (title) VALUES ('Running and Jumping');
-- Search on the simple tokenizer field (lowercased)
SELECT COUNT(*) AS simple_tokenizer_search FROM tokenized_test WHERE id @@@ paradedb.parse('title_simple:running');
 simple_tokenizer_search 
-------------------------
                       1
(1 row)

-- Search on the default text field (should also find it)
SELECT COUNT(*) AS default_text_search FROM tokenized_test WHERE id @@@ paradedb.parse('title:running');
 default_text_search 
---------------------
                   1
(1 row)

------------------------------------------------------------
-- TEST: Ngram tokenizer in composite fields
------------------------------------------------------------
CREATE TYPE ngram_fields AS (
    content TEXT,
    content_ngram pdb.ngram(2, 4)
);
CREATE TABLE ngram_test (
    id SERIAL PRIMARY KEY,
    content TEXT
);
CREATE INDEX idx_ngram ON ngram_test USING bm25 (
    id,
    (ROW(content, content)::ngram_fields)
) WITH (key_field='id');
INSERT INTO ngram_test (content) VALUES ('PostgreSQL database');
-- Search with partial match via ngram - 'gres' should match 'PostgreSQL'
SELECT COUNT(*) AS ngram_partial_search FROM ngram_test WHERE id @@@ paradedb.parse('content_ngram:gres');
 ngram_partial_search 
----------------------
                    1
(1 row)

-- Default text field should NOT match partial 'gres' (no ngram)
SELECT COUNT(*) AS default_no_partial FROM ngram_test WHERE id @@@ paradedb.parse('content:gres');
 default_no_partial 
--------------------
                  0
(1 row)

------------------------------------------------------------
-- TEST: Stemmer tokenizer in composite fields
------------------------------------------------------------
CREATE TYPE stemmer_fields AS (
    content TEXT,
    content_stemmed pdb.simple('stemmer=english')
);
CREATE TABLE stemmer_test (
    id SERIAL PRIMARY KEY,
    content TEXT
);
CREATE INDEX idx_stemmer ON stemmer_test USING bm25 (
    id,
    (ROW(content, content)::stemmer_fields)
) WITH (key_field='id');
INSERT INTO stemmer_test (content) VALUES
    ('running quickly'),
    ('he runs fast');
-- Stemmed search: 'run' should match 'running' and 'runs' (both stem to 'run')
SELECT COUNT(*) AS stemmer_search FROM stemmer_test WHERE id @@@ paradedb.parse('content_stemmed:run');
 stemmer_search 
----------------
              2
(1 row)

-- Default text field should NOT match 'run' (no stemming)
SELECT COUNT(*) AS default_no_stem FROM stemmer_test WHERE id @@@ paradedb.parse('content:run');
 default_no_stem 
-----------------
               0
(1 row)

\i common/composite_cleanup.sql
-- Cleanup for composite type tests
DROP SCHEMA IF EXISTS composite_test CASCADE;
RESET search_path;
