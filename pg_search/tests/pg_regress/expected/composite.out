-- Composite Type Tests for pg_search
-- Tests basic functionality, features, and error cases
\i common/composite_setup.sql
-- Setup for composite type tests
CREATE EXTENSION IF NOT EXISTS pg_search;
-- Disable parallel workers for deterministic results
SET max_parallel_workers_per_gather = 0;
-- Create a schema for composite tests
DROP SCHEMA IF EXISTS composite_test CASCADE;
CREATE SCHEMA composite_test;
SET search_path TO composite_test, public;
------------------------------------------------------------
-- TEST: Basic composite type indexing
------------------------------------------------------------
-- Create composite type
CREATE TYPE product_info AS (
    name TEXT,
    description TEXT,
    price FLOAT
);
-- Create table with composite type in index
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name TEXT,
    description TEXT,
    price FLOAT
);
-- Create index using composite type expression
CREATE INDEX idx_products
ON products
USING bm25 (id, (ROW(name, description, price)::product_info))
WITH (key_field='id');
-- Insert test data
INSERT INTO products (name, description, price) VALUES ('Widget', 'A useful widget', 19.99);
INSERT INTO products (name, description, price) VALUES ('Gadget', 'An amazing gadget', 29.99);
INSERT INTO products (name, description, price) VALUES ('Gizmo', 'A fantastic gizmo', 39.99);
-- Query on composite field - search by name
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) FROM products WHERE id @@@ pdb.parse('name:Widget');
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on products
         Table: products
         Index: idx_products
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"name:Widget","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) FROM products WHERE id @@@ pdb.parse('name:Widget');
 count 
-------
     1
(1 row)

-- Query on composite field - search by description
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) FROM products WHERE id @@@ pdb.parse('description:amazing');
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on products
         Table: products
         Index: idx_products
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"description:amazing","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) FROM products WHERE id @@@ pdb.parse('description:amazing');
 count 
-------
     1
(1 row)

------------------------------------------------------------
-- TEST: Composite type with more than 32 fields
------------------------------------------------------------
-- Create composite type with 35 text fields
CREATE TYPE large_composite AS (
    field_1 TEXT, field_2 TEXT, field_3 TEXT, field_4 TEXT, field_5 TEXT,
    field_6 TEXT, field_7 TEXT, field_8 TEXT, field_9 TEXT, field_10 TEXT,
    field_11 TEXT, field_12 TEXT, field_13 TEXT, field_14 TEXT, field_15 TEXT,
    field_16 TEXT, field_17 TEXT, field_18 TEXT, field_19 TEXT, field_20 TEXT,
    field_21 TEXT, field_22 TEXT, field_23 TEXT, field_24 TEXT, field_25 TEXT,
    field_26 TEXT, field_27 TEXT, field_28 TEXT, field_29 TEXT, field_30 TEXT,
    field_31 TEXT, field_32 TEXT, field_33 TEXT, field_34 TEXT, field_35 TEXT
);
CREATE TABLE large_table (
    id SERIAL PRIMARY KEY,
    field_1 TEXT, field_2 TEXT, field_3 TEXT, field_4 TEXT, field_5 TEXT,
    field_6 TEXT, field_7 TEXT, field_8 TEXT, field_9 TEXT, field_10 TEXT,
    field_11 TEXT, field_12 TEXT, field_13 TEXT, field_14 TEXT, field_15 TEXT,
    field_16 TEXT, field_17 TEXT, field_18 TEXT, field_19 TEXT, field_20 TEXT,
    field_21 TEXT, field_22 TEXT, field_23 TEXT, field_24 TEXT, field_25 TEXT,
    field_26 TEXT, field_27 TEXT, field_28 TEXT, field_29 TEXT, field_30 TEXT,
    field_31 TEXT, field_32 TEXT, field_33 TEXT, field_34 TEXT, field_35 TEXT
);
CREATE INDEX idx_large ON large_table USING bm25 (id, (ROW(
    field_1, field_2, field_3, field_4, field_5,
    field_6, field_7, field_8, field_9, field_10,
    field_11, field_12, field_13, field_14, field_15,
    field_16, field_17, field_18, field_19, field_20,
    field_21, field_22, field_23, field_24, field_25,
    field_26, field_27, field_28, field_29, field_30,
    field_31, field_32, field_33, field_34, field_35
)::large_composite)) WITH (key_field='id');
INSERT INTO large_table (field_1, field_20, field_35) VALUES ('alpha', 'beta', 'gamma');
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) FROM large_table WHERE id @@@ pdb.parse('field_1:alpha');
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on large_table
         Table: large_table
         Index: idx_large
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"field_1:alpha","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) FROM large_table WHERE id @@@ pdb.parse('field_1:alpha');
 count 
-------
     1
(1 row)

EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) FROM large_table WHERE id @@@ pdb.parse('field_35:gamma');
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on large_table
         Table: large_table
         Index: idx_large
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"field_35:gamma","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) FROM large_table WHERE id @@@ pdb.parse('field_35:gamma');
 count 
-------
     1
(1 row)

------------------------------------------------------------
-- TEST: Composite type with 100 fields
------------------------------------------------------------
-- Create composite type with 100 text fields (abbreviated for readability)
DO $$
DECLARE
    type_def TEXT := 'CREATE TYPE huge_composite AS (';
    table_def TEXT := 'CREATE TABLE huge_table (id SERIAL PRIMARY KEY';
    index_cols TEXT := '';
BEGIN
    FOR i IN 1..100 LOOP
        type_def := type_def || format('f%s TEXT', lpad(i::text, 3, '0'));
        table_def := table_def || format(', f%s TEXT', lpad(i::text, 3, '0'));
        index_cols := index_cols || format('f%s', lpad(i::text, 3, '0'));
        IF i < 100 THEN
            type_def := type_def || ', ';
            index_cols := index_cols || ', ';
        END IF;
    END LOOP;
    type_def := type_def || ')';
    table_def := table_def || ')';

    EXECUTE type_def;
    EXECUTE table_def;
    EXECUTE format('CREATE INDEX idx_huge ON huge_table USING bm25 (id, (ROW(%s)::huge_composite)) WITH (key_field=''id'')', index_cols);
END $$;
INSERT INTO huge_table (f001, f050, f100) VALUES ('first_field', 'middle_field', 'last_field');
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) FROM huge_table WHERE id @@@ pdb.parse('f001:first_field');
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on huge_table
         Table: huge_table
         Index: idx_huge
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"f001:first_field","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) FROM huge_table WHERE id @@@ pdb.parse('f001:first_field');
 count 
-------
     1
(1 row)

EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) FROM huge_table WHERE id @@@ pdb.parse('f050:middle_field');
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on huge_table
         Table: huge_table
         Index: idx_huge
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"f050:middle_field","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) FROM huge_table WHERE id @@@ pdb.parse('f050:middle_field');
 count 
-------
     1
(1 row)

EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) FROM huge_table WHERE id @@@ pdb.parse('f100:last_field');
                                                             QUERY PLAN                                                              
-------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on huge_table
         Table: huge_table
         Index: idx_huge
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"f100:last_field","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) FROM huge_table WHERE id @@@ pdb.parse('f100:last_field');
 count 
-------
     1
(1 row)

------------------------------------------------------------
-- TEST: Anonymous ROW expressions are rejected (ERROR expected)
------------------------------------------------------------
CREATE TABLE anon_test (
    id SERIAL PRIMARY KEY,
    a TEXT,
    b TEXT
);
-- This should fail: anonymous ROW without type cast
\set ON_ERROR_STOP off
CREATE INDEX idx_anon_test ON anon_test USING bm25 (id, ROW(a, b)) WITH (key_field='id');
ERROR:  syntax error at or near "(" at character 60
\set ON_ERROR_STOP on
DROP TABLE anon_test;
------------------------------------------------------------
-- TEST: Nested composites are rejected (ERROR expected)
-- NOTE: Domain over composite test removed because error message contains
-- dynamic OID that varies between runs, causing flaky tests.
------------------------------------------------------------
CREATE TYPE inner_composite AS (
    inner_field TEXT
);
CREATE TYPE outer_composite AS (
    outer_field TEXT,
    nested inner_composite
);
CREATE TABLE nested_test (
    id SERIAL PRIMARY KEY,
    field1 TEXT,
    field2 inner_composite
);
-- This should fail: nested composite
\set ON_ERROR_STOP off
CREATE INDEX idx_nested_test ON nested_test USING bm25 (id, (ROW(field1, field2)::outer_composite)) WITH (key_field='id');
ERROR:  Nested composite types are not supported for BM25 indexes.
\set ON_ERROR_STOP on
DROP TABLE nested_test;
DROP TYPE outer_composite;
DROP TYPE inner_composite;
------------------------------------------------------------
-- TEST: Domain over composite is rejected (ERROR expected)
-- Uses DO block to mask dynamic OID in error message
------------------------------------------------------------
CREATE TYPE base_composite AS (
    field1 TEXT,
    field2 TEXT
);
CREATE DOMAIN composite_domain AS base_composite;
CREATE TABLE domain_test (
    id SERIAL PRIMARY KEY,
    data composite_domain
);
-- Use function to catch error and return standardized message
CREATE OR REPLACE FUNCTION test_domain_rejection() RETURNS TEXT AS $$
BEGIN
    EXECUTE 'CREATE INDEX idx_domain_test ON domain_test USING bm25 (id, data) WITH (key_field=''id'')';
    RETURN 'UNEXPECTED: No error raised for domain over composite';
EXCEPTION
    WHEN OTHERS THEN
        IF SQLERRM LIKE '%invalid postgres oid%' THEN
            RETURN 'OK: Domain over composite correctly rejected';
        ELSE
            RETURN 'UNEXPECTED ERROR: ' || SQLERRM;
        END IF;
END;
$$ LANGUAGE plpgsql;
SELECT test_domain_rejection() AS domain_test_result;
              domain_test_result              
----------------------------------------------
 OK: Domain over composite correctly rejected
(1 row)

DROP FUNCTION test_domain_rejection();
DROP TABLE domain_test;
DROP DOMAIN composite_domain;
DROP TYPE base_composite;
------------------------------------------------------------
-- TEST: Duplicate field names between composites rejected (ERROR expected)
------------------------------------------------------------
CREATE TYPE comp_a AS (shared_name TEXT, unique_a TEXT);
CREATE TYPE comp_b AS (shared_name TEXT, unique_b TEXT);
CREATE TABLE dup_comp_test (
    id SERIAL PRIMARY KEY,
    a_field TEXT,
    b_field TEXT,
    c_field TEXT,
    d_field TEXT
);
-- This should fail: 'shared_name' appears in both composites
\set ON_ERROR_STOP off
CREATE INDEX idx_dup_comp ON dup_comp_test USING bm25 (
    id,
    (ROW(a_field, b_field)::comp_a),
    (ROW(c_field, d_field)::comp_b)
) WITH (key_field='id');
ERROR:  indexed attribute shared_name defined more than once
\set ON_ERROR_STOP on
DROP TABLE dup_comp_test;
DROP TYPE comp_a;
DROP TYPE comp_b;
------------------------------------------------------------
-- TEST: Duplicate field with regular column rejected (ERROR expected)
------------------------------------------------------------
CREATE TYPE dup_field_comp AS (name TEXT, other TEXT);
CREATE TABLE dup_field_test (
    id SERIAL PRIMARY KEY,
    name TEXT,
    description TEXT
);
-- This should fail: 'name' appears both as column and composite field
\set ON_ERROR_STOP off
CREATE INDEX idx_dup_field ON dup_field_test USING bm25 (
    id,
    name,
    (ROW(name, description)::dup_field_comp)
) WITH (key_field='id');
ERROR:  indexed attribute name defined more than once
\set ON_ERROR_STOP on
DROP TABLE dup_field_test;
DROP TYPE dup_field_comp;
------------------------------------------------------------
-- TEST: NULL handling in composite fields
------------------------------------------------------------
CREATE TYPE nullable_comp AS (name TEXT, description TEXT, price FLOAT);
CREATE TABLE nullable_test (
    id SERIAL PRIMARY KEY,
    name TEXT,
    description TEXT,
    price FLOAT
);
CREATE INDEX idx_nullable ON nullable_test USING bm25 (
    id, (ROW(name, description, price)::nullable_comp)
) WITH (key_field='id');
-- Insert with NULL fields
INSERT INTO nullable_test (name, description, price) VALUES ('Product A', 'Has description', 10.00);
INSERT INTO nullable_test (name, description, price) VALUES ('Product B', NULL, 20.00);
INSERT INTO nullable_test (name, description, price) VALUES ('Product C', 'Another desc', NULL);
-- Should find non-NULL fields
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) FROM nullable_test WHERE id @@@ pdb.parse('name:"Product C"');
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on nullable_test
         Table: nullable_test
         Index: idx_nullable
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"name:\"Product C\"","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) FROM nullable_test WHERE id @@@ pdb.parse('name:"Product C"');
 count 
-------
     1
(1 row)

------------------------------------------------------------
-- TEST: REINDEX with composite types
------------------------------------------------------------
CREATE TYPE reindex_comp AS (name TEXT, description TEXT, price FLOAT);
CREATE TABLE reindex_test (
    id SERIAL PRIMARY KEY,
    name TEXT,
    description TEXT,
    price FLOAT
);
CREATE INDEX idx_reindex ON reindex_test USING bm25 (
    id, (ROW(name, description, price)::reindex_comp)
) WITH (key_field='id');
INSERT INTO reindex_test (name, description, price) VALUES ('Widget', 'A useful widget', 19.99);
-- Perform REINDEX
REINDEX INDEX idx_reindex;
-- Verify data is still searchable after REINDEX
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) FROM reindex_test WHERE id @@@ pdb.parse('name:Widget');
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on reindex_test
         Table: reindex_test
         Index: idx_reindex
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"name:Widget","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) FROM reindex_test WHERE id @@@ pdb.parse('name:Widget');
 count 
-------
     1
(1 row)

------------------------------------------------------------
-- TEST: Large values in composite fields
------------------------------------------------------------
CREATE TYPE large_val_comp AS (title TEXT, content TEXT, metadata TEXT);
CREATE TABLE large_val_test (
    id SERIAL PRIMARY KEY,
    title TEXT,
    content TEXT,
    metadata TEXT
);
CREATE INDEX idx_large_val ON large_val_test USING bm25 (
    id, (ROW(title, content, metadata)::large_val_comp)
) WITH (key_field='id');
-- Insert with large text values
INSERT INTO large_val_test (title, content, metadata) VALUES (
    'Large Document',
    repeat('This is a large content block. ', 100),
    repeat('metadata value ', 50)
);
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) FROM large_val_test WHERE id @@@ pdb.parse('title:Large');
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on large_val_test
         Table: large_val_test
         Index: idx_large_val
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"title:Large","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) FROM large_val_test WHERE id @@@ pdb.parse('title:Large');
 count 
-------
     1
(1 row)

SELECT COUNT(*) FROM large_val_test;
 count 
-------
     1
(1 row)

------------------------------------------------------------
-- TEST: Full pipeline with complex queries
------------------------------------------------------------
CREATE TYPE full_pipeline_comp AS (name TEXT, description TEXT, category TEXT, tags TEXT);
CREATE TABLE full_pipeline_test (
    id SERIAL PRIMARY KEY,
    name TEXT,
    description TEXT,
    category TEXT,
    tags TEXT
);
CREATE INDEX idx_full_pipeline ON full_pipeline_test USING bm25 (
    id, (ROW(name, description, category, tags)::full_pipeline_comp)
) WITH (key_field='id');
INSERT INTO full_pipeline_test (name, description, category, tags) VALUES
    ('Laptop', 'Powerful laptop computer', 'Electronics', 'computer tech'),
    ('Mouse', 'Wireless mouse', 'Electronics', 'computer accessories'),
    ('Book', 'Programming guide', 'Books', 'computer education'),
    ('Chair', 'Ergonomic office chair', 'Furniture', 'office comfort'),
    ('Desk', 'Standing desk', 'Furniture', 'office workspace');
-- Test search on each field
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) FROM full_pipeline_test WHERE id @@@ pdb.parse('name:Laptop');
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on full_pipeline_test
         Table: full_pipeline_test
         Index: idx_full_pipeline
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"name:Laptop","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) FROM full_pipeline_test WHERE id @@@ pdb.parse('name:Laptop');
 count 
-------
     1
(1 row)

EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) FROM full_pipeline_test WHERE id @@@ pdb.parse('description:Wireless');
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on full_pipeline_test
         Table: full_pipeline_test
         Index: idx_full_pipeline
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"description:Wireless","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) FROM full_pipeline_test WHERE id @@@ pdb.parse('description:Wireless');
 count 
-------
     1
(1 row)

EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) FROM full_pipeline_test WHERE id @@@ pdb.parse('category:Electronics');
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on full_pipeline_test
         Table: full_pipeline_test
         Index: idx_full_pipeline
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"category:Electronics","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) FROM full_pipeline_test WHERE id @@@ pdb.parse('category:Electronics');
 count 
-------
     2
(1 row)

EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) FROM full_pipeline_test WHERE id @@@ pdb.parse('tags:office');
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on full_pipeline_test
         Table: full_pipeline_test
         Index: idx_full_pipeline
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"tags:office","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) FROM full_pipeline_test WHERE id @@@ pdb.parse('tags:office');
 count 
-------
     2
(1 row)

-- Test complex queries with OR and AND using pdb.parse with tantivy syntax
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) FROM full_pipeline_test WHERE id @@@ pdb.parse('category:books OR tags:computer');
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on full_pipeline_test
         Table: full_pipeline_test
         Index: idx_full_pipeline
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"category:books OR tags:computer","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) FROM full_pipeline_test WHERE id @@@ pdb.parse('category:books OR tags:computer');
 count 
-------
     3
(1 row)

EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) FROM full_pipeline_test WHERE id @@@ pdb.parse('category:electronics AND tags:accessories');
                                                                          QUERY PLAN                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on full_pipeline_test
         Table: full_pipeline_test
         Index: idx_full_pipeline
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"category:electronics AND tags:accessories","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) FROM full_pipeline_test WHERE id @@@ pdb.parse('category:electronics AND tags:accessories');
 count 
-------
     1
(1 row)

-- Verify total rows
SELECT COUNT(*) FROM full_pipeline_test;
 count 
-------
     5
(1 row)

------------------------------------------------------------
-- TEST: Multiple composites with distinct field names
------------------------------------------------------------
CREATE TYPE multi_comp_a AS (title TEXT, body TEXT);
CREATE TYPE multi_comp_b AS (author TEXT, category TEXT);
CREATE TABLE multi_comp_test (
    id SERIAL PRIMARY KEY,
    title TEXT,
    body TEXT,
    author TEXT,
    category TEXT
);
CREATE INDEX idx_multi_comp ON multi_comp_test USING bm25 (
    id,
    (ROW(title, body)::multi_comp_a),
    (ROW(author, category)::multi_comp_b)
) WITH (key_field='id');
INSERT INTO multi_comp_test (title, body, author, category) VALUES
    ('PostgreSQL Guide', 'Learn about databases', 'Alice', 'tech'),
    ('Cooking Tips', 'How to make pasta', 'Bob', 'food');
-- Search works on fields from BOTH composites
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) FROM multi_comp_test WHERE id @@@ pdb.parse('title:PostgreSQL');
                                                              QUERY PLAN                                                              
--------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on multi_comp_test
         Table: multi_comp_test
         Index: idx_multi_comp
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"title:PostgreSQL","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) FROM multi_comp_test WHERE id @@@ pdb.parse('title:PostgreSQL');
 count 
-------
     1
(1 row)

EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) FROM multi_comp_test WHERE id @@@ pdb.parse('body:pasta');
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on multi_comp_test
         Table: multi_comp_test
         Index: idx_multi_comp
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"body:pasta","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) FROM multi_comp_test WHERE id @@@ pdb.parse('body:pasta');
 count 
-------
     1
(1 row)

EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) FROM multi_comp_test WHERE id @@@ pdb.parse('author:Alice');
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on multi_comp_test
         Table: multi_comp_test
         Index: idx_multi_comp
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"author:Alice","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) FROM multi_comp_test WHERE id @@@ pdb.parse('author:Alice');
 count 
-------
     1
(1 row)

EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) FROM multi_comp_test WHERE id @@@ pdb.parse('category:food');
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on multi_comp_test
         Table: multi_comp_test
         Index: idx_multi_comp
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"category:food","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) FROM multi_comp_test WHERE id @@@ pdb.parse('category:food');
 count 
-------
     1
(1 row)

-- Cross-composite search using pdb.parse with AND
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) FROM multi_comp_test WHERE id @@@ pdb.parse('title:guide AND author:alice');
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on multi_comp_test
         Table: multi_comp_test
         Index: idx_multi_comp
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"title:guide AND author:alice","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) FROM multi_comp_test WHERE id @@@ pdb.parse('title:guide AND author:alice');
 count 
-------
     1
(1 row)

------------------------------------------------------------
-- TEST: Complex hybrid index (composite + regular columns)
------------------------------------------------------------
CREATE TYPE hybrid_comp_a AS (description TEXT, notes TEXT);
CREATE TYPE hybrid_comp_b AS (tags TEXT, keywords TEXT);
CREATE TABLE hybrid_test (
    id SERIAL PRIMARY KEY,
    name TEXT,
    description TEXT,
    notes TEXT,
    category TEXT,
    tags TEXT,
    keywords TEXT
);
CREATE INDEX idx_hybrid ON hybrid_test USING bm25 (
    id,
    name,
    (ROW(description, notes)::hybrid_comp_a),
    category,
    (ROW(tags, keywords)::hybrid_comp_b)
) WITH (key_field='id');
INSERT INTO hybrid_test (name, description, notes, category, tags, keywords) VALUES
    ('Widget', 'A useful widget', 'Some notes here', 'tools', 'gadget,useful', 'tool widget'),
    ('Gizmo', 'An amazing gizmo', 'More notes', 'electronics', 'device,tech', 'electronic gizmo');
-- Test regular column
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) FROM hybrid_test WHERE id @@@ pdb.parse('name:Widget');
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on hybrid_test
         Table: hybrid_test
         Index: idx_hybrid
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"name:Widget","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) FROM hybrid_test WHERE id @@@ pdb.parse('name:Widget');
 count 
-------
     1
(1 row)

-- Test first composite field
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) FROM hybrid_test WHERE id @@@ pdb.parse('description:amazing');
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on hybrid_test
         Table: hybrid_test
         Index: idx_hybrid
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"description:amazing","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) FROM hybrid_test WHERE id @@@ pdb.parse('description:amazing');
 count 
-------
     1
(1 row)

-- Test second regular column
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) FROM hybrid_test WHERE id @@@ pdb.parse('category:tools');
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on hybrid_test
         Table: hybrid_test
         Index: idx_hybrid
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"category:tools","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) FROM hybrid_test WHERE id @@@ pdb.parse('category:tools');
 count 
-------
     1
(1 row)

-- Test second composite field
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) FROM hybrid_test WHERE id @@@ pdb.parse('tags:tech');
                                                          QUERY PLAN                                                           
-------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on hybrid_test
         Table: hybrid_test
         Index: idx_hybrid
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"tags:tech","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) FROM hybrid_test WHERE id @@@ pdb.parse('tags:tech');
 count 
-------
     1
(1 row)

-- Test cross-type query using pdb.parse with AND
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) FROM hybrid_test WHERE id @@@ pdb.parse('name:widget AND description:useful');
                                                                       QUERY PLAN                                                                       
--------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on hybrid_test
         Table: hybrid_test
         Index: idx_hybrid
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"name:widget AND description:useful","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) FROM hybrid_test WHERE id @@@ pdb.parse('name:widget AND description:useful');
 count 
-------
     1
(1 row)

------------------------------------------------------------
-- TEST: Mixed expressions (columns + IMMUTABLE functions)
------------------------------------------------------------
CREATE TYPE article_search AS (
    title TEXT,
    body TEXT,
    title_upper TEXT
);
CREATE TABLE articles (
    id SERIAL PRIMARY KEY,
    title TEXT,
    body TEXT,
    created_at TIMESTAMP
);
-- Mix simple columns (title, body) with expression (upper - IMMUTABLE function)
CREATE INDEX idx_articles
ON articles
USING bm25 (
    id,
    (ROW(title, body, upper(title))::article_search)
)
WITH (key_field='id');
INSERT INTO articles (title, body, created_at) VALUES
    ('First Post', 'This is the first post', '2024-01-15'),
    ('Second Post', 'This is the second post', '2024-02-20');
-- Search by title (simple column)
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) AS title_search FROM articles WHERE id @@@ pdb.parse('title:First');
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on articles
         Table: articles
         Index: idx_articles
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"title:First","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) AS title_search FROM articles WHERE id @@@ pdb.parse('title:First');
 title_search 
--------------
            1
(1 row)

-- Search by title_upper (expression result - uppercase)
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) AS title_upper_search FROM articles WHERE id @@@ pdb.parse('title_upper:FIRST');
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on articles
         Table: articles
         Index: idx_articles
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"title_upper:FIRST","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) AS title_upper_search FROM articles WHERE id @@@ pdb.parse('title_upper:FIRST');
 title_upper_search 
--------------------
                  1
(1 row)

------------------------------------------------------------
-- TEST: Mixed data sizes (empty, small, medium, large, NULL)
------------------------------------------------------------
CREATE TYPE mixed_composite AS (
    small TEXT,
    medium TEXT,
    large TEXT
);
CREATE TABLE mixed_data (
    id SERIAL PRIMARY KEY,
    small TEXT,
    medium TEXT,
    large TEXT
);
CREATE INDEX idx_mixed
ON mixed_data
USING bm25 (id, (ROW(small, medium, large)::mixed_composite))
WITH (key_field='id');
-- Test with mixed sizes: empty, small, medium, large, NULL
INSERT INTO mixed_data (small, medium, large) VALUES
    ('', 'medium text here', NULL),
    ('tiny', NULL, 'this is a much longer text that goes on and on'),
    (NULL, NULL, NULL);
-- Verify all rows were indexed
SELECT COUNT(*) AS mixed_total FROM mixed_data;
 mixed_total 
-------------
           3
(1 row)

-- Verify searchable non-NULL values
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) AS found_medium FROM mixed_data WHERE id @@@ pdb.parse('medium:medium');
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on mixed_data
         Table: mixed_data
         Index: idx_mixed
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"medium:medium","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) AS found_medium FROM mixed_data WHERE id @@@ pdb.parse('medium:medium');
 found_medium 
--------------
            1
(1 row)

EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) AS found_tiny FROM mixed_data WHERE id @@@ pdb.parse('small:tiny');
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on mixed_data
         Table: mixed_data
         Index: idx_mixed
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"small:tiny","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) AS found_tiny FROM mixed_data WHERE id @@@ pdb.parse('small:tiny');
 found_tiny 
------------
          1
(1 row)

------------------------------------------------------------
-- TEST: Composite fields exist in index schema
------------------------------------------------------------
CREATE TYPE verify_composite AS (
    first_field TEXT,
    second_field TEXT
);
CREATE TABLE verify_table (
    id SERIAL PRIMARY KEY,
    first_field TEXT,
    second_field TEXT
);
CREATE INDEX verify_idx
ON verify_table
USING bm25 (id, (ROW(first_field, second_field)::verify_composite))
WITH (key_field='id');
-- Verify the composite fields exist in the index schema
SELECT EXISTS (SELECT 1 FROM paradedb.schema('verify_idx') WHERE name = 'first_field') AS first_field_exists;
 first_field_exists 
--------------------
 t
(1 row)

SELECT EXISTS (SELECT 1 FROM paradedb.schema('verify_idx') WHERE name = 'second_field') AS second_field_exists;
 second_field_exists 
---------------------
 t
(1 row)

-- Verify they work by indexing and searching
INSERT INTO verify_table (first_field, second_field) VALUES ('hello', 'world');
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) AS first_field_search FROM verify_table WHERE id @@@ pdb.parse('first_field:hello');
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on verify_table
         Table: verify_table
         Index: verify_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"first_field:hello","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) AS first_field_search FROM verify_table WHERE id @@@ pdb.parse('first_field:hello');
 first_field_search 
--------------------
                  1
(1 row)

EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) AS second_field_search FROM verify_table WHERE id @@@ pdb.parse('second_field:world');
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on verify_table
         Table: verify_table
         Index: verify_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"second_field:world","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) AS second_field_search FROM verify_table WHERE id @@@ pdb.parse('second_field:world');
 second_field_search 
---------------------
                   1
(1 row)

------------------------------------------------------------
-- TEST: Comprehensive schema verification with search
------------------------------------------------------------
CREATE TYPE product_schema AS (
    product_name TEXT,
    product_desc TEXT,
    product_price FLOAT
);
CREATE TABLE products_schema (
    id SERIAL PRIMARY KEY,
    product_name TEXT,
    product_desc TEXT,
    product_price FLOAT
);
CREATE INDEX idx_products_schema
ON products_schema
USING bm25 (id, (ROW(product_name, product_desc, product_price)::product_schema))
WITH (key_field='id');
-- Query the index schema to verify composite fields exist
SELECT EXISTS (
    SELECT 1 FROM paradedb.schema('idx_products_schema')
    WHERE name IN ('product_name', 'product_desc', 'product_price')
) AS fields_exist;
 fields_exist 
--------------
 t
(1 row)

-- Verify all three fields are present
SELECT COUNT(*) AS field_count FROM paradedb.schema('idx_products_schema')
WHERE name IN ('product_name', 'product_desc', 'product_price');
 field_count 
-------------
           3
(1 row)

-- Insert data and verify it's searchable on each field
INSERT INTO products_schema (product_name, product_desc, product_price) VALUES ('TestProduct', 'TestDescription', 99.99);
-- Search each field to prove it was indexed
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) AS name_search FROM products_schema WHERE id @@@ pdb.parse('product_name:TestProduct');
                                                                  QUERY PLAN                                                                  
----------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on products_schema
         Table: products_schema
         Index: idx_products_schema
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"product_name:TestProduct","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) AS name_search FROM products_schema WHERE id @@@ pdb.parse('product_name:TestProduct');
 name_search 
-------------
           1
(1 row)

EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) AS desc_search FROM products_schema WHERE id @@@ pdb.parse('product_desc:TestDescription');
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on products_schema
         Table: products_schema
         Index: idx_products_schema
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"product_desc:TestDescription","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) AS desc_search FROM products_schema WHERE id @@@ pdb.parse('product_desc:TestDescription');
 desc_search 
-------------
           1
(1 row)

------------------------------------------------------------
-- TEST: Tokenizer types in composite fields (pdb.simple)
------------------------------------------------------------
CREATE TYPE tokenized_fields AS (
    title TEXT,
    title_simple pdb.simple
);
CREATE TABLE tokenized_test (
    id SERIAL PRIMARY KEY,
    title TEXT
);
CREATE INDEX idx_tokenized ON tokenized_test USING bm25 (
    id,
    (ROW(title, title)::tokenized_fields)
) WITH (key_field='id');
-- Validate that pdb.simple tokenizer was applied (should show 'default' tokenizer for title_simple)
SELECT * FROM paradedb.schema('idx_tokenized') ORDER BY name;
     name     | field_type | stored | indexed | fast | fieldnorms | expand_dots |            tokenizer             |  record  | normalizer 
--------------+------------+--------+---------+------+------------+-------------+----------------------------------+----------+------------
 ctid         | U64        | f      | t       | t    | f          |             |                                  |          | 
 id           | I64        | f      | t       | t    | f          |             |                                  |          | 
 title        | Str        | f      | t       | f    | t          |             | unicode_words_removeemojis:false | position | 
 title_simple | Str        | f      | t       | f    | t          |             | default                          | position | 
(4 rows)

INSERT INTO tokenized_test (title) VALUES ('Running and Jumping');
-- Search on the simple tokenizer field (lowercased)
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) AS simple_tokenizer_search FROM tokenized_test WHERE id @@@ pdb.parse('title_simple:running');
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on tokenized_test
         Table: tokenized_test
         Index: idx_tokenized
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"title_simple:running","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) AS simple_tokenizer_search FROM tokenized_test WHERE id @@@ pdb.parse('title_simple:running');
 simple_tokenizer_search 
-------------------------
                       1
(1 row)

-- Search on the default text field (should also find it)
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) AS default_text_search FROM tokenized_test WHERE id @@@ pdb.parse('title:running');
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on tokenized_test
         Table: tokenized_test
         Index: idx_tokenized
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"title:running","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) AS default_text_search FROM tokenized_test WHERE id @@@ pdb.parse('title:running');
 default_text_search 
---------------------
                   1
(1 row)

------------------------------------------------------------
-- TEST: Ngram tokenizer in composite fields
------------------------------------------------------------
CREATE TYPE ngram_fields AS (
    content TEXT,
    content_ngram pdb.ngram(2, 4)
);
CREATE TABLE ngram_test (
    id SERIAL PRIMARY KEY,
    content TEXT
);
CREATE INDEX idx_ngram ON ngram_test USING bm25 (
    id,
    (ROW(content, content)::ngram_fields)
) WITH (key_field='id');
-- Validate that ngram tokenizer was applied (should show 'ngram_mingram:2_maxgram:4...' for content_ngram)
SELECT * FROM paradedb.schema('idx_ngram') ORDER BY name;
     name      | field_type | stored | indexed | fast | fieldnorms | expand_dots |                 tokenizer                  |  record  | normalizer 
---------------+------------+--------+---------+------+------------+-------------+--------------------------------------------+----------+------------
 content       | Str        | f      | t       | f    | t          |             | unicode_words_removeemojis:false           | position | 
 content_ngram | Str        | f      | t       | f    | t          |             | ngram_mingram:2_maxgram:4_prefixonly:false | position | 
 ctid          | U64        | f      | t       | t    | f          |             |                                            |          | 
 id            | I64        | f      | t       | t    | f          |             |                                            |          | 
(4 rows)

INSERT INTO ngram_test (content) VALUES ('PostgreSQL database');
-- Search with partial match via ngram - 'gres' should match 'PostgreSQL'
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) AS ngram_partial_search FROM ngram_test WHERE id @@@ pdb.parse('content_ngram:gres');
                                                               QUERY PLAN                                                               
----------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on ngram_test
         Table: ngram_test
         Index: idx_ngram
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"content_ngram:gres","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) AS ngram_partial_search FROM ngram_test WHERE id @@@ pdb.parse('content_ngram:gres');
 ngram_partial_search 
----------------------
                    1
(1 row)

-- Default text field should NOT match partial 'gres' (no ngram)
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) AS default_no_partial FROM ngram_test WHERE id @@@ pdb.parse('content:gres');
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on ngram_test
         Table: ngram_test
         Index: idx_ngram
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"content:gres","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) AS default_no_partial FROM ngram_test WHERE id @@@ pdb.parse('content:gres');
 default_no_partial 
--------------------
                  0
(1 row)

------------------------------------------------------------
-- TEST: Stemmer tokenizer in composite fields
------------------------------------------------------------
CREATE TYPE stemmer_fields AS (
    content TEXT,
    content_stemmed pdb.simple('stemmer=english')
);
CREATE TABLE stemmer_test (
    id SERIAL PRIMARY KEY,
    content TEXT
);
CREATE INDEX idx_stemmer ON stemmer_test USING bm25 (
    id,
    (ROW(content, content)::stemmer_fields)
) WITH (key_field='id');
-- Validate that stemmer tokenizer was applied (should show 'default[stemmer=English]' for content_stemmed)
SELECT * FROM paradedb.schema('idx_stemmer') ORDER BY name;
      name       | field_type | stored | indexed | fast | fieldnorms | expand_dots |            tokenizer             |  record  | normalizer 
-----------------+------------+--------+---------+------+------------+-------------+----------------------------------+----------+------------
 content         | Str        | f      | t       | f    | t          |             | unicode_words_removeemojis:false | position | 
 content_stemmed | Str        | f      | t       | f    | t          |             | default[stemmer=English]         | position | 
 ctid            | U64        | f      | t       | t    | f          |             |                                  |          | 
 id              | I64        | f      | t       | t    | f          |             |                                  |          | 
(4 rows)

INSERT INTO stemmer_test (content) VALUES
    ('running quickly'),
    ('he runs fast');
-- Stemmed search: 'run' should match 'running' and 'runs' (both stem to 'run')
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) AS stemmer_search FROM stemmer_test WHERE id @@@ pdb.parse('content_stemmed:run');
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on stemmer_test
         Table: stemmer_test
         Index: idx_stemmer
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"content_stemmed:run","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) AS stemmer_search FROM stemmer_test WHERE id @@@ pdb.parse('content_stemmed:run');
 stemmer_search 
----------------
              2
(1 row)

-- Default text field should NOT match 'run' (no stemming)
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) AS default_no_stem FROM stemmer_test WHERE id @@@ pdb.parse('content:run');
                                                           QUERY PLAN                                                            
---------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on stemmer_test
         Table: stemmer_test
         Index: idx_stemmer
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"content:run","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) AS default_no_stem FROM stemmer_test WHERE id @@@ pdb.parse('content:run');
 default_no_stem 
-----------------
               0
(1 row)

------------------------------------------------------------
-- SMOKE TESTS: Comprehensive feature coverage
------------------------------------------------------------
-- Create composite type for smoke tests (using pdb tokenizer types)
CREATE TYPE smoke_product AS (
    name TEXT,
    description TEXT,
    category pdb.literal  -- keyword tokenizer with fast field
);
-- Create table with columns that will be indexed via composite type
CREATE TABLE smoke_test (
    id SERIAL PRIMARY KEY,
    name TEXT,
    description TEXT,
    category TEXT,
    rating FLOAT,
    price FLOAT,
    in_stock BOOLEAN
);
-- Insert test data
INSERT INTO smoke_test (name, description, category, rating, price, in_stock) VALUES
    ('Running Shoes', 'Lightweight running shoes for athletes', 'Footwear', 4.5, 89.99, true),
    ('Wireless Keyboard', 'Ergonomic wireless keyboard with backlight', 'Electronics', 4.2, 79.99, true),
    ('Gaming Mouse', 'High precision gaming mouse with RGB', 'Electronics', 4.8, 59.99, true),
    ('Yoga Mat', 'Non-slip yoga mat for exercise', 'Sports', 4.0, 29.99, true),
    ('Coffee Maker', 'Automatic drip coffee maker', 'Kitchen', 3.9, 49.99, false),
    ('Hiking Boots', 'Waterproof hiking boots for trails', 'Footwear', 4.6, 129.99, true),
    ('Bluetooth Speaker', 'Portable bluetooth speaker waterproof', 'Electronics', 4.3, 39.99, true),
    ('Tennis Racket', 'Professional tennis racket lightweight', 'Sports', 4.1, 149.99, false);
-- Create BM25 index on composite type
-- FLOAT fields (rating, price) are automatically fast
-- category uses pdb.literal (keyword tokenizer with fast) defined in composite type
CREATE INDEX smoke_idx ON smoke_test
USING bm25 (id, (ROW(name, description, category)::smoke_product), rating, price)
WITH (key_field = 'id');
------------------------------------------------------------
-- TEST: Scoring with pdb.score()
------------------------------------------------------------
\echo '=== TEST: Scoring ==='
=== TEST: Scoring ===
-- Basic score (tie-breaker on id)
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name, pdb.score(id) as score
FROM smoke_test
WHERE id @@@ pdb.parse('description:shoes')
ORDER BY score DESC, id;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: (pdb.score(id)) DESC, id
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: NormalScanExecState
         Scores: true
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"description:shoes","lenient":null,"conjunction_mode":null}}}}
(8 rows)

SELECT id, name, pdb.score(id) as score
FROM smoke_test
WHERE id @@@ pdb.parse('description:shoes')
ORDER BY score DESC, id;
 id |     name      |   score   
----+---------------+-----------
  1 | Running Shoes | 1.7731597
(1 row)

-- Score with multiple matches (tie-breaker on id)
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name, pdb.score(id) as score
FROM smoke_test
WHERE id @@@ pdb.parse('description:shoes OR description:keyboard')
ORDER BY score DESC, id;
                                                                          QUERY PLAN                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: (pdb.score(id)) DESC, id
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: NormalScanExecState
         Scores: true
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"description:shoes OR description:keyboard","lenient":null,"conjunction_mode":null}}}}
(8 rows)

SELECT id, name, pdb.score(id) as score
FROM smoke_test
WHERE id @@@ pdb.parse('description:shoes OR description:keyboard')
ORDER BY score DESC, id;
 id |       name        |   score   
----+-------------------+-----------
  1 | Running Shoes     | 1.7731597
  2 | Wireless Keyboard | 1.7731597
(2 rows)

------------------------------------------------------------
-- TEST: Snippets with pdb.snippet()
------------------------------------------------------------
\echo '=== TEST: Snippets ==='
=== TEST: Snippets ===
-- Snippet on field
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, pdb.snippet(description) as snippet
FROM smoke_test
WHERE id @@@ pdb.parse('description:shoes')
ORDER BY id;
                                                              QUERY PLAN                                                               
---------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: id
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"description:shoes","lenient":null,"conjunction_mode":null}}}}
(8 rows)

SELECT id, pdb.snippet(description) as snippet
FROM smoke_test
WHERE id @@@ pdb.parse('description:shoes')
ORDER BY id;
 id |                    snippet                    
----+-----------------------------------------------
  1 | Lightweight running <b>shoes</b> for athletes
(1 row)

-- Snippet with custom tags
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, pdb.snippet(description, start_tag => '**', end_tag => '**') as snippet
FROM smoke_test
WHERE id @@@ pdb.parse('description:wireless')
ORDER BY id;
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: id
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"description:wireless","lenient":null,"conjunction_mode":null}}}}
(8 rows)

SELECT id, pdb.snippet(description, start_tag => '**', end_tag => '**') as snippet
FROM smoke_test
WHERE id @@@ pdb.parse('description:wireless')
ORDER BY id;
 id |                    snippet                     
----+------------------------------------------------
  2 | Ergonomic **wireless** keyboard with backlight
(1 row)

------------------------------------------------------------
-- TEST: TopN Scan (ORDER BY with LIMIT)
------------------------------------------------------------
\echo '=== TEST: TopN Scan ==='
=== TEST: TopN Scan ===
-- Basic TopN with EXPLAIN
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name, rating
FROM smoke_test
WHERE id @@@ pdb.parse('name:Shoes OR name:Keyboard OR name:Mouse')
ORDER BY rating DESC, id
LIMIT 3;
                                                                          QUERY PLAN                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: TopNScanExecState
         Scores: false
            TopN Order By: rating desc, id asc
            TopN Limit: 3
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"name:Shoes OR name:Keyboard OR name:Mouse","lenient":null,"conjunction_mode":null}}}}
(9 rows)

-- Execute TopN query
SELECT id, name, rating
FROM smoke_test
WHERE id @@@ pdb.parse('name:Shoes OR name:Keyboard OR name:Mouse')
ORDER BY rating DESC, id
LIMIT 3;
 id |       name        | rating 
----+-------------------+--------
  3 | Gaming Mouse      |    4.8
  1 | Running Shoes     |    4.5
  2 | Wireless Keyboard |    4.2
(3 rows)

-- TopN with score ordering
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name, pdb.score(id) as score
FROM smoke_test
WHERE id @@@ pdb.parse('description:shoes OR description:keyboard')
ORDER BY score DESC, id
LIMIT 2;
                                                                          QUERY PLAN                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: TopNScanExecState
         Scores: true
            TopN Order By: pdb.score() desc, id asc
            TopN Limit: 2
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"description:shoes OR description:keyboard","lenient":null,"conjunction_mode":null}}}}
(9 rows)

SELECT id, name, pdb.score(id) as score
FROM smoke_test
WHERE id @@@ pdb.parse('description:shoes OR description:keyboard')
ORDER BY score DESC, id
LIMIT 2;
 id |       name        |   score   
----+-------------------+-----------
  1 | Running Shoes     | 1.7731597
  2 | Wireless Keyboard | 1.7731597
(2 rows)

------------------------------------------------------------
-- TEST: Aggregates
------------------------------------------------------------
\echo '=== TEST: Aggregates ==='
=== TEST: Aggregates ===
-- COUNT
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) as total FROM smoke_test WHERE id @@@ pdb.parse('category:Electronics');
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"category:Electronics","lenient":null,"conjunction_mode":null}}}}
(7 rows)

SELECT COUNT(*) as total FROM smoke_test WHERE id @@@ pdb.parse('category:Electronics');
 total 
-------
     3
(1 row)

-- SUM
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT SUM(price) as total_price FROM smoke_test WHERE id @@@ pdb.parse('category:Electronics');
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: MixedFastFieldExecState
         Fast Fields: price
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"category:Electronics","lenient":null,"conjunction_mode":null}}}}
(8 rows)

SELECT SUM(price) as total_price FROM smoke_test WHERE id @@@ pdb.parse('category:Electronics');
 total_price 
-------------
      179.97
(1 row)

-- AVG
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT AVG(rating) as avg_rating FROM smoke_test WHERE id @@@ pdb.parse('description:shoes OR description:boots');
                                                                         QUERY PLAN                                                                         
------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: MixedFastFieldExecState
         Fast Fields: rating
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"description:shoes OR description:boots","lenient":null,"conjunction_mode":null}}}}
(8 rows)

SELECT AVG(rating) as avg_rating FROM smoke_test WHERE id @@@ pdb.parse('description:shoes OR description:boots');
 avg_rating 
------------
       4.55
(1 row)

-- Multiple aggregates
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) as count, SUM(price) as total, AVG(rating) as avg_rating, MIN(price) as min_price, MAX(price) as max_price
FROM smoke_test
WHERE id @@@ pdb.parse('category:Electronics OR category:Footwear');
                                                                          QUERY PLAN                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: MixedFastFieldExecState
         Fast Fields: price, rating
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"category:Electronics OR category:Footwear","lenient":null,"conjunction_mode":null}}}}
(8 rows)

SELECT COUNT(*) as count, SUM(price) as total, AVG(rating) as avg_rating, MIN(price) as min_price, MAX(price) as max_price
FROM smoke_test
WHERE id @@@ pdb.parse('category:Electronics OR category:Footwear');
 count |       total        | avg_rating | min_price | max_price 
-------+--------------------+------------+-----------+-----------
     5 | 399.95000000000005 |       4.48 |     39.99 |    129.99
(1 row)

------------------------------------------------------------
-- TEST: GROUP BY with Aggregates
------------------------------------------------------------
\echo '=== TEST: GROUP BY ==='
=== TEST: GROUP BY ===
-- GROUP BY on field (tie-breaker on category)
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT category, COUNT(*) as count, AVG(rating) as avg_rating
FROM smoke_test
WHERE id @@@ pdb.all()
GROUP BY category
ORDER BY count DESC, category;
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Sort
   Sort Key: (count(*)) DESC, category
   ->  HashAggregate
         Group Key: category
         ->  Custom Scan (ParadeDB Scan) on smoke_test
               Table: smoke_test
               Index: smoke_idx
               Exec Method: NormalScanExecState
               Scores: false
               Tantivy Query: {"with_index":{"query":{"all":{"field":"id"}}}}
(10 rows)

SELECT category, COUNT(*) as count, AVG(rating) as avg_rating
FROM smoke_test
WHERE id @@@ pdb.all()
GROUP BY category
ORDER BY count DESC, category;
  category   | count |    avg_rating     
-------------+-------+-------------------
 Electronics |     3 | 4.433333333333334
 Footwear    |     2 |              4.55
 Sports      |     2 |              4.05
 Kitchen     |     1 |               3.9
(4 rows)

------------------------------------------------------------
-- TEST: pdb.agg() Window Function
------------------------------------------------------------
\echo '=== TEST: pdb.agg() Window Function ==='
=== TEST: pdb.agg() Window Function ===
-- pdb.agg with terms aggregation (requires TopN query)
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name, category,
       pdb.agg('{"terms": {"field": "category"}}'::jsonb) OVER () as category_facets
FROM smoke_test
WHERE id @@@ pdb.all()
ORDER BY id
LIMIT 3;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Limit
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: TopNScanExecState
         Scores: false
            TopN Order By: id asc
            TopN Limit: 3
         Tantivy Query: {"with_index":{"query":{"all":{"field":"id"}}}}
(9 rows)

SELECT id, name, category,
       pdb.agg('{"terms": {"field": "category"}}'::jsonb) OVER () as category_facets
FROM smoke_test
WHERE id @@@ pdb.all()
ORDER BY id
LIMIT 3;
 id |       name        |  category   |                                                                                                        category_facets                                                                                                        
----+-------------------+-------------+-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
  1 | Running Shoes     | Footwear    | {"buckets": [{"key": "Electronics", "doc_count": 3}, {"key": "Footwear", "doc_count": 2}, {"key": "Sports", "doc_count": 2}, {"key": "Kitchen", "doc_count": 1}], "sum_other_doc_count": 0, "doc_count_error_upper_bound": 0}
  2 | Wireless Keyboard | Electronics | {"buckets": [{"key": "Electronics", "doc_count": 3}, {"key": "Footwear", "doc_count": 2}, {"key": "Sports", "doc_count": 2}, {"key": "Kitchen", "doc_count": 1}], "sum_other_doc_count": 0, "doc_count_error_upper_bound": 0}
  3 | Gaming Mouse      | Electronics | {"buckets": [{"key": "Electronics", "doc_count": 3}, {"key": "Footwear", "doc_count": 2}, {"key": "Sports", "doc_count": 2}, {"key": "Kitchen", "doc_count": 1}], "sum_other_doc_count": 0, "doc_count_error_upper_bound": 0}
(3 rows)

-- pdb.agg with avg aggregation (requires TopN query)
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name, rating,
       pdb.agg('{"avg": {"field": "rating"}}'::jsonb) OVER () as avg_rating
FROM smoke_test
WHERE id @@@ pdb.parse('category:Electronics')
ORDER BY id
LIMIT 3;
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: TopNScanExecState
         Scores: false
            TopN Order By: id asc
            TopN Limit: 3
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"category:Electronics","lenient":null,"conjunction_mode":null}}}}
(9 rows)

SELECT id, name, rating,
       pdb.agg('{"avg": {"field": "rating"}}'::jsonb) OVER () as avg_rating
FROM smoke_test
WHERE id @@@ pdb.parse('category:Electronics')
ORDER BY id
LIMIT 3;
 id |       name        | rating |          avg_rating          
----+-------------------+--------+------------------------------
  2 | Wireless Keyboard |    4.2 | {"value": 4.433333333333334}
  3 | Gaming Mouse      |    4.8 | {"value": 4.433333333333334}
  7 | Bluetooth Speaker |    4.3 | {"value": 4.433333333333334}
(3 rows)

-- pdb.agg with stats aggregation
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name, price,
       pdb.agg('{"stats": {"field": "price"}}'::jsonb) OVER () as price_stats
FROM smoke_test
WHERE id @@@ pdb.all()
ORDER BY id
LIMIT 3;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Limit
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: TopNScanExecState
         Scores: false
            TopN Order By: id asc
            TopN Limit: 3
         Tantivy Query: {"with_index":{"query":{"all":{"field":"id"}}}}
(9 rows)

SELECT id, name, price,
       pdb.agg('{"stats": {"field": "price"}}'::jsonb) OVER () as price_stats
FROM smoke_test
WHERE id @@@ pdb.all()
ORDER BY id
LIMIT 3;
 id |       name        | price |                                          price_stats                                          
----+-------------------+-------+-----------------------------------------------------------------------------------------------
  1 | Running Shoes     | 89.99 | {"avg": 78.74000000000001, "max": 149.99, "min": 29.99, "sum": 629.9200000000001, "count": 8}
  2 | Wireless Keyboard | 79.99 | {"avg": 78.74000000000001, "max": 149.99, "min": 29.99, "sum": 629.9200000000001, "count": 8}
  3 | Gaming Mouse      | 59.99 | {"avg": 78.74000000000001, "max": 149.99, "min": 29.99, "sum": 629.9200000000001, "count": 8}
(3 rows)

------------------------------------------------------------
-- TEST: Range Queries with pdb.range()
------------------------------------------------------------
\echo '=== TEST: Range Queries ==='
=== TEST: Range Queries ===
-- Range on FLOAT field using PostgreSQL range type
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name, price FROM smoke_test
WHERE price @@@ pdb.range(numrange(50.0, 100.0, '[]'))
ORDER BY price, id;
                                                                            QUERY PLAN                                                                            
------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: price, id
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"range":{"field":"price","lower_bound":{"included":"50"},"upper_bound":{"included":"100"},"is_datetime":false}}}}
(8 rows)

SELECT id, name, price FROM smoke_test
WHERE price @@@ pdb.range(numrange(50.0, 100.0, '[]'))
ORDER BY price, id;
 id |       name        | price 
----+-------------------+-------
  3 | Gaming Mouse      | 59.99
  2 | Wireless Keyboard | 79.99
  1 | Running Shoes     | 89.99
(3 rows)

-- Range combined with text search
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name, rating FROM smoke_test
WHERE id @@@ pdb.parse('description:shoes OR description:boots') AND rating >= 4.0
ORDER BY rating DESC, id;
                                                                                                                                      QUERY PLAN                                                                                                                                      
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: rating DESC, id
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"boolean":{"must":[{"with_index":{"query":{"parse":{"query_string":"description:shoes OR description:boots","lenient":null,"conjunction_mode":null}}}},{"range":{"field":"rating","lower_bound":{"included":4.0},"upper_bound":null,"is_datetime":false}}]}}
(8 rows)

SELECT id, name, rating FROM smoke_test
WHERE id @@@ pdb.parse('description:shoes OR description:boots') AND rating >= 4.0
ORDER BY rating DESC, id;
 id |     name      | rating 
----+---------------+--------
  6 | Hiking Boots  |    4.6
  1 | Running Shoes |    4.5
(2 rows)

------------------------------------------------------------
-- TEST: Fuzzy Search (parse syntax with ~N for edit distance)
------------------------------------------------------------
\echo '=== TEST: Fuzzy Search ==='
=== TEST: Fuzzy Search ===
-- Fuzzy search using tantivy parse syntax (~ for fuzzy, ~1 for edit distance 1)
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name FROM smoke_test
WHERE id @@@ pdb.parse('name:runnin~1')
ORDER BY id;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: id
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"name:runnin~1","lenient":null,"conjunction_mode":null}}}}
(8 rows)

SELECT id, name FROM smoke_test
WHERE id @@@ pdb.parse('name:runnin~1')
ORDER BY id;
 id | name 
----+------
(0 rows)

-- Fuzzy search with more distance (~2 for edit distance 2)
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name FROM smoke_test
WHERE id @@@ pdb.parse('name:keyboar~2')
ORDER BY id;
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: id
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"name:keyboar~2","lenient":null,"conjunction_mode":null}}}}
(8 rows)

SELECT id, name FROM smoke_test
WHERE id @@@ pdb.parse('name:keyboar~2')
ORDER BY id;
 id | name 
----+------
(0 rows)

------------------------------------------------------------
-- TEST: Phrase with Slop (parse syntax with ~N for slop)
------------------------------------------------------------
\echo '=== TEST: Phrase with Slop ==='
=== TEST: Phrase with Slop ===
-- Phrase with slop 0 (exact phrase match) - double quotes for phrase
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name FROM smoke_test
WHERE id @@@ pdb.parse('description:"running shoes"')
ORDER BY id;
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: id
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"description:\"running shoes\"","lenient":null,"conjunction_mode":null}}}}
(8 rows)

SELECT id, name FROM smoke_test
WHERE id @@@ pdb.parse('description:"running shoes"')
ORDER BY id;
 id |     name      
----+---------------
  1 | Running Shoes
(1 row)

-- Phrase with slop 2 (allows 2 words between terms) - ~2 after phrase for slop
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name FROM smoke_test
WHERE id @@@ pdb.parse('description:"lightweight shoes"~2')
ORDER BY id;
                                                                       QUERY PLAN                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: id
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"description:\"lightweight shoes\"~2","lenient":null,"conjunction_mode":null}}}}
(8 rows)

SELECT id, name FROM smoke_test
WHERE id @@@ pdb.parse('description:"lightweight shoes"~2')
ORDER BY id;
 id |     name      
----+---------------
  1 | Running Shoes
(1 row)

------------------------------------------------------------
-- TEST: Mixed Conditions (BM25 + Regular SQL)
------------------------------------------------------------
\echo '=== TEST: Mixed Conditions ==='
=== TEST: Mixed Conditions ===
-- BM25 search with regular column filter
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name, rating, in_stock
FROM smoke_test
WHERE id @@@ pdb.parse('category:Electronics') AND rating > 4.0 AND in_stock = true
ORDER BY rating DESC, id;
                                                                                                                                                                                QUERY PLAN                                                                                                                                                                                
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: rating DESC, id
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"boolean":{"must":[{"heap_filter":{"indexed_query":{"boolean":{"must":[{"with_index":{"query":{"parse":{"query_string":"category:Electronics","lenient":null,"conjunction_mode":null}}}},{"range":{"field":"rating","lower_bound":{"excluded":4.0},"upper_bound":null,"is_datetime":false}}]}},"field_filters":[{"heap_filter":"in_stock"}]}}]}}
(8 rows)

SELECT id, name, rating, in_stock
FROM smoke_test
WHERE id @@@ pdb.parse('category:Electronics') AND rating > 4.0 AND in_stock = true
ORDER BY rating DESC, id;
 id |       name        | rating | in_stock 
----+-------------------+--------+----------
  3 | Gaming Mouse      |    4.8 | t
  7 | Bluetooth Speaker |    4.3 | t
  2 | Wireless Keyboard |    4.2 | t
(3 rows)

-- BM25 search with price range
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name, price
FROM smoke_test
WHERE id @@@ pdb.parse('description:shoes OR description:boots') AND price BETWEEN 50 AND 150
ORDER BY price, id;
                                                                                                                                                                                        QUERY PLAN                                                                                                                                                                                        
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: price, id
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"boolean":{"must":[{"with_index":{"query":{"parse":{"query_string":"description:shoes OR description:boots","lenient":null,"conjunction_mode":null}}}},{"range":{"field":"price","lower_bound":{"included":50.0},"upper_bound":null,"is_datetime":false}},{"range":{"field":"price","lower_bound":null,"upper_bound":{"included":150.0},"is_datetime":false}}]}}
(8 rows)

SELECT id, name, price
FROM smoke_test
WHERE id @@@ pdb.parse('description:shoes OR description:boots') AND price BETWEEN 50 AND 150
ORDER BY price, id;
 id |     name      | price  
----+---------------+--------
  1 | Running Shoes |  89.99
  6 | Hiking Boots  | 129.99
(2 rows)

-- BM25 search with IN clause
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name, category
FROM smoke_test
WHERE id @@@ pdb.all() AND category IN ('Electronics', 'Footwear')
ORDER BY id;
                                                                                                                    QUERY PLAN                                                                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: id
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"boolean":{"must":[{"with_index":{"query":{"all":{"field":"id"}}}},{"term_set":{"terms":[{"field":"category","value":"Electronics","is_datetime":false},{"field":"category","value":"Footwear","is_datetime":false}]}}]}}
(8 rows)

SELECT id, name, category
FROM smoke_test
WHERE id @@@ pdb.all() AND category IN ('Electronics', 'Footwear')
ORDER BY id;
 id |       name        |  category   
----+-------------------+-------------
  1 | Running Shoes     | Footwear
  2 | Wireless Keyboard | Electronics
  3 | Gaming Mouse      | Electronics
  6 | Hiking Boots      | Footwear
  7 | Bluetooth Speaker | Electronics
(5 rows)

------------------------------------------------------------
-- TEST: EXPLAIN Plan Verification
------------------------------------------------------------
\echo '=== TEST: EXPLAIN Plans ==='
=== TEST: EXPLAIN Plans ===
-- NormalScanExecState / MixedFastFieldExecState - basic search
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name FROM smoke_test
WHERE id @@@ pdb.parse('name:Shoes');
                                                        QUERY PLAN                                                        
--------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ParadeDB Scan) on smoke_test
   Table: smoke_test
   Index: smoke_idx
   Exec Method: NormalScanExecState
   Scores: false
   Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"name:Shoes","lenient":null,"conjunction_mode":null}}}}
(6 rows)

-- TopNScanExecState - search with ORDER BY score DESC and LIMIT
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name, pdb.score(id) as score
FROM smoke_test
WHERE id @@@ pdb.parse('description:shoes OR description:keyboard')
ORDER BY score DESC, id
LIMIT 3;
                                                                          QUERY PLAN                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: TopNScanExecState
         Scores: true
            TopN Order By: pdb.score() desc, id asc
            TopN Limit: 3
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"description:shoes OR description:keyboard","lenient":null,"conjunction_mode":null}}}}
(9 rows)

-- TopNScanExecState - search with ORDER BY fast field and LIMIT
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name, rating
FROM smoke_test
WHERE id @@@ pdb.parse('name:Shoes OR name:Keyboard OR name:Mouse')
ORDER BY rating DESC, id
LIMIT 3;
                                                                          QUERY PLAN                                                                           
---------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: TopNScanExecState
         Scores: false
            TopN Order By: rating desc, id asc
            TopN Limit: 3
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"name:Shoes OR name:Keyboard OR name:Mouse","lenient":null,"conjunction_mode":null}}}}
(9 rows)

-- ParadeDB Aggregate Scan - aggregate query with fast fields
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT COUNT(*) FROM smoke_test
WHERE id @@@ pdb.parse('category:Electronics');
                                                                QUERY PLAN                                                                
------------------------------------------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"category:Electronics","lenient":null,"conjunction_mode":null}}}}
(7 rows)

-- Verify TopN with pdb.agg window function
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name,
       pdb.agg('{"terms": {"field": "category"}}'::jsonb) OVER () as facets
FROM smoke_test
WHERE id @@@ pdb.all()
ORDER BY id
LIMIT 3;
                               QUERY PLAN                               
------------------------------------------------------------------------
 Limit
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: TopNScanExecState
         Scores: false
            TopN Order By: id asc
            TopN Limit: 3
         Tantivy Query: {"with_index":{"query":{"all":{"field":"id"}}}}
(9 rows)

------------------------------------------------------------
-- TEST: Field existence with pdb.exists()
------------------------------------------------------------
\echo '=== TEST: Field Existence ==='
=== TEST: Field Existence ===
-- Check field existence using pdb.exists() on composite field
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name FROM smoke_test
WHERE category @@@ pdb.exists()
ORDER BY id;
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Sort
   Sort Key: id
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"exists":{"field":"category"}}}}
(8 rows)

SELECT id, name FROM smoke_test
WHERE category @@@ pdb.exists()
ORDER BY id;
 id |       name        
----+-------------------
  1 | Running Shoes
  2 | Wireless Keyboard
  3 | Gaming Mouse
  4 | Yoga Mat
  5 | Coffee Maker
  6 | Hiking Boots
  7 | Bluetooth Speaker
  8 | Tennis Racket
(8 rows)

------------------------------------------------------------
-- TEST: pdb functions on composite fields
------------------------------------------------------------
\echo '=== TEST: pdb functions on composite fields ==='
=== TEST: pdb functions on composite fields ===
-- pdb.term() on composite field
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name FROM smoke_test WHERE name @@@ pdb.term('running') ORDER BY id;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: id
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"term":{"field":"name","value":"running","is_datetime":false}}}}
(8 rows)

SELECT id, name FROM smoke_test WHERE name @@@ pdb.term('running') ORDER BY id;
 id |     name      
----+---------------
  1 | Running Shoes
(1 row)

-- pdb.match() on composite field
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name FROM smoke_test WHERE description @@@ pdb.match('shoes') ORDER BY id;
                                                                                               QUERY PLAN                                                                                               
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: id
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"match":{"field":"description","value":"shoes","tokenizer":null,"distance":null,"transposition_cost_one":null,"prefix":null,"conjunction_mode":null}}}}
(8 rows)

SELECT id, name FROM smoke_test WHERE description @@@ pdb.match('shoes') ORDER BY id;
 id |     name      
----+---------------
  1 | Running Shoes
(1 row)

-- pdb.regex() on composite field
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name FROM smoke_test WHERE description @@@ pdb.regex('.*shoes.*') ORDER BY id;
                                               QUERY PLAN                                                
---------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: id
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"regex":{"field":"description","pattern":".*shoes.*"}}}}
(8 rows)

SELECT id, name FROM smoke_test WHERE description @@@ pdb.regex('.*shoes.*') ORDER BY id;
 id |     name      
----+---------------
  1 | Running Shoes
(1 row)

-- pdb.fuzzy_term() on composite field
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name FROM smoke_test WHERE name @@@ pdb.fuzzy_term('runnin', distance => 1) ORDER BY id;
                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: id
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"fuzzy_term":{"field":"name","value":"runnin","distance":1,"transposition_cost_one":null,"prefix":null}}}}
(8 rows)

SELECT id, name FROM smoke_test WHERE name @@@ pdb.fuzzy_term('runnin', distance => 1) ORDER BY id;
 id |     name      
----+---------------
  1 | Running Shoes
(1 row)

-- pdb.phrase() on composite field
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name FROM smoke_test WHERE description @@@ pdb.phrase('running shoes') ORDER BY id;
                                                            QUERY PLAN                                                             
-----------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: id
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"tokenized_phrase":{"field":"description","phrase":"running shoes","slop":null}}}}
(8 rows)

SELECT id, name FROM smoke_test WHERE description @@@ pdb.phrase('running shoes') ORDER BY id;
 id |     name      
----+---------------
  1 | Running Shoes
(1 row)

-- pdb.phrase_prefix() on composite field (takes array of terms)
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name FROM smoke_test WHERE description @@@ pdb.phrase_prefix(ARRAY['lightweight', 'run']) ORDER BY id;
                                                                   QUERY PLAN                                                                    
-------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: id
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"phrase_prefix":{"field":"description","phrases":["lightweight","run"],"max_expansions":null}}}}
(8 rows)

SELECT id, name FROM smoke_test WHERE description @@@ pdb.phrase_prefix(ARRAY['lightweight', 'run']) ORDER BY id;
 id |     name      
----+---------------
  1 | Running Shoes
(1 row)

-- pdb.range() on FLOAT field (not composite, but verify it works alongside)
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name, rating FROM smoke_test WHERE rating @@@ pdb.range(numrange(4.0, 5.0, '[]')) ORDER BY id;
                                                                           QUERY PLAN                                                                           
----------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: id
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"range":{"field":"rating","lower_bound":{"included":"4"},"upper_bound":{"included":"5"},"is_datetime":false}}}}
(8 rows)

SELECT id, name, rating FROM smoke_test WHERE rating @@@ pdb.range(numrange(4.0, 5.0, '[]')) ORDER BY id;
 id |       name        | rating 
----+-------------------+--------
  1 | Running Shoes     |    4.5
  2 | Wireless Keyboard |    4.2
  3 | Gaming Mouse      |    4.8
  4 | Yoga Mat          |      4
  6 | Hiking Boots      |    4.6
  7 | Bluetooth Speaker |    4.3
  8 | Tennis Racket     |    4.1
(7 rows)

-- Multiple pdb functions combined with AND
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name FROM smoke_test
WHERE name @@@ pdb.term('running') AND description @@@ pdb.match('lightweight')
ORDER BY id;
                                                                                                                                                          QUERY PLAN                                                                                                                                                          
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: id
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"boolean":{"must":[{"with_index":{"query":{"term":{"field":"name","value":"running","is_datetime":false}}}},{"with_index":{"query":{"match":{"field":"description","value":"lightweight","tokenizer":null,"distance":null,"transposition_cost_one":null,"prefix":null,"conjunction_mode":null}}}}]}}
(8 rows)

SELECT id, name FROM smoke_test
WHERE name @@@ pdb.term('running') AND description @@@ pdb.match('lightweight')
ORDER BY id;
 id |     name      
----+---------------
  1 | Running Shoes
(1 row)

-- pdb.term() with different composite fields (category uses pdb.literal - case sensitive)
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name FROM smoke_test WHERE category @@@ pdb.term('Footwear') ORDER BY id;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: id
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"term":{"field":"category","value":"Footwear","is_datetime":false}}}}
(8 rows)

SELECT id, name FROM smoke_test WHERE category @@@ pdb.term('Footwear') ORDER BY id;
 id |     name      
----+---------------
  1 | Running Shoes
  6 | Hiking Boots
(2 rows)

------------------------------------------------------------
-- TEST: TopN queries with pdb functions on composite fields
------------------------------------------------------------
\echo '=== TEST: TopN with pdb functions on composite fields ==='
=== TEST: TopN with pdb functions on composite fields ===
-- TopN with pdb.term() on composite field, ORDER BY score
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name, pdb.score(id) as score
FROM smoke_test WHERE name @@@ pdb.term('shoes')
ORDER BY score DESC, id LIMIT 3;
                                                  QUERY PLAN                                                   
---------------------------------------------------------------------------------------------------------------
 Limit
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: TopNScanExecState
         Scores: true
            TopN Order By: pdb.score() desc, id asc
            TopN Limit: 3
         Tantivy Query: {"with_index":{"query":{"term":{"field":"name","value":"shoes","is_datetime":false}}}}
(9 rows)

SELECT id, name, pdb.score(id) as score
FROM smoke_test WHERE name @@@ pdb.term('shoes')
ORDER BY score DESC, id LIMIT 3;
 id |     name      |   score   
----+---------------+-----------
  1 | Running Shoes | 1.7917595
(1 row)

-- TopN with pdb.match() on composite field, ORDER BY rating (fast field)
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name, rating
FROM smoke_test WHERE description @@@ pdb.match('wireless OR shoes')
ORDER BY rating DESC, id LIMIT 3;
                                                                                                     QUERY PLAN                                                                                                     
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: TopNScanExecState
         Scores: false
            TopN Order By: rating desc, id asc
            TopN Limit: 3
         Tantivy Query: {"with_index":{"query":{"match":{"field":"description","value":"wireless OR shoes","tokenizer":null,"distance":null,"transposition_cost_one":null,"prefix":null,"conjunction_mode":null}}}}
(9 rows)

SELECT id, name, rating
FROM smoke_test WHERE description @@@ pdb.match('wireless OR shoes')
ORDER BY rating DESC, id LIMIT 3;
 id |       name        | rating 
----+-------------------+--------
  1 | Running Shoes     |    4.5
  2 | Wireless Keyboard |    4.2
(2 rows)

-- TopN with pdb.regex() on composite field
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name, pdb.score(id) as score
FROM smoke_test WHERE description @@@ pdb.regex('.*boot.*')
ORDER BY score DESC, id LIMIT 2;
                                               QUERY PLAN                                               
--------------------------------------------------------------------------------------------------------
 Limit
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: TopNScanExecState
         Scores: true
            TopN Order By: pdb.score() desc, id asc
            TopN Limit: 2
         Tantivy Query: {"with_index":{"query":{"regex":{"field":"description","pattern":".*boot.*"}}}}
(9 rows)

SELECT id, name, pdb.score(id) as score
FROM smoke_test WHERE description @@@ pdb.regex('.*boot.*')
ORDER BY score DESC, id LIMIT 2;
 id |     name     | score 
----+--------------+-------
  6 | Hiking Boots |     1
(1 row)

-- TopN with multiple composite field conditions
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name, pdb.score(id) as score
FROM smoke_test WHERE name @@@ pdb.term('wireless') OR description @@@ pdb.match('keyboard')
ORDER BY score DESC, id LIMIT 2;
                                                                                                                                                          QUERY PLAN                                                                                                                                                          
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   ->  Custom Scan (ParadeDB Scan) on smoke_test
         Table: smoke_test
         Index: smoke_idx
         Exec Method: TopNScanExecState
         Scores: true
            TopN Order By: pdb.score() desc, id asc
            TopN Limit: 2
         Tantivy Query: {"boolean":{"should":[{"with_index":{"query":{"term":{"field":"name","value":"wireless","is_datetime":false}}}},{"with_index":{"query":{"match":{"field":"description","value":"keyboard","tokenizer":null,"distance":null,"transposition_cost_one":null,"prefix":null,"conjunction_mode":null}}}}]}}
(9 rows)

SELECT id, name, pdb.score(id) as score
FROM smoke_test WHERE name @@@ pdb.term('wireless') OR description @@@ pdb.match('keyboard')
ORDER BY score DESC, id LIMIT 2;
 id |       name        |   score   
----+-------------------+-----------
  2 | Wireless Keyboard | 3.5649192
(1 row)

------------------------------------------------------------
-- TEST: JSON fields in composite types
------------------------------------------------------------
CREATE TYPE json_composite AS (
    metadata JSONB,
    tags TEXT[]
);
CREATE TABLE json_test (
    id SERIAL PRIMARY KEY,
    metadata JSONB,
    tags TEXT[]
);
CREATE INDEX idx_json_composite ON json_test USING bm25 (
    id,
    (ROW(metadata, tags)::json_composite)
) WITH (key_field='id');
-- Validate schema shows JSON field
SELECT * FROM paradedb.schema('idx_json_composite') ORDER BY name;
   name   | field_type | stored | indexed | fast | fieldnorms | expand_dots |            tokenizer             |  record  | normalizer 
----------+------------+--------+---------+------+------------+-------------+----------------------------------+----------+------------
 ctid     | U64        | f      | t       | t    | f          |             |                                  |          | 
 id       | I64        | f      | t       | t    | f          |             |                                  |          | 
 metadata | JsonObject | f      | t       | f    | f          | t           | unicode_words_removeemojis:false | position | 
 tags     | Str        | f      | t       | f    | t          |             | unicode_words_removeemojis:false | position | 
(4 rows)

INSERT INTO json_test (metadata, tags) VALUES
    ('{"title": "PostgreSQL Guide", "author": "John", "year": 2024}', ARRAY['database', 'tutorial']),
    ('{"title": "Search Engine Basics", "author": "Jane", "year": 2023}', ARRAY['search', 'guide']);
-- Search JSON field using key_field with full path
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, metadata FROM json_test WHERE id @@@ pdb.parse('metadata.title:PostgreSQL');
                                                               QUERY PLAN                                                                
-----------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ParadeDB Scan) on json_test
   Table: json_test
   Index: idx_json_composite
   Exec Method: NormalScanExecState
   Scores: false
   Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"metadata.title:PostgreSQL","lenient":null,"conjunction_mode":null}}}}
(6 rows)

SELECT id, metadata FROM json_test WHERE id @@@ pdb.parse('metadata.title:PostgreSQL');
 id |                           metadata                            
----+---------------------------------------------------------------
  1 | {"year": 2024, "title": "PostgreSQL Guide", "author": "John"}
(1 row)

-- Search JSON field using JSON path operator
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, metadata FROM json_test WHERE metadata->>'title' @@@ 'PostgreSQL';
                                                                          QUERY PLAN                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ParadeDB Scan) on json_test
   Table: json_test
   Index: idx_json_composite
   Exec Method: NormalScanExecState
   Scores: false
   Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"metadata.title","query_string":"PostgreSQL","lenient":null,"conjunction_mode":null}}}}
(6 rows)

SELECT id, metadata FROM json_test WHERE metadata->>'title' @@@ 'PostgreSQL';
 id |                           metadata                            
----+---------------------------------------------------------------
  1 | {"year": 2024, "title": "PostgreSQL Guide", "author": "John"}
(1 row)

-- Search JSON nested path using key_field
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, metadata FROM json_test WHERE id @@@ pdb.parse('metadata.author:John');
                                                             QUERY PLAN                                                             
------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ParadeDB Scan) on json_test
   Table: json_test
   Index: idx_json_composite
   Exec Method: NormalScanExecState
   Scores: false
   Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"metadata.author:John","lenient":null,"conjunction_mode":null}}}}
(6 rows)

SELECT id, metadata FROM json_test WHERE id @@@ pdb.parse('metadata.author:John');
 id |                           metadata                            
----+---------------------------------------------------------------
  1 | {"year": 2024, "title": "PostgreSQL Guide", "author": "John"}
(1 row)

-- Search JSON nested path using JSON path operator
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, metadata FROM json_test WHERE metadata->>'author' @@@ 'John';
                                                                       QUERY PLAN                                                                        
---------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ParadeDB Scan) on json_test
   Table: json_test
   Index: idx_json_composite
   Exec Method: NormalScanExecState
   Scores: false
   Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"metadata.author","query_string":"John","lenient":null,"conjunction_mode":null}}}}
(6 rows)

SELECT id, metadata FROM json_test WHERE metadata->>'author' @@@ 'John';
 id |                           metadata                            
----+---------------------------------------------------------------
  1 | {"year": 2024, "title": "PostgreSQL Guide", "author": "John"}
(1 row)

------------------------------------------------------------
-- TEST: Array fields in composite types
------------------------------------------------------------
-- Search array field using key_field
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, tags FROM json_test WHERE id @@@ pdb.parse('tags:database');
                                                         QUERY PLAN                                                          
-----------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ParadeDB Scan) on json_test
   Table: json_test
   Index: idx_json_composite
   Exec Method: NormalScanExecState
   Scores: false
   Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"tags:database","lenient":null,"conjunction_mode":null}}}}
(6 rows)

SELECT id, tags FROM json_test WHERE id @@@ pdb.parse('tags:database');
 id |        tags         
----+---------------------
  1 | {database,tutorial}
(1 row)

-- Search array field using source column
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, tags FROM json_test WHERE tags @@@ pdb.parse('database');
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ParadeDB Scan) on json_test
   Table: json_test
   Index: idx_json_composite
   Exec Method: NormalScanExecState
   Scores: false
   Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"database","lenient":null,"conjunction_mode":null}}}}
(6 rows)

SELECT id, tags FROM json_test WHERE tags @@@ pdb.parse('database');
 id |        tags         
----+---------------------
  1 | {database,tutorial}
(1 row)

------------------------------------------------------------
-- TEST: Multiple tokenizers per field using composite types
------------------------------------------------------------
CREATE TYPE multi_tokenizer_composite AS (
    desc_standard TEXT,          -- Standard word tokenization
    desc_ngram pdb.ngram(3, 3)   -- Partial matching with ngram (min=3, max=3)
);
CREATE TABLE multi_tokenizer_test (
    id SERIAL PRIMARY KEY,
    description TEXT
);
CREATE INDEX idx_multi_tokenizer ON multi_tokenizer_test USING bm25 (
    id,
    (ROW(description, description::pdb.ngram(3,3))::multi_tokenizer_composite)
) WITH (key_field='id');
-- Validate schema shows both fields with different tokenizers
SELECT * FROM paradedb.schema('idx_multi_tokenizer') ORDER BY name;
     name      | field_type | stored | indexed | fast | fieldnorms | expand_dots |                 tokenizer                  |  record  | normalizer 
---------------+------------+--------+---------+------+------------+-------------+--------------------------------------------+----------+------------
 ctid          | U64        | f      | t       | t    | f          |             |                                            |          | 
 desc_ngram    | Str        | f      | t       | f    | t          |             | ngram_mingram:3_maxgram:3_prefixonly:false | position | 
 desc_standard | Str        | f      | t       | f    | t          |             | unicode_words_removeemojis:false           | position | 
 id            | I64        | f      | t       | t    | f          |             |                                            |          | 
(4 rows)

INSERT INTO multi_tokenizer_test (description) VALUES
    ('PostgreSQL is a powerful database'),
    ('MySQL is also popular'),
    ('Search engines use indexing');
-- Search using standard tokenizer via source column (full word match)
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, description FROM multi_tokenizer_test WHERE description @@@ pdb.parse('powerful');
                                                       QUERY PLAN                                                       
------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ParadeDB Scan) on multi_tokenizer_test
   Table: multi_tokenizer_test
   Index: idx_multi_tokenizer
   Exec Method: NormalScanExecState
   Scores: false
   Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"powerful","lenient":null,"conjunction_mode":null}}}}
(6 rows)

SELECT id, description FROM multi_tokenizer_test WHERE description @@@ pdb.parse('powerful');
 id |            description            
----+-----------------------------------
  1 | PostgreSQL is a powerful database
(1 row)

-- Search using ngram tokenizer via key_field (partial match - 'owe' is inside 'powerful')
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, description FROM multi_tokenizer_test WHERE id @@@ pdb.parse('desc_ngram:owe');
                                                          QUERY PLAN                                                          
------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ParadeDB Scan) on multi_tokenizer_test
   Table: multi_tokenizer_test
   Index: idx_multi_tokenizer
   Exec Method: NormalScanExecState
   Scores: false
   Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"desc_ngram:owe","lenient":null,"conjunction_mode":null}}}}
(6 rows)

SELECT id, description FROM multi_tokenizer_test WHERE id @@@ pdb.parse('desc_ngram:owe');
 id |            description            
----+-----------------------------------
  1 | PostgreSQL is a powerful database
(1 row)

-- Search using ngram tokenizer via tokenizer cast expression (matches ROW arg at position 1)
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, description FROM multi_tokenizer_test WHERE description::pdb.ngram(3,3) @@@ pdb.parse('owe');
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Custom Scan (ParadeDB Scan) on multi_tokenizer_test
   Table: multi_tokenizer_test
   Index: idx_multi_tokenizer
   Exec Method: NormalScanExecState
   Scores: false
   Tantivy Query: {"with_index":{"query":{"parse":{"query_string":"owe","lenient":null,"conjunction_mode":null}}}}
(6 rows)

SELECT id, description FROM multi_tokenizer_test WHERE description::pdb.ngram(3,3) @@@ pdb.parse('owe');
 id |            description            
----+-----------------------------------
  1 | PostgreSQL is a powerful database
(1 row)

-- Same query with simple string shows explicit field name in Tantivy Query (parse_with_field)
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, description FROM multi_tokenizer_test WHERE description::pdb.ngram(3,3) @@@ 'owe';
                                                                    QUERY PLAN                                                                     
---------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ParadeDB Scan) on multi_tokenizer_test
   Table: multi_tokenizer_test
   Index: idx_multi_tokenizer
   Exec Method: NormalScanExecState
   Scores: false
   Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"desc_ngram","query_string":"owe","lenient":null,"conjunction_mode":null}}}}
(6 rows)

SELECT id, description FROM multi_tokenizer_test WHERE description::pdb.ngram(3,3) @@@ 'owe';
 id |            description            
----+-----------------------------------
  1 | PostgreSQL is a powerful database
(1 row)

------------------------------------------------------------
-- TEST: Non-text expressions in composite fields
------------------------------------------------------------
CREATE TYPE numeric_expr_composite AS (
    original_price FLOAT,
    discounted_price FLOAT
);
CREATE TABLE numeric_expr_test (
    id SERIAL PRIMARY KEY,
    price FLOAT
);
CREATE INDEX idx_numeric_expr ON numeric_expr_test USING bm25 (
    id,
    (ROW(price, price * 0.9)::numeric_expr_composite)
) WITH (key_field='id');
-- Validate schema
SELECT * FROM paradedb.schema('idx_numeric_expr') ORDER BY name;
       name       | field_type | stored | indexed | fast | fieldnorms | expand_dots | tokenizer | record | normalizer 
------------------+------------+--------+---------+------+------------+-------------+-----------+--------+------------
 ctid             | U64        | f      | t       | t    | f          |             |           |        | 
 discounted_price | F64        | f      | t       | t    | f          |             |           |        | 
 id               | I64        | f      | t       | t    | f          |             |           |        | 
 original_price   | F64        | f      | t       | t    | f          |             |           |        | 
(4 rows)

INSERT INTO numeric_expr_test (price) VALUES (100.00), (200.00), (50.00);
-- Range query on original price (use the expression 'price' which maps to 'original_price' field)
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, price FROM numeric_expr_test WHERE price @@@ pdb.range(numrange(75, 150, '[]'));
                                                                             QUERY PLAN                                                                              
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ParadeDB Scan) on numeric_expr_test
   Table: numeric_expr_test
   Index: idx_numeric_expr
   Exec Method: NormalScanExecState
   Scores: false
   Tantivy Query: {"with_index":{"query":{"range":{"field":"original_price","lower_bound":{"included":"75"},"upper_bound":{"included":"150"},"is_datetime":false}}}}
(6 rows)

SELECT id, price FROM numeric_expr_test WHERE price @@@ pdb.range(numrange(75, 150, '[]'));
 id | price 
----+-------
  1 |   100
(1 row)

-- Range query on calculated discounted price (use the expression 'price * 0.9' which maps to 'discounted_price' field)
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, price FROM numeric_expr_test WHERE (price * 0.9) @@@ pdb.range(numrange(80, 100, '[]'));
                                                                              QUERY PLAN                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ParadeDB Scan) on numeric_expr_test
   Table: numeric_expr_test
   Index: idx_numeric_expr
   Exec Method: NormalScanExecState
   Scores: false
   Tantivy Query: {"with_index":{"query":{"range":{"field":"discounted_price","lower_bound":{"included":"80"},"upper_bound":{"included":"100"},"is_datetime":false}}}}
(6 rows)

SELECT id, price FROM numeric_expr_test WHERE (price * 0.9) @@@ pdb.range(numrange(80, 100, '[]'));
 id | price 
----+-------
  1 |   100
(1 row)

\i common/composite_cleanup.sql
-- Cleanup for composite type tests
DROP SCHEMA IF EXISTS composite_test CASCADE;
RESET search_path;
