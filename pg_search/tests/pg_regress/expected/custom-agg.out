-- Test custom agg function with paradedb.agg()
CREATE EXTENSION IF NOT EXISTS pg_search;
SET paradedb.enable_aggregate_custom_scan TO on;
DROP TABLE IF EXISTS logs CASCADE;
-- Setup test data
CREATE TABLE logs (
    id SERIAL PRIMARY KEY,
    description TEXT,
    severity TEXT,
    category TEXT,
    response_time INT,
    status_code INT,
    timestamp TIMESTAMP
);
INSERT INTO logs (description, severity, category, response_time, status_code, timestamp) VALUES
    ('Database connection error', 'error', 'database', 150, 500, '2024-01-01 10:00:00'),
    ('Failed to fetch data', 'error', 'api', 200, 404, '2024-01-01 10:01:00'),
    ('Timeout connecting to service', 'error', 'network', 5000, 503, '2024-01-01 10:02:00'),
    ('Invalid query syntax error', 'error', 'database', 50, 400, '2024-01-01 10:03:00');
CREATE INDEX logs_idx ON logs USING bm25 (id, description, severity, category, response_time, status_code, timestamp)
WITH (
    key_field = 'id',
    text_fields = '{"description": {}, "severity": {"fast": true}, "category": {"fast": true}}',
    numeric_fields = '{"response_time": {"fast": true}, "status_code": {"fast": true}}',
    datetime_fields = '{"timestamp": {"fast": true}}'
);
-- Test 1: Simple custom agg with terms aggregation (without search query - should fail gracefully or not be intercepted)
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF, VERBOSE)
SELECT category, paradedb.agg('{"terms": {"field": "severity"}}'::jsonb)
FROM logs
WHERE description @@@ 'error'
GROUP BY category;
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ParadeDB Aggregate Scan) on public.logs
   Output: category, now()
   Index: logs_idx
   Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"error","lenient":null,"conjunction_mode":null}}}}
     Applies to Aggregates: CUSTOM_AGG({"terms":{"field":"severity"}})
     Group By: category
     Aggregate Definition: {"grouped":{"aggs":{"0":{"terms":{"field":"severity"}}},"terms":{"field":"category","segment_size":65000,"size":65000}}}
(7 rows)

SELECT category, paradedb.agg('{"terms": {"field": "severity"}}'::jsonb)
FROM logs
WHERE description @@@ 'error'
GROUP BY category;
 category | agg 
----------+-----
 database | 
(1 row)

-- Test 2: Custom agg in window function
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF, VERBOSE)
SELECT *, paradedb.agg('{"avg": {"field": "response_time"}}'::jsonb) OVER ()
FROM logs
WHERE description @@@ 'error'
ORDER BY timestamp DESC LIMIT 10;
                                                                                                                QUERY PLAN                                                                                                                 
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: id, description, severity, category, response_time, status_code, "timestamp", (paradedb.window_func('{"agg_types":[{"Custom":{"agg_json":{"avg":{"field":"response_time"}},"filter":null}}],"grouping_columns":[]}'::text))
   ->  Custom Scan (ParadeDB Scan) on public.logs
         Output: id, description, severity, category, response_time, status_code, "timestamp", paradedb.window_func('{"agg_types":[{"Custom":{"agg_json":{"avg":{"field":"response_time"}},"filter":null}}],"grouping_columns":[]}'::text)
         Table: logs
         Index: logs_idx
         Exec Method: TopNScanExecState
         Scores: false
            TopN Order By: timestamp desc
            TopN Limit: 10
         Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"error","lenient":null,"conjunction_mode":null}}}}
(11 rows)

SELECT *, paradedb.agg('{"avg": {"field": "response_time"}}'::jsonb) OVER ()
FROM logs
WHERE description @@@ 'error'
ORDER BY timestamp DESC LIMIT 10;
 id |        description         | severity | category | response_time | status_code |        timestamp         |              agg              
----+----------------------------+----------+----------+---------------+-------------+--------------------------+-------------------------------
  4 | Invalid query syntax error | error    | database |            50 |         400 | Mon Jan 01 10:03:00 2024 | {"result": "not implemented"}
  1 | Database connection error  | error    | database |           150 |         500 | Mon Jan 01 10:00:00 2024 | {"result": "not implemented"}
(2 rows)

-- Test 3: Mix custom and standard aggregates
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF, VERBOSE)
SELECT category, 
       COUNT(*),
       paradedb.agg('{"terms": {"field": "severity"}}'::jsonb)
FROM logs
WHERE description @@@ 'error'
GROUP BY category;
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ParadeDB Aggregate Scan) on public.logs
   Output: category, now(), now()
   Index: logs_idx
   Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"error","lenient":null,"conjunction_mode":null}}}}
     Applies to Aggregates: COUNT(*), CUSTOM_AGG({"terms":{"field":"severity"}})
     Group By: category
     Aggregate Definition: {"grouped":{"aggs":{"1":{"terms":{"field":"severity"}}},"terms":{"field":"category","segment_size":65000,"size":65000}}}
(7 rows)

SELECT category, 
       COUNT(*),
       paradedb.agg('{"terms": {"field": "severity"}}'::jsonb)
FROM logs
WHERE description @@@ 'error'
GROUP BY category;
 category | count | agg 
----------+-------+-----
 database |     2 | 
(1 row)

-- Test 4: Custom agg with FILTER (extracted at planning time)
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF, VERBOSE)
SELECT paradedb.agg('{"avg": {"field": "response_time"}}'::jsonb) 
       FILTER (WHERE status_code >= 500)
FROM logs
WHERE description @@@ 'error';
                                                                                                                                       QUERY PLAN                                                                                                                                       
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ParadeDB Aggregate Scan) on public.logs
   Output: now()
   Index: logs_idx
     Combined Query: {"boolean":{"must":[{"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"error","lenient":null,"conjunction_mode":null}}}},{"range":{"field":"status_code","lower_bound":{"included":500},"upper_bound":null,"is_datetime":false}}]}}
     Applies to Aggregates: CUSTOM_AGG({"avg":{"field":"response_time"}}) FILTER (WHERE {"range":{"field":"status_code","lower_bound":{"included":500},"upper_bound":null,"is_datetime":false}})
(5 rows)

SELECT paradedb.agg('{"avg": {"field": "response_time"}}'::jsonb) 
       FILTER (WHERE status_code >= 500)
FROM logs
WHERE description @@@ 'error';
 agg 
-----
 
(1 row)

-- Test 5: Custom agg with FILTER and OVER (window function)
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF, VERBOSE)
SELECT *, paradedb.agg('{"terms": {"field": "category"}}'::jsonb) 
       FILTER (WHERE status_code >= 500) OVER ()
FROM logs
WHERE description @@@ 'error'
ORDER BY timestamp DESC LIMIT 10;
                                                                                                QUERY PLAN                                                                                                
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: id, description, severity, category, response_time, status_code, "timestamp", (paradedb.agg('{"terms": {"field": "category"}}'::jsonb) FILTER (WHERE (status_code >= 500)) OVER (?))
   ->  Sort
         Output: id, description, severity, category, response_time, status_code, "timestamp", (paradedb.agg('{"terms": {"field": "category"}}'::jsonb) FILTER (WHERE (status_code >= 500)) OVER (?))
         Sort Key: logs."timestamp" DESC
         ->  WindowAgg
               Output: id, description, severity, category, response_time, status_code, "timestamp", paradedb.agg('{"terms": {"field": "category"}}'::jsonb) FILTER (WHERE (status_code >= 500)) OVER (?)
               ->  Custom Scan (ParadeDB Scan) on public.logs
                     Output: id, description, severity, category, response_time, status_code, "timestamp"
                     Table: logs
                     Index: logs_idx
                     Exec Method: NormalScanExecState
                     Scores: false
                     Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"error","lenient":null,"conjunction_mode":null}}}}
(14 rows)

SELECT *, paradedb.agg('{"terms": {"field": "category"}}'::jsonb) 
       FILTER (WHERE status_code >= 500) OVER ()
FROM logs
WHERE description @@@ 'error'
ORDER BY timestamp DESC LIMIT 10;
 id |        description         | severity | category | response_time | status_code |        timestamp         |             agg             
----+----------------------------+----------+----------+---------------+-------------+--------------------------+-----------------------------
  4 | Invalid query syntax error | error    | database |            50 |         400 | Mon Jan 01 10:03:00 2024 | {"result": "not supported"}
  1 | Database connection error  | error    | database |           150 |         500 | Mon Jan 01 10:00:00 2024 | {"result": "not supported"}
(2 rows)

-- Test 6: EXPLAIN query to show custom agg is recognized
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF, VERBOSE)
SELECT category, 
       COUNT(*),
       paradedb.agg('{"max": {"field": "response_time"}}'::jsonb)
FROM logs
WHERE description @@@ 'error'
GROUP BY category;
                                                                              QUERY PLAN                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ParadeDB Aggregate Scan) on public.logs
   Output: category, now(), now()
   Index: logs_idx
   Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"error","lenient":null,"conjunction_mode":null}}}}
     Applies to Aggregates: COUNT(*), CUSTOM_AGG({"max":{"field":"response_time"}})
     Group By: category
     Aggregate Definition: {"grouped":{"aggs":{"1":{"max":{"field":"response_time","missing":null}}},"terms":{"field":"category","segment_size":65000,"size":65000}}}
(7 rows)

SELECT category, 
       COUNT(*),
       paradedb.agg('{"max": {"field": "response_time"}}'::jsonb)
FROM logs
WHERE description @@@ 'error'
GROUP BY category;
 category | count | agg 
----------+-------+-----
 database |     2 | 
(1 row)

-- Cleanup
DROP TABLE logs CASCADE;
