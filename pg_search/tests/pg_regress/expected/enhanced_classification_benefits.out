-- Test cases demonstrating the benefits of Enhanced Condition Classification
-- These tests show concrete improvements over the basic implementation
-- that was previously in place
-- Load the pg_search extension
CREATE EXTENSION IF NOT EXISTS pg_search;
-- Setup test tables for demonstrating classification benefits
DROP TABLE IF EXISTS products;
DROP TABLE IF EXISTS categories;
DROP TABLE IF EXISTS reviews;
CREATE TABLE categories (
    id SERIAL PRIMARY KEY,
    name TEXT,
    description TEXT,
    is_active BOOLEAN DEFAULT true
);
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name TEXT,
    description TEXT,
    category_id INTEGER REFERENCES categories(id),
    price DECIMAL(10,2),
    in_stock BOOLEAN DEFAULT true
);
CREATE TABLE reviews (
    id SERIAL PRIMARY KEY,
    product_id INTEGER REFERENCES products(id),
    content TEXT,
    rating INTEGER,
    is_verified BOOLEAN DEFAULT false
);
-- Insert test data
INSERT INTO categories (name, description, is_active) VALUES
('Electronics', 'Electronic devices and gadgets', true),
('Books', 'Books and publications', true),
('Clothing', 'Apparel and accessories', true),
('Sports', 'Sports equipment and gear', false);
INSERT INTO products (name, description, category_id, price, in_stock) VALUES
('Smartphone', 'Latest smartphone with advanced features', 1, 699.99, true),
('Laptop', 'High-performance laptop for professionals', 1, 1299.99, true),
('Novel', 'Bestselling fiction novel', 2, 19.99, true),
('T-Shirt', 'Comfortable cotton t-shirt', 3, 29.99, false),
('Basketball', 'Professional basketball equipment', 4, 89.99, true);
INSERT INTO reviews (product_id, content, rating, is_verified) VALUES
(1, 'Amazing smartphone with great camera quality', 5, true),
(2, 'Excellent laptop performance for work and gaming', 4, true),
(3, 'Captivating story with excellent character development', 5, false),
(1, 'Good value smartphone but battery could be better', 4, true),
(2, 'Great laptop but a bit expensive for students', 3, false);
-- Create BM25 indexes
CREATE INDEX categories_bm25_idx ON categories USING bm25 (id, name, description) WITH (key_field = 'id');
CREATE INDEX products_bm25_idx ON products USING bm25 (id, name, description) WITH (key_field = 'id');
CREATE INDEX reviews_bm25_idx ON reviews USING bm25 (id, content) WITH (key_field = 'id');
-- =============================================================================
-- BENEFIT 1: Detailed Diagnostic Messages for Complex Boolean Logic
-- =============================================================================
SELECT '=== BENEFIT 1: Enhanced Diagnostic Messages ===' as section;
                     section                     
-------------------------------------------------
 === BENEFIT 1: Enhanced Diagnostic Messages ===
(1 row)

-- Test Case 1a: Complex AND expression with mixed safety levels
-- The enhanced system provides detailed breakdowns of which clauses are safe vs unsafe
SELECT 
    'Test 1a: Complex AND with mixed safety' as test_name,
    p.name as product_name,
    c.name as category_name,
    paradedb.score(p.id) as product_score,
    paradedb.score(c.id) as category_score
FROM products p
JOIN categories c ON p.category_id = c.id
WHERE (p.description @@@ 'smartphone' AND p.price > 500)  -- Mixed: search + non-indexed
  AND (c.name @@@ 'Electronics' AND c.is_active = true)   -- Mixed: search + indexed
ORDER BY product_score DESC;
               test_name                | product_name | category_name | product_score | category_score 
----------------------------------------+--------------+---------------+---------------+----------------
 Test 1a: Complex AND with mixed safety | Smartphone   | Electronics   |      1.257669 |      1.2039728
(1 row)

-- Test Case 1b: Complex OR expression requiring all clauses to be safe
-- The enhanced system explains why OR expressions are rejected when any clause is unsafe
SELECT 
    'Test 1b: OR expression safety analysis' as test_name,
    p.name as product_name,
    r.content as review_content,
    paradedb.score(p.id) as product_score,
    paradedb.score(r.id) as review_score
FROM products p
JOIN reviews r ON p.id = r.product_id
WHERE (p.description @@@ 'laptop' OR r.content @@@ 'excellent')  -- Both search terms (potentially safe)
   OR (p.price > 1000 OR r.rating > 4)                          -- Non-indexed terms (unsafe)
ORDER BY product_score DESC;
WARNING:  ri_tostring: Starting
WARNING:  ri_tostring: Processing clause
WARNING:  ri_tostring: Returning result
WARNING:  >>> 333 baseri is empty and pushed_down_joinri is not empty: "RestrictInfo { clause: ((table_1.col_1 op_401354 <const_type_401235>) OR (table_2.col_1 op_401354 <const_type_401235>) OR (table_1.col_5 op_1756 <const_type_1700>) OR (table_2.col_4 op_521 4)) }"
WARNING:  ri_tostring: Starting
WARNING:  ri_tostring: Processing clause
WARNING:  ri_tostring: Returning result
WARNING:  >>> 333 baseri is empty and pushed_down_joinri is not empty: "RestrictInfo { clause: ((table_1.col_1 op_401354 <const_type_401235>) OR (table_2.col_1 op_401354 <const_type_401235>) OR (table_1.col_5 op_1756 <const_type_1700>) OR (table_2.col_4 op_521 4)) }"
               test_name                | product_name |                     review_content                     | product_score | review_score 
----------------------------------------+--------------+--------------------------------------------------------+---------------+--------------
 Test 1b: OR expression safety analysis | Laptop       | Excellent laptop performance for work and gaming       |      1.257669 |    0.8754688
 Test 1b: OR expression safety analysis | Laptop       | Great laptop but a bit expensive for students          |      1.257669 |            0
 Test 1b: OR expression safety analysis | Smartphone   | Amazing smartphone with great camera quality           |             0 |            0
 Test 1b: OR expression safety analysis | Novel        | Captivating story with excellent character development |             0 |   0.92980814
(4 rows)

-- =============================================================================
-- BENEFIT 2: Intelligent Partial Salvage of AND Expressions
-- =============================================================================
SELECT '=== BENEFIT 2: Intelligent AND Expression Handling ===' as section;
                        section                         
--------------------------------------------------------
 === BENEFIT 2: Intelligent AND Expression Handling ===
(1 row)

-- Test Case 2a: AND expression where some clauses can be salvaged
-- The enhanced system can salvage safe parts of AND expressions
SELECT 
    'Test 2a: Salvaging safe parts of AND' as test_name,
    p.name as product_name,
    paradedb.score(p.id) as product_score
FROM products p
JOIN categories c ON p.category_id = c.id
WHERE (p.description @@@ 'laptop')        -- Safe: search on target table
  AND (p.price > 1000)                    -- Unsafe: non-indexed field
  AND (c.name @@@ 'Electronics')         -- Unsafe: external table reference
ORDER BY product_score DESC;
              test_name               | product_name | product_score 
--------------------------------------+--------------+---------------
 Test 2a: Salvaging safe parts of AND | Laptop       |      1.257669
(1 row)

-- Test Case 2b: Comparison with simple condition to show salvage benefit
-- This shows what happens when we can push down the safe part
SELECT 
    'Test 2b: Direct query for comparison' as test_name,
    p.name as product_name,
    paradedb.score(p.id) as product_score
FROM products p
WHERE p.description @@@ 'laptop'
ORDER BY product_score DESC;
              test_name               | product_name | product_score 
--------------------------------------+--------------+---------------
 Test 2b: Direct query for comparison | Laptop       |      1.257669
(1 row)

-- =============================================================================
-- BENEFIT 3: Conservative OR Handling Prevents Semantic Violations
-- =============================================================================
SELECT '=== BENEFIT 3: Conservative OR Handling ===' as section;
                   section                   
---------------------------------------------
 === BENEFIT 3: Conservative OR Handling ===
(1 row)

-- Test Case 3a: OR with external variables (should be rejected)
-- The enhanced system correctly identifies why OR expressions are dangerous
SELECT 
    'Test 3a: OR with external variables' as test_name,
    p.name as product_name,
    c.name as category_name,
    paradedb.score(p.id) as product_score,
    paradedb.score(c.id) as category_score
FROM products p
JOIN categories c ON p.category_id = c.id
WHERE (p.description @@@ 'smartphone')    -- Safe condition on products
   OR (c.description @@@ 'electronic')    -- External condition on categories
ORDER BY product_score DESC;
WARNING:  ri_tostring: Starting
WARNING:  ri_tostring: Processing clause
WARNING:  ri_tostring: Returning result
WARNING:  >>> 333 baseri is empty and pushed_down_joinri is not empty: "RestrictInfo { clause: ((table_1.col_1 op_401354 <const_type_401235>) OR (table_2.col_1 op_401354 <const_type_401235>)) }"
WARNING:  ri_tostring: Starting
WARNING:  ri_tostring: Processing clause
WARNING:  ri_tostring: Returning result
WARNING:  >>> 333 baseri is empty and pushed_down_joinri is not empty: "RestrictInfo { clause: ((table_1.col_1 op_401354 <const_type_401235>) OR (table_2.col_1 op_401354 <const_type_401235>)) }"
              test_name              | product_name | category_name | product_score | category_score 
-------------------------------------+--------------+---------------+---------------+----------------
 Test 3a: OR with external variables | Smartphone   | Electronics   |      1.257669 |      1.1374958
 Test 3a: OR with external variables | Laptop       | Electronics   |             0 |      1.1374958
(2 rows)

-- Test Case 3b: Safe OR expression (all clauses reference same table)
-- Shows when OR expressions can be safely pushed down
SELECT 
    'Test 3b: Safe OR expression' as test_name,
    p.name as product_name,
    paradedb.score(p.id) as product_score
FROM products p
WHERE (p.description @@@ 'smartphone')
   OR (p.name @@@ 'laptop')
ORDER BY product_score DESC;
          test_name          | product_name | product_score 
-----------------------------+--------------+---------------
 Test 3b: Safe OR expression | Laptop       |     1.4877304
 Test 3b: Safe OR expression | Smartphone   |      1.257669
(2 rows)

-- =============================================================================
-- BENEFIT 4: Enhanced Edge Case Detection
-- =============================================================================
SELECT '=== BENEFIT 4: Enhanced Edge Case Detection ===' as section;
                     section                     
-------------------------------------------------
 === BENEFIT 4: Enhanced Edge Case Detection ===
(1 row)

-- Test Case 4a: Nested boolean expressions
-- The enhanced system handles complex nested logic with detailed analysis
SELECT 
    'Test 4a: Nested boolean logic' as test_name,
    p.name as product_name,
    paradedb.score(p.id) as product_score
FROM products p
JOIN categories c ON p.category_id = c.id
JOIN reviews r ON p.id = r.product_id
WHERE (
    (p.description @@@ 'smartphone' AND p.in_stock = true)   -- Mixed safety on products
    OR 
    (c.name @@@ 'Electronics' AND r.rating > 4)             -- Cross-table OR (unsafe)
)
ORDER BY product_score DESC;
WARNING:  ri_tostring: Starting
WARNING:  ri_tostring: Processing clause
WARNING:  ri_tostring: Returning result
WARNING:  >>> 333 baseri is empty and pushed_down_joinri is not empty: "RestrictInfo { clause: (((table_1.col_1 op_401354 <const_type_401235>) AND table_1.col_6) OR ((table_2.col_1 op_401354 <const_type_401235>) AND (table_4.col_4 op_521 4))) }"
WARNING:  ri_tostring: Starting
WARNING:  ri_tostring: Processing clause
WARNING:  ri_tostring: Returning result
WARNING:  >>> 333 baseri is empty and pushed_down_joinri is not empty: "RestrictInfo { clause: (((table_1.col_1 op_401354 <const_type_401235>) AND table_1.col_6) OR ((table_2.col_1 op_401354 <const_type_401235>) AND (table_4.col_4 op_521 4))) }"
WARNING:  ri_tostring: Starting
WARNING:  ri_tostring: Processing clause
WARNING:  ri_tostring: Returning result
WARNING:  >>> 333 baseri is empty and pushed_down_joinri is not empty: "RestrictInfo { clause: (((table_1.col_1 op_401354 <const_type_401235>) AND table_1.col_6) OR ((table_2.col_1 op_401354 <const_type_401235>) AND (table_4.col_4 op_521 4))) }"
           test_name           | product_name | product_score 
-------------------------------+--------------+---------------
 Test 4a: Nested boolean logic | Smartphone   |      1.257669
 Test 4a: Nested boolean logic | Smartphone   |      1.257669
(2 rows)

-- Test Case 4b: Mixed indexed and non-indexed conditions across tables
-- Shows how the system handles complex real-world scenarios
SELECT 
    'Test 4b: Mixed conditions across tables' as test_name,
    p.name as product_name,
    r.content as review_content,
    paradedb.score(p.id) as product_score,
    paradedb.score(r.id) as review_score
FROM products p
JOIN reviews r ON p.id = r.product_id
WHERE (p.description @@@ 'laptop' AND p.price > 1000)     -- Mixed on products
  AND (r.content @@@ 'excellent' AND r.is_verified = true) -- Mixed on reviews
ORDER BY product_score DESC;
                test_name                | product_name |                  review_content                  | product_score | review_score 
-----------------------------------------+--------------+--------------------------------------------------+---------------+--------------
 Test 4b: Mixed conditions across tables | Laptop       | Excellent laptop performance for work and gaming |      1.257669 |    0.8754688
(1 row)

-- =============================================================================
-- BENEFIT 5: Consistency in Score Calculation
-- =============================================================================
SELECT '=== BENEFIT 5: Score Consistency ===' as section;
               section                
--------------------------------------
 === BENEFIT 5: Score Consistency ===
(1 row)

-- Test Case 5a: Query that would have been incorrectly pushed down before
-- The enhanced system prevents incorrect pushdown that would give wrong scores
SELECT 
    'Test 5a: Prevented incorrect pushdown' as test_name,
    p.name as product_name,
    c.name as category_name,
    paradedb.score(p.id) as product_score,
    paradedb.score(c.id) as category_score
FROM products p
JOIN categories c ON p.category_id = c.id
WHERE (p.description @@@ 'smartphone')
  AND (c.name = 'Electronics')  -- Non-search condition that could cause issues
ORDER BY product_score DESC;
               test_name               | product_name | category_name | product_score | category_score 
---------------------------------------+--------------+---------------+---------------+----------------
 Test 5a: Prevented incorrect pushdown | Smartphone   | Electronics   |      1.257669 |               
(1 row)

-- Test Case 5b: Equivalent query structure showing consistent results
-- Shows that our fixes maintain consistent scoring
SELECT 
    'Test 5b: Consistent scoring verification' as test_name,
    p.name as product_name,
    paradedb.score(p.id) as product_score
FROM products p
WHERE p.description @@@ 'smartphone'
ORDER BY product_score DESC;
                test_name                 | product_name | product_score 
------------------------------------------+--------------+---------------
 Test 5b: Consistent scoring verification | Smartphone   |      1.257669
(1 row)

-- =============================================================================
-- BENEFIT 6: Improved Developer Experience with Clear Diagnostics
-- =============================================================================
SELECT '=== BENEFIT 6: Developer Experience Improvements ===' as section;
                       section                        
------------------------------------------------------
 === BENEFIT 6: Developer Experience Improvements ===
(1 row)

-- Test Case 6a: Query with multiple types of issues
-- The enhanced system provides specific feedback for each problem
SELECT 
    'Test 6a: Multiple diagnostic types' as test_name,
    p.name as product_name,
    c.name as category_name,
    r.content as review_content,
    paradedb.score(p.id) as product_score,
    paradedb.score(c.id) as category_score,
    paradedb.score(r.id) as review_score
FROM products p
JOIN categories c ON p.category_id = c.id
LEFT JOIN reviews r ON p.id = r.product_id
WHERE (
    -- This complex condition will trigger multiple diagnostic messages
    (p.description @@@ 'laptop' AND p.price > 1000)           -- Partially unsafe AND
    OR 
    (c.name @@@ 'Electronics' AND r.rating > 4)               -- Unsafe OR across tables
    OR
    (p.in_stock = true AND c.is_active = true)                -- Unknown conditions
)
ORDER BY product_score DESC;
WARNING:  ri_tostring: Starting
WARNING:  ri_tostring: Processing clause
WARNING:  ri_tostring: Returning result
WARNING:  >>> 333 baseri is empty and pushed_down_joinri is not empty: "RestrictInfo { clause: (((table_1.col_1 op_401354 <const_type_401235>) AND (table_1.col_5 op_1756 <const_type_1700>)) OR ((table_2.col_1 op_401354 <const_type_401235>) AND (table_4.col_4 op_521 4)) OR (table_1.col_6 AND table_2.col_4)) }"
WARNING:  ri_tostring: Starting
WARNING:  ri_tostring: Processing clause
WARNING:  ri_tostring: Returning result
WARNING:  >>> 333 baseri is empty and pushed_down_joinri is not empty: "RestrictInfo { clause: (((table_1.col_1 op_401354 <const_type_401235>) AND (table_1.col_5 op_1756 <const_type_1700>)) OR ((table_2.col_1 op_401354 <const_type_401235>) AND (table_4.col_4 op_521 4)) OR (table_1.col_6 AND table_2.col_4)) }"
WARNING:  ri_tostring: Starting
WARNING:  ri_tostring: Processing clause
WARNING:  ri_tostring: Returning result
WARNING:  >>> 333 baseri is empty and pushed_down_joinri is not empty: "RestrictInfo { clause: (((table_1.col_1 op_401354 <const_type_401235>) AND (table_1.col_5 op_1756 <const_type_1700>)) OR ((table_2.col_1 op_401354 <const_type_401235>) AND (table_4.col_4 op_521 4)) OR (table_1.col_6 AND table_2.col_4)) }"
             test_name              | product_name | category_name |                     review_content                     | product_score | category_score | review_score 
------------------------------------+--------------+---------------+--------------------------------------------------------+---------------+----------------+--------------
 Test 6a: Multiple diagnostic types | Smartphone   | Electronics   | Amazing smartphone with great camera quality           |               |                |             
 Test 6a: Multiple diagnostic types | Laptop       | Electronics   | Excellent laptop performance for work and gaming       |               |                |             
 Test 6a: Multiple diagnostic types | Novel        | Books         | Captivating story with excellent character development |               |                |             
 Test 6a: Multiple diagnostic types | Smartphone   | Electronics   | Good value smartphone but battery could be better      |               |                |             
 Test 6a: Multiple diagnostic types | Laptop       | Electronics   | Great laptop but a bit expensive for students          |               |                |             
(5 rows)

-- Test Case 6b: Query showing partial salvage in action
-- Demonstrates how AND expressions can have parts salvaged
SELECT 
    'Test 6b: Partial salvage demonstration' as test_name,
    p.name as product_name,
    paradedb.score(p.id) as product_score
FROM products p
JOIN categories c ON p.category_id = c.id
WHERE (p.description @@@ 'smartphone')   -- Safe: can be pushed down
  AND (p.price > 500)                    -- Unsafe: non-indexed
  AND (c.is_active = true)               -- Unsafe: external table
  AND (p.name @@@ 'phone')              -- Safe: can be pushed down
ORDER BY product_score DESC;
 test_name | product_name | product_score 
-----------+--------------+---------------
(0 rows)

-- =============================================================================
-- SUMMARY: Before vs After Comparison
-- =============================================================================
SELECT '=== SUMMARY: Benefits Demonstration ===' as section;
                 section                 
-----------------------------------------
 === SUMMARY: Benefits Demonstration ===
(1 row)

-- The enhanced system provides:
-- 1. Detailed diagnostic messages explaining exactly why conditions are rejected
-- 2. Intelligent handling of complex boolean logic with partial salvage
-- 3. Conservative OR handling that prevents semantic violations
-- 4. Better edge case detection for complex nested expressions
-- 5. Consistent score calculation by preventing incorrect pushdowns
-- 6. Improved developer experience with clear, actionable feedback
-- Example of diagnostic output you'll see:
-- WARNING: Rejecting join quals: OR expression: 1 safe, 2 unsafe, 0 unknown clauses (OR requires all safe)
-- WARNING: Partially rejecting join quals: AND expression: 2 safe, 2 unsafe, 0 unknown clauses
-- WARNING: Accepting join quals: boolean field condition on indexed field
-- Cleanup
DROP TABLE IF EXISTS reviews;
DROP TABLE IF EXISTS products;
DROP TABLE IF EXISTS categories; 
