-- Test cases that force conditions into joininfo to demonstrate hybrid join logic
-- These tests create scenarios where PostgreSQL cannot push conditions to baserestrictinfo
-- and our join condition pushdown logic is actually triggered
-- Load the pg_search extension
CREATE EXTENSION IF NOT EXISTS pg_search;
-- Setup test tables designed to trigger joininfo conditions
DROP TABLE IF EXISTS left_table;
DROP TABLE IF EXISTS right_table;
DROP TABLE IF EXISTS bridge_table;
CREATE TABLE left_table (
    id SERIAL PRIMARY KEY,
    content TEXT,
    category TEXT,
    value INTEGER
);
CREATE TABLE right_table (
    id SERIAL PRIMARY KEY,
    content TEXT,
    description TEXT,
    priority INTEGER
);
CREATE TABLE bridge_table (
    left_id INTEGER REFERENCES left_table(id),
    right_id INTEGER REFERENCES right_table(id),
    relationship_type TEXT,
    strength INTEGER
);
-- Insert test data
INSERT INTO left_table (content, category, value) VALUES
('smartphone technology', 'electronics', 100),
('laptop computer', 'electronics', 200),
('book fiction', 'literature', 50),
('game console', 'electronics', 150);
INSERT INTO right_table (content, description, priority) VALUES
('advanced features', 'smartphone capabilities', 1),
('high performance', 'laptop specifications', 2),
('storytelling', 'book narrative', 3),
('gaming experience', 'console features', 1);
INSERT INTO bridge_table (left_id, right_id, relationship_type, strength) VALUES
(1, 1, 'primary', 10),
(2, 2, 'primary', 9),
(3, 3, 'primary', 8),
(4, 4, 'primary', 7),
(1, 2, 'secondary', 5),
(2, 3, 'secondary', 3);
-- Create BM25 indexes
CREATE INDEX left_table_bm25_idx ON left_table USING bm25 (id, content, category) WITH (key_field = 'id');
CREATE INDEX right_table_bm25_idx ON right_table USING bm25 (id, content, description) WITH (key_field = 'id');
-- =============================================================================
-- Test Case 1: Complex join with conditions spanning multiple tables
-- This should force conditions into joininfo
-- =============================================================================
SELECT 'Test 1: Complex join forcing joininfo' as test_name;
               test_name               
---------------------------------------
 Test 1: Complex join forcing joininfo
(1 row)

-- This query structure forces PostgreSQL to put conditions in joininfo
-- because the condition spans multiple tables in a way that can't be pushed to baserestrictinfo
SELECT 
    l.content as left_content,
    r.content as right_content,
    b.relationship_type,
    paradedb.score(l.id) as left_score,
    paradedb.score(r.id) as right_score
FROM left_table l
JOIN bridge_table b ON l.id = b.left_id
JOIN right_table r ON r.id = b.right_id
WHERE (l.content @@@ 'smartphone' AND r.content @@@ 'advanced')  -- Search conditions across tables
   OR (l.value > 100 AND r.priority = 1)                        -- Non-search conditions across tables
ORDER BY l.id, r.id, left_score DESC;
     left_content      |   right_content   | relationship_type | left_score | right_score 
-----------------------+-------------------+-------------------+------------+-------------
 smartphone technology | advanced features | primary           |  1.2039728 |   1.1374958
 game console          | gaming experience | primary           |          0 |           0
(2 rows)

-- =============================================================================
-- Test Case 2: Outer join with complex conditions
-- Outer joins often force conditions into joininfo
-- =============================================================================
SELECT 'Test 2: Outer join forcing joininfo' as test_name;
              test_name              
-------------------------------------
 Test 2: Outer join forcing joininfo
(1 row)

-- LEFT JOIN with complex WHERE conditions often triggers joininfo
SELECT 
    l.content as left_content,
    r.content as right_content,
    paradedb.score(l.id) as left_score,
    paradedb.score(r.id) as right_score
FROM left_table l
LEFT JOIN bridge_table b ON l.id = b.left_id
LEFT JOIN right_table r ON r.id = b.right_id
WHERE (l.content @@@ 'laptop' AND COALESCE(r.content @@@ 'performance', false))  -- Complex condition with COALESCE
ORDER BY l.id, r.id, left_score DESC;
  left_content   |  right_content   | left_score | right_score 
-----------------+------------------+------------+-------------
 laptop computer | high performance |  1.2039728 |            
(1 row)

-- =============================================================================
-- Test Case 3: Subquery join with correlated conditions
-- Subqueries often prevent pushdown to baserestrictinfo
-- =============================================================================
SELECT 'Test 3: Subquery join forcing joininfo' as test_name;
               test_name                
----------------------------------------
 Test 3: Subquery join forcing joininfo
(1 row)

-- Subquery structure that forces joininfo
SELECT 
    l.content as left_content,
    subq.right_content,
    paradedb.score(l.id) as left_score,
    subq.right_score
FROM left_table l
JOIN (
    SELECT r.id, r.content as right_content, paradedb.score(r.id) as right_score
    FROM right_table r
    WHERE r.priority <= 2
) subq ON l.value > 50
WHERE l.content @@@ 'electronics'  -- This might end up in joininfo due to subquery
ORDER BY l.id, subq.id, left_score DESC;
 left_content | right_content | left_score | right_score 
--------------+---------------+------------+-------------
(0 rows)

-- =============================================================================
-- Test Case 4: Multiple table join with aggregate conditions
-- Aggregate conditions often force joininfo
-- =============================================================================
SELECT 'Test 4: Aggregate join forcing joininfo' as test_name;
                test_name                
-----------------------------------------
 Test 4: Aggregate join forcing joininfo
(1 row)

-- Aggregate join that forces conditions into joininfo
SELECT 
    l.content as left_content,
    COUNT(r.id) as right_count,
    paradedb.score(l.id) as left_score
FROM left_table l
LEFT JOIN bridge_table b ON l.id = b.left_id
LEFT JOIN right_table r ON r.id = b.right_id
WHERE l.content @@@ 'smartphone'
GROUP BY l.id, l.content
HAVING COUNT(r.id) > 0  -- HAVING conditions often trigger joininfo
ORDER BY l.id, left_score DESC;
     left_content      | right_count | left_score 
-----------------------+-------------+------------
 smartphone technology |           2 |  1.2039728
(1 row)

-- =============================================================================
-- Test Case 5: Self-join with complex conditions
-- Self-joins often create joininfo conditions
-- =============================================================================
SELECT 'Test 5: Self-join forcing joininfo' as test_name;
             test_name              
------------------------------------
 Test 5: Self-join forcing joininfo
(1 row)

-- Self-join that should force joininfo
SELECT 
    l1.content as left1_content,
    l2.content as left2_content,
    paradedb.score(l1.id) as left1_score,
    paradedb.score(l2.id) as left2_score
FROM left_table l1
JOIN left_table l2 ON l1.category = l2.category AND l1.id != l2.id
WHERE (l1.content @@@ 'smartphone' AND l2.content @@@ 'laptop')  -- Search across self-joined tables
ORDER BY l1.id, l2.id, left1_score DESC;
     left1_content     |  left2_content  | left1_score | left2_score 
-----------------------+-----------------+-------------+-------------
 smartphone technology | laptop computer |   1.2039728 |   1.2039728
(1 row)

-- =============================================================================
-- Test Case 6: Anti-join (NOT EXISTS) with search conditions
-- Anti-joins often force conditions into joininfo
-- =============================================================================
SELECT 'Test 6: Anti-join forcing joininfo' as test_name;
             test_name              
------------------------------------
 Test 6: Anti-join forcing joininfo
(1 row)

-- Anti-join that forces joininfo
SELECT 
    l.content as left_content,
    paradedb.score(l.id) as left_score
FROM left_table l
WHERE l.content @@@ 'electronics'
  AND NOT EXISTS (
    SELECT 1 FROM bridge_table b 
    JOIN right_table r ON r.id = b.right_id 
    WHERE b.left_id = l.id AND r.priority = 1
  )
ORDER BY l.id, left_score DESC;
 left_content | left_score 
--------------+------------
(0 rows)

-- =============================================================================
-- Test Case 7: Complex boolean logic spanning tables
-- This should definitely trigger joininfo
-- =============================================================================
SELECT 'Test 7: Complex boolean spanning tables' as test_name;
                test_name                
-----------------------------------------
 Test 7: Complex boolean spanning tables
(1 row)

-- Complex boolean logic that spans multiple tables
SELECT 
    l.content as left_content,
    r.content as right_content,
    paradedb.score(l.id) as left_score,
    paradedb.score(r.id) as right_score
FROM left_table l
JOIN bridge_table b ON l.id = b.left_id
JOIN right_table r ON r.id = b.right_id
WHERE (
    (l.content @@@ 'smartphone' AND r.description @@@ 'capabilities')  -- Search across tables
    OR 
    (l.value > 100 AND r.priority = 1 AND b.strength > 5)              -- Complex condition spanning all tables
)
ORDER BY l.id, r.id, left_score DESC;
     left_content      |   right_content   | left_score | right_score 
-----------------------+-------------------+------------+-------------
 smartphone technology | advanced features |  1.2039728 |   1.2039728
 game console          | gaming experience |          0 |           0
(2 rows)

-- =============================================================================
-- SUMMARY: These tests should trigger our hybrid join logic
-- =============================================================================
SELECT 'Summary: Tests designed to force joininfo conditions' as summary;
                       summary                        
------------------------------------------------------
 Summary: Tests designed to force joininfo conditions
(1 row)

-- Cleanup
DROP TABLE IF EXISTS bridge_table;
DROP TABLE IF EXISTS right_table;
DROP TABLE IF EXISTS left_table; 
