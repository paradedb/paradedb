\i common/common_setup.sql
CREATE EXTENSION IF NOT EXISTS pg_search;
-- Disable parallel workers to avoid differences in plans
SET max_parallel_workers_per_gather = 0;
SET enable_indexscan to OFF;
SET paradedb.enable_mixed_fast_field_exec = true;
SET paradedb.enable_aggregate_custom_scan TO on;
CALL paradedb.create_bm25_test_table(
  schema_name => 'public',
  table_name => 'mock_items'
);
CREATE INDEX search_idx ON mock_items USING bm25 (id, description, rating, (category::pdb.literal), metadata) WITH (key_field='id');
CREATE TABLE allowed_categories (
    category TEXT PRIMARY KEY
);
INSERT INTO allowed_categories (category) VALUES
    ('Electronics'),
    ('Clothing');
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF, VERBOSE)
SELECT COUNT(*) FROM mock_items WHERE category @@@ paradedb.term_set(terms => ARRAY(SELECT paradedb.term('category', category) FROM allowed_categories LIMIT 5));
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Custom Scan (ParadeDB Aggregate Scan) on public.mock_items
   Output: pdb.agg_fn('COUNT(*)'::text)
   Index: search_idx
   Tantivy Query: {"postgres_expression":{"expr":{"expr_desc":"<expression>"}}}
     Applies to Aggregates: COUNT(*)
     Aggregate Definition: {"0":{"value_count":{"field":"ctid","missing":null}}}
   InitPlan 1
     ->  Limit
           Output: (paradedb.term('category'::paradedb.fieldname, allowed_categories.category))
           ->  Seq Scan on public.allowed_categories
                 Output: paradedb.term('category'::paradedb.fieldname, allowed_categories.category)
(11 rows)

SELECT COUNT(*) FROM mock_items WHERE category @@@ paradedb.term_set(terms => ARRAY(SELECT paradedb.term('category', category) FROM allowed_categories LIMIT 5));
 count 
-------
     5
(1 row)

EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF, VERBOSE)
SELECT
  COUNT(*) AS total,
  COUNT(*) FILTER (WHERE category @@@ paradedb.term_set(terms => ARRAY(SELECT paradedb.term('category', category) FROM allowed_categories LIMIT 2))),
  COUNT(*) FILTER (WHERE category @@@ paradedb.term_set(terms => ARRAY(SELECT paradedb.term('category', category) FROM allowed_categories LIMIT 2 OFFSET 2)))
FROM mock_items;
                                                                                                                                                                             QUERY PLAN                                                                                                                                                                              
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ParadeDB Aggregate Scan) on public.mock_items
   Output: pdb.agg_fn('COUNT(*)'::text), pdb.agg_fn('COUNT(*)'::text), pdb.agg_fn('COUNT(*)'::text)
   Index: search_idx
   Tantivy Query: "all"
     Applies to Aggregates: COUNT(*), COUNT(*), COUNT(*)
     Aggregate Definition: {"0":{"value_count":{"field":"ctid","missing":null}},"1":{"aggs":{"0":{"value_count":{"field":"ctid","missing":null}}},"filter":{"postgres_expression":{"expr":{"expr_desc":"<expression>"}}}},"2":{"aggs":{"0":{"value_count":{"field":"ctid","missing":null}}},"filter":{"postgres_expression":{"expr":{"expr_desc":"<expression>"}}}}}
   InitPlan 1
     ->  Limit
           Output: (paradedb.term('category'::paradedb.fieldname, allowed_categories.category))
           ->  Seq Scan on public.allowed_categories
                 Output: paradedb.term('category'::paradedb.fieldname, allowed_categories.category)
   InitPlan 2
     ->  Limit
           Output: (paradedb.term('category'::paradedb.fieldname, allowed_categories_1.category))
           ->  Seq Scan on public.allowed_categories allowed_categories_1
                 Output: paradedb.term('category'::paradedb.fieldname, allowed_categories_1.category)
(16 rows)

SELECT
  COUNT(*) AS total,
  COUNT(*) FILTER (WHERE category @@@ paradedb.term_set(terms => ARRAY(SELECT paradedb.term('category', category) FROM allowed_categories LIMIT 2))),
  COUNT(*) FILTER (WHERE category @@@ paradedb.term_set(terms => ARRAY(SELECT paradedb.term('category', category) FROM allowed_categories LIMIT 2 OFFSET 2)))
FROM mock_items;
 total | count | count 
-------+-------+-------
    41 |     5 |     0
(1 row)

-- Make sure the results are correct
SET paradedb.enable_aggregate_custom_scan TO off;
SELECT COUNT(*) FROM mock_items WHERE category @@@ paradedb.term_set(terms => ARRAY(SELECT paradedb.term('category', category) FROM allowed_categories LIMIT 5));
 count 
-------
     5
(1 row)

SELECT
  COUNT(*) AS total,
  COUNT(*) FILTER (WHERE category @@@ paradedb.term_set(terms => ARRAY(SELECT paradedb.term('category', category) FROM allowed_categories LIMIT 2))),
  COUNT(*) FILTER (WHERE category @@@ paradedb.term_set(terms => ARRAY(SELECT paradedb.term('category', category) FROM allowed_categories LIMIT 2 OFFSET 2)))
FROM mock_items;
 total | count | count 
-------+-------+-------
    41 |     5 |     0
(1 row)

DROP TABLE allowed_categories;
DROP TABLE mock_items;
