-- Test for the JoinScan Custom Scan planning with parallelism
-- This test verifies that the join custom scan is proposed and works correctly
-- when parallel workers are enabled and multiple segments exist.
-- Disable mutable segments to ensure multiple segments are created
SET paradedb.global_mutable_segment_rows = 0;
-- Enable parallel workers and force parallel plans even for small data
SET max_parallel_workers_per_gather = 2;
SET min_parallel_table_scan_size = 0;
SET min_parallel_index_scan_size = 0;
SET parallel_setup_cost = 0;
SET parallel_tuple_cost = 0;
-- Load the pg_search extension
CREATE EXTENSION IF NOT EXISTS pg_search;
-- =============================================================================
-- SETUP
-- =============================================================================
DROP TABLE IF EXISTS products CASCADE;
DROP TABLE IF EXISTS suppliers CASCADE;
CREATE TABLE suppliers (
    id INTEGER PRIMARY KEY,
    name TEXT
);
CREATE TABLE products (
    id INTEGER PRIMARY KEY,
    name TEXT,
    supplier_id INTEGER
);
-- Create BM25 indexes
-- We create them BEFORE inserting data so that each insert creates a new segment
-- due to paradedb.global_mutable_segment_rows = 0
CREATE INDEX suppliers_bm25_idx ON suppliers USING bm25 (id, name)
WITH (key_field = 'id');
CREATE INDEX products_bm25_idx ON products USING bm25 (id, name, supplier_id)
WITH (key_field = 'id', numeric_fields = '{"supplier_id": {"fast": true}}');
-- Insert test data in separate batches to create multiple segments
INSERT INTO suppliers (id, name) VALUES (1, 'TechCorp');
INSERT INTO suppliers (id, name) VALUES (2, 'GlobalSupply');
INSERT INTO products (id, name, supplier_id) VALUES (1, 'Wireless Mouse', 1);
INSERT INTO products (id, name, supplier_id) VALUES (2, 'Wireless Keyboard', 1);
INSERT INTO products (id, name, supplier_id) VALUES (3, 'USB Cable', 2);
INSERT INTO products (id, name, supplier_id) VALUES (4, 'Monitor Stand', 2);
VACUUM FREEZE products;
VACUUM FREEZE suppliers;
-- =============================================================================
-- TEST 1: Parallel JoinScan with predicate on driving side
-- =============================================================================
SET paradedb.enable_join_custom_scan = on;
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT p.id, p.name, s.name AS supplier_name
FROM products p
JOIN suppliers s ON p.supplier_id = s.id
WHERE p.name @@@ 'Wireless'
ORDER BY p.id
LIMIT 10;
                                                                                                   QUERY PLAN                                                                                                   
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: p.id, p.name, s.name
   ->  Custom Scan (ParadeDB Join Scan)
         Output: p.id, p.name, s.name
         Join Type: Inner
         Relation 0: suppliers (s)
         Relation 1: products (p)
         Join Cond: p.supplier_id = s.id
         Limit: 10
         Order By: p.id asc
         Planned Workers: 2
         DataFusion Physical Plan: 
           : ProjectionExec: expr=[id@2 as col_1, NULL as col_2, NULL as col_3, ctid_2@0 as ctid_2, ctid_1@1 as ctid_1]
           :   SortPreservingMergeExec: [id@2 ASC NULLS LAST], fetch=10
           :     DsmExchangeExec(stream_id=2, producer_partitioning=UnknownPartitioning(3), sanitized=true)
           :       SortExec: TopK(fetch=10), expr=[id@2 ASC NULLS LAST], preserve_partitioning=[true]
           :         HashJoinExec: mode=Partitioned, join_type=Inner, on=[(id@1, supplier_id@1)], projection=[ctid_2@0, ctid_1@2, id@4]
           :           DsmExchangeExec(stream_id=0, producer_partitioning=Hash([Column { name: "id", index: 1 }], 3), sanitized=true)
           :             ProjectionExec: expr=[ctid@0 as ctid_2, id@1 as id]
           :               CooperativeExec
           :                 PgSearchScan: segments=1, dynamic_filters=1, query="all"
           :           DsmExchangeExec(stream_id=1, producer_partitioning=Hash([Column { name: "supplier_id", index: 1 }], 3), sanitized=true)
           :             ProjectionExec: expr=[ctid@0 as ctid_1, supplier_id@1 as supplier_id, id@2 as id]
           :               CooperativeExec
           :                 PgSearchScan: segments=1, dynamic_filters=2, query={"with_index":{"query":{"parse_with_field":{"field":"name","query_string":"Wireless","lenient":null,"conjunction_mode":null}}}}
(25 rows)

SELECT p.id, p.name, s.name AS supplier_name
FROM products p
JOIN suppliers s ON p.supplier_id = s.id
WHERE p.name @@@ 'Wireless'
ORDER BY p.id
LIMIT 10;
 id |       name        | supplier_name 
----+-------------------+---------------
  1 | Wireless Mouse    | TechCorp
  2 | Wireless Keyboard | TechCorp
(2 rows)

-- =============================================================================
-- TEST 2: Parallel JoinScan with predicate on build side
-- =============================================================================
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT p.id, p.name, s.name AS supplier_name
FROM products p
JOIN suppliers s ON p.supplier_id = s.id
WHERE s.name @@@ 'TechCorp'
ORDER BY p.id
LIMIT 10;
                                                                                                   QUERY PLAN                                                                                                   
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: p.id, p.name, s.name
   ->  Custom Scan (ParadeDB Join Scan)
         Output: p.id, p.name, s.name
         Join Type: Inner
         Relation 0: suppliers (s)
         Relation 1: products (p)
         Join Cond: p.supplier_id = s.id
         Limit: 10
         Order By: p.id asc
         Planned Workers: 2
         DataFusion Physical Plan: 
           : ProjectionExec: expr=[id@2 as col_1, NULL as col_2, NULL as col_3, ctid_2@0 as ctid_2, ctid_1@1 as ctid_1]
           :   SortPreservingMergeExec: [id@2 ASC NULLS LAST], fetch=10
           :     DsmExchangeExec(stream_id=2, producer_partitioning=UnknownPartitioning(3), sanitized=true)
           :       SortExec: TopK(fetch=10), expr=[id@2 ASC NULLS LAST], preserve_partitioning=[true]
           :         HashJoinExec: mode=Partitioned, join_type=Inner, on=[(id@1, supplier_id@1)], projection=[ctid_2@0, ctid_1@2, id@4]
           :           DsmExchangeExec(stream_id=0, producer_partitioning=Hash([Column { name: "id", index: 1 }], 3), sanitized=true)
           :             ProjectionExec: expr=[ctid@0 as ctid_2, id@1 as id]
           :               CooperativeExec
           :                 PgSearchScan: segments=1, dynamic_filters=1, query={"with_index":{"query":{"parse_with_field":{"field":"name","query_string":"TechCorp","lenient":null,"conjunction_mode":null}}}}
           :           DsmExchangeExec(stream_id=1, producer_partitioning=Hash([Column { name: "supplier_id", index: 1 }], 3), sanitized=true)
           :             ProjectionExec: expr=[ctid@0 as ctid_1, supplier_id@1 as supplier_id, id@2 as id]
           :               CooperativeExec
           :                 PgSearchScan: segments=1, dynamic_filters=2, query="all"
(25 rows)

SELECT p.id, p.name, s.name AS supplier_name
FROM products p
JOIN suppliers s ON p.supplier_id = s.id
WHERE s.name @@@ 'TechCorp'
ORDER BY p.id
LIMIT 10;
 id |       name        | supplier_name 
----+-------------------+---------------
  1 | Wireless Mouse    | TechCorp
  2 | Wireless Keyboard | TechCorp
(2 rows)

-- =============================================================================
-- TEST 3: Parallel JoinScan with predicates on both sides
-- =============================================================================
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT p.id, p.name, s.name AS supplier_name
FROM products p
JOIN suppliers s ON p.supplier_id = s.id
WHERE p.name @@@ 'Wireless' AND s.name @@@ 'TechCorp'
ORDER BY p.id
LIMIT 10;
                                                                                                   QUERY PLAN                                                                                                   
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: p.id, p.name, s.name
   ->  Custom Scan (ParadeDB Join Scan)
         Output: p.id, p.name, s.name
         Join Type: Inner
         Relation 0: suppliers (s)
         Relation 1: products (p)
         Join Cond: p.supplier_id = s.id
         Limit: 10
         Order By: p.id asc
         Planned Workers: 2
         DataFusion Physical Plan: 
           : ProjectionExec: expr=[id@2 as col_1, NULL as col_2, NULL as col_3, ctid_2@0 as ctid_2, ctid_1@1 as ctid_1]
           :   SortPreservingMergeExec: [id@2 ASC NULLS LAST], fetch=10
           :     DsmExchangeExec(stream_id=2, producer_partitioning=UnknownPartitioning(3), sanitized=true)
           :       SortExec: TopK(fetch=10), expr=[id@2 ASC NULLS LAST], preserve_partitioning=[true]
           :         HashJoinExec: mode=Partitioned, join_type=Inner, on=[(id@1, supplier_id@1)], projection=[ctid_2@0, ctid_1@2, id@4]
           :           DsmExchangeExec(stream_id=0, producer_partitioning=Hash([Column { name: "id", index: 1 }], 3), sanitized=true)
           :             ProjectionExec: expr=[ctid@0 as ctid_2, id@1 as id]
           :               CooperativeExec
           :                 PgSearchScan: segments=1, dynamic_filters=1, query={"with_index":{"query":{"parse_with_field":{"field":"name","query_string":"TechCorp","lenient":null,"conjunction_mode":null}}}}
           :           DsmExchangeExec(stream_id=1, producer_partitioning=Hash([Column { name: "supplier_id", index: 1 }], 3), sanitized=true)
           :             ProjectionExec: expr=[ctid@0 as ctid_1, supplier_id@1 as supplier_id, id@2 as id]
           :               CooperativeExec
           :                 PgSearchScan: segments=1, dynamic_filters=2, query={"with_index":{"query":{"parse_with_field":{"field":"name","query_string":"Wireless","lenient":null,"conjunction_mode":null}}}}
(25 rows)

SELECT p.id, p.name, s.name AS supplier_name
FROM products p
JOIN suppliers s ON p.supplier_id = s.id
WHERE p.name @@@ 'Wireless' AND s.name @@@ 'TechCorp'
ORDER BY p.id
LIMIT 10;
 id |       name        | supplier_name 
----+-------------------+---------------
  1 | Wireless Mouse    | TechCorp
  2 | Wireless Keyboard | TechCorp
(2 rows)

-- =============================================================================
-- TEST 4: Parallel JoinScan with ORDER BY score
-- =============================================================================
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT p.id, p.name, s.name AS supplier_name, paradedb.score(p.id)
FROM products p
JOIN suppliers s ON p.supplier_id = s.id
WHERE p.name @@@ 'Wireless'
ORDER BY paradedb.score(p.id) DESC, p.id
LIMIT 10;
                                                                                                      QUERY PLAN                                                                                                      
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: p.id, p.name, s.name, (paradedb.score(p.id))
   ->  Result
         Output: p.id, p.name, s.name, (paradedb.score(p.id))
         ->  Custom Scan (ParadeDB Join Scan)
               Output: p.id, p.name, (paradedb.score(p.id)), s.name
               Join Type: Inner
               Relation 0: suppliers (s)
               Relation 1: products (p)
               Join Cond: p.supplier_id = s.id
               Limit: 10
               Order By: pdb.score() desc, p.id asc
               Planned Workers: 2
               DataFusion Physical Plan: 
                 : ProjectionExec: expr=[id@3 as col_1, NULL as col_2, score@1 as col_3, NULL as col_4, ctid_2@0 as ctid_2, ctid_1@2 as ctid_1]
                 :   SortPreservingMergeExec: [score@1 DESC, id@3 ASC NULLS LAST], fetch=10
                 :     DsmExchangeExec(stream_id=2, producer_partitioning=UnknownPartitioning(3), sanitized=true)
                 :       SortExec: TopK(fetch=10), expr=[score@1 DESC, id@3 ASC NULLS LAST], preserve_partitioning=[true]
                 :         HashJoinExec: mode=Partitioned, join_type=Inner, on=[(id@1, supplier_id@2)], projection=[ctid_2@0, score@2, ctid_1@3, id@5]
                 :           DsmExchangeExec(stream_id=0, producer_partitioning=Hash([Column { name: "id", index: 1 }], 3), sanitized=true)
                 :             ProjectionExec: expr=[ctid@0 as ctid_2, id@1 as id]
                 :               CooperativeExec
                 :                 PgSearchScan: segments=1, query="all"
                 :           DsmExchangeExec(stream_id=1, producer_partitioning=Hash([Column { name: "supplier_id", index: 2 }], 3), sanitized=true)
                 :             ProjectionExec: expr=[pdb.score()@0 as score, ctid@1 as ctid_1, supplier_id@2 as supplier_id, id@3 as id]
                 :               CooperativeExec
                 :                 PgSearchScan: segments=1, dynamic_filters=1, query={"with_index":{"query":{"parse_with_field":{"field":"name","query_string":"Wireless","lenient":null,"conjunction_mode":null}}}}
(27 rows)

SELECT p.id, p.name, s.name AS supplier_name, paradedb.score(p.id)
FROM products p
JOIN suppliers s ON p.supplier_id = s.id
WHERE p.name @@@ 'Wireless'
ORDER BY paradedb.score(p.id) DESC, p.id
LIMIT 10;
 id |       name        | supplier_name |   score   
----+-------------------+---------------+-----------
  1 | Wireless Mouse    | TechCorp      | 0.6931472
  2 | Wireless Keyboard | TechCorp      | 0.6931472
(2 rows)

-- Cleanup
DROP TABLE products CASCADE;
DROP TABLE suppliers CASCADE;
RESET paradedb.global_mutable_segment_rows;
RESET max_parallel_workers_per_gather;
RESET min_parallel_table_scan_size;
RESET min_parallel_index_scan_size;
RESET parallel_setup_cost;
RESET parallel_tuple_cost;
