-- Test UNION operations and window functions with mixed fast fields
-- This test verifies that mixed fast fields work correctly with UNION operations
-- and when used in window functions
-- Disable parallel workers to avoid differences in plans
SET max_parallel_workers_per_gather = 0;
-- Create test tables
DROP TABLE IF EXISTS union_test_a;
DROP TABLE IF EXISTS union_test_b;
CREATE TABLE union_test_a (
    id SERIAL PRIMARY KEY,
    title TEXT,
    author TEXT,
    rating NUMERIC,
    year INTEGER,
    price FLOAT,
    is_published BOOLEAN
);
CREATE TABLE union_test_b (
    id SERIAL PRIMARY KEY,
    title TEXT,
    author TEXT,
    rating NUMERIC,
    year INTEGER,
    price FLOAT,
    is_published BOOLEAN
);
-- Insert test data with deterministic values
INSERT INTO union_test_a (title, author, rating, year, price, is_published)
SELECT
    'Book A' || i,
    'Author ' || (1 + (i % 10)),
    (3 + (i % 3))::numeric,  -- Ratings from 3 to 5
    2000 + (i % 22),
    (10 + (i * 5))::float,   -- Deterministic prices
    i % 3 != 0               -- Deterministic boolean pattern
FROM generate_series(1, 50) i;
INSERT INTO union_test_b (title, author, rating, year, price, is_published)
SELECT
    'Book B' || i,
    'Author ' || (1 + (i % 15)),
    (1 + (i % 5))::numeric,  -- Ratings from 1 to 5
    1980 + (i % 40),
    (15 + (i * 3))::float,   -- Deterministic prices
    i % 4 != 0               -- Deterministic boolean pattern
FROM generate_series(1, 50) i;
-- Create indices with mixed fast fields
DROP INDEX IF EXISTS union_test_a_idx;
DROP INDEX IF EXISTS union_test_b_idx;
CREATE INDEX union_test_a_idx ON union_test_a
USING bm25 (id, title, author, rating, year, price, is_published)
WITH (
    key_field = 'id',
    text_fields = '{"title": {"tokenizer": {"type": "default"}, "fast": true}, "author": {"tokenizer": {"type": "default"}, "fast": true}}',
    numeric_fields = '{"rating": {"fast": true}, "year": {"fast": true}, "price": {"fast": true}}',
    boolean_fields = '{"is_published": {"fast": true}}'
);
CREATE INDEX union_test_b_idx ON union_test_b
USING bm25 (id, title, author, rating, year, price, is_published)
WITH (
    key_field = 'id',
    text_fields = '{"title": {"tokenizer": {"type": "default"}, "fast": true}, "author": {"tokenizer": {"type": "default"}, "fast": true}}',
    numeric_fields = '{"rating": {"fast": true}, "year": {"fast": true}, "price": {"fast": true}}',
    boolean_fields = '{"is_published": {"fast": true}}'
);
-- Test 1: Basic UNION with mixed field types
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT title, author, rating, price
FROM union_test_a
WHERE title @@@ 'Book A' AND rating > 4
UNION
SELECT title, author, rating, price
FROM union_test_b
WHERE title @@@ 'Book B' AND rating > 3
ORDER BY rating DESC, title;
                                                                                                     QUERY PLAN                                                                                                     
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: union_test_a.rating DESC, union_test_a.title
   ->  HashAggregate
         Group Key: union_test_a.title, union_test_a.author, union_test_a.rating, union_test_a.price
         ->  Append
               ->  Index Scan using union_test_a_idx on union_test_a
                     Index Cond: (id @@@ '{"with_index":{"oid":1848406,"query":{"parse_with_field":{"field":"title","query_string":"Book A","lenient":null,"conjunction_mode":null}}}}'::paradedb.searchqueryinput)
                     Filter: (rating > '4'::numeric)
               ->  Index Scan using union_test_b_idx on union_test_b
                     Index Cond: (id @@@ '{"with_index":{"oid":1848407,"query":{"parse_with_field":{"field":"title","query_string":"Book B","lenient":null,"conjunction_mode":null}}}}'::paradedb.searchqueryinput)
                     Filter: (rating > '3'::numeric)
(11 rows)

-- Test 2: UNION ALL with numeric fields for filtering
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT title, price, year
FROM union_test_a
WHERE price < 30 AND year > 2010
UNION ALL
SELECT title, price, year
FROM union_test_b
WHERE price < 45 AND year > 2000
ORDER BY price;
                                 QUERY PLAN                                 
----------------------------------------------------------------------------
 Sort
   Sort Key: union_test_a.price
   ->  Append
         ->  Seq Scan on union_test_a
               Filter: ((price < '30'::double precision) AND (year > 2010))
         ->  Seq Scan on union_test_b
               Filter: ((price < '45'::double precision) AND (year > 2000))
(7 rows)

-- Test 3: Window function - ROW_NUMBER() with mixed fields
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT title, author, price, rating,
       ROW_NUMBER() OVER (PARTITION BY author ORDER BY rating DESC) as author_rank
FROM union_test_a
WHERE title @@@ 'Book A'
ORDER BY author, author_rank;
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Incremental Sort
   Sort Key: author, (row_number() OVER (?))
   Presorted Key: author
   ->  WindowAgg
         ->  Sort
               Sort Key: author, rating DESC
               ->  Custom Scan (ParadeDB Scan) on union_test_a
                     Table: union_test_a
                     Index: union_test_a_idx
                     Segment Count: 1
                     Exec Method: MixedFastFieldExecState
                     Fast Fields: title, author, price, rating
                     String Fast Fields: title, author
                     Numeric Fast Fields: price, rating
                     Scores: false
                     Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"title","query_string":"Book A","lenient":null,"conjunction_mode":null}}}}
(16 rows)

-- Test 4: Window function - Running average price by author
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT title, author, price,
       AVG(price) OVER (PARTITION BY author ORDER BY price) as running_avg_price
FROM union_test_a
WHERE author @@@ 'Author'
ORDER BY author, price;
                                                                          QUERY PLAN                                                                          
--------------------------------------------------------------------------------------------------------------------------------------------------------------
 WindowAgg
   ->  Sort
         Sort Key: author, price
         ->  Custom Scan (ParadeDB Scan) on union_test_a
               Table: union_test_a
               Index: union_test_a_idx
               Segment Count: 1
               Exec Method: MixedFastFieldExecState
               Fast Fields: title, author, price
               String Fast Fields: title, author
               Numeric Fast Fields: price
               Scores: false
               Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"author","query_string":"Author","lenient":null,"conjunction_mode":null}}}}
(13 rows)

-- Test 5: Window function with UNION and mixed filters
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
WITH combined_books AS (
    SELECT title, author, rating, 'A' as source
    FROM union_test_a
    WHERE rating > 3.5
    UNION
    SELECT title, author, rating, 'B' as source
    FROM union_test_b
    WHERE rating > 2.5
)
SELECT title, author, rating, source,
       RANK() OVER (PARTITION BY author ORDER BY rating DESC) as author_rank
FROM combined_books
ORDER BY author, author_rank;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Incremental Sort
   Sort Key: combined_books.author, (rank() OVER (?))
   Presorted Key: combined_books.author
   ->  WindowAgg
         ->  Sort
               Sort Key: combined_books.author, combined_books.rating DESC
               ->  Subquery Scan on combined_books
                     ->  HashAggregate
                           Group Key: union_test_a.title, union_test_a.author, union_test_a.rating, ('A'::text)
                           ->  Append
                                 ->  Seq Scan on union_test_a
                                       Filter: (rating > 3.5)
                                 ->  Seq Scan on union_test_b
                                       Filter: (rating > 2.5)
(14 rows)

-- Test 6: UNION with boolean and text fields
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT title, author, is_published
FROM union_test_a
WHERE is_published = true AND author @@@ 'Author 1'
UNION
SELECT title, author, is_published
FROM union_test_b
WHERE is_published = true AND author @@@ 'Author 1'
ORDER BY author, title;
                                                                                                                              QUERY PLAN                                                                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: union_test_a.author, union_test_a.title
   ->  Unique
         ->  Merge Append
               Sort Key: union_test_a.title, union_test_a.author, union_test_a.is_published
               ->  Sort
                     Sort Key: union_test_a.title, union_test_a.author, union_test_a.is_published
                     ->  Custom Scan (ParadeDB Scan) on union_test_a
                           Table: union_test_a
                           Index: union_test_a_idx
                           Segment Count: 1
                           Exec Method: MixedFastFieldExecState
                           Fast Fields: title, author, is_published
                           String Fast Fields: title, author
                           Numeric Fast Fields: is_published
                           Scores: false
                           Tantivy Query: {"boolean":{"must":[{"term":{"field":"is_published","value":true,"is_datetime":false}},{"with_index":{"query":{"parse_with_field":{"field":"author","query_string":"Author 1","lenient":null,"conjunction_mode":null}}}}]}}
               ->  Sort
                     Sort Key: union_test_b.title, union_test_b.author, union_test_b.is_published
                     ->  Custom Scan (ParadeDB Scan) on union_test_b
                           Table: union_test_b
                           Index: union_test_b_idx
                           Segment Count: 1
                           Exec Method: MixedFastFieldExecState
                           Fast Fields: title, author, is_published
                           String Fast Fields: title, author
                           Numeric Fast Fields: is_published
                           Scores: false
                           Tantivy Query: {"boolean":{"must":[{"term":{"field":"is_published","value":true,"is_datetime":false}},{"with_index":{"query":{"parse_with_field":{"field":"author","query_string":"Author 1","lenient":null,"conjunction_mode":null}}}}]}}
(29 rows)

-- Test 7: Window functions with multiple partitions and mixed fields
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT author, 
       AVG(rating) as avg_rating,
       AVG(price) as avg_price,
       COUNT(*) as book_count,
       RANK() OVER (ORDER BY AVG(rating) DESC) as rating_rank,
       RANK() OVER (ORDER BY AVG(price)) as price_rank
FROM union_test_a
WHERE author @@@ 'Author'
GROUP BY author
ORDER BY avg_rating DESC;
                                                                                   QUERY PLAN                                                                                   
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 WindowAgg
   ->  Sort
         Sort Key: (avg(rating)) DESC
         ->  WindowAgg
               ->  Sort
                     Sort Key: (avg(price))
                     ->  HashAggregate
                           Group Key: author
                           ->  Custom Scan (ParadeDB Scan) on union_test_a
                                 Table: union_test_a
                                 Index: union_test_a_idx
                                 Segment Count: 1
                                 Exec Method: StringFastFieldExecState
                                 Fast Fields: author
                                 String Agg Field: author
                                 Scores: false
                                    Sort Field: author
                                    Sort Direction: asc
                                 Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"author","query_string":"Author","lenient":null,"conjunction_mode":null}}}}
(19 rows)

-- Test 8: UNION with INTERSECT and different field types
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
(SELECT author FROM union_test_a WHERE rating > 4.5)
INTERSECT
(SELECT author FROM union_test_b WHERE rating > 4.0);
                 QUERY PLAN                 
--------------------------------------------
 HashSetOp Intersect
   ->  Append
         ->  Subquery Scan on "*SELECT* 1"
               ->  Seq Scan on union_test_a
                     Filter: (rating > 4.5)
         ->  Subquery Scan on "*SELECT* 2"
               ->  Seq Scan on union_test_b
                     Filter: (rating > 4.0)
(8 rows)

-- Verify actual results of UNION (not just execution method)
SELECT title, author, rating, price
FROM union_test_a
WHERE title @@@ 'Book A1' AND rating > 4
UNION
SELECT title, author, rating, price
FROM union_test_b
WHERE title @@@ 'Book B1' AND rating > 3
ORDER BY rating DESC, title
LIMIT 10;
  title   |  author   | rating | price 
----------+-----------+--------+-------
 Book A11 | Author 2  |      5 |    65
 Book A14 | Author 5  |      5 |    80
 Book A17 | Author 8  |      5 |    95
 Book A2  | Author 3  |      5 |    20
 Book A20 | Author 1  |      5 |   110
 Book A23 | Author 4  |      5 |   125
 Book A26 | Author 7  |      5 |   140
 Book A29 | Author 10 |      5 |   155
 Book A32 | Author 3  |      5 |   170
 Book A35 | Author 6  |      5 |   185
(10 rows)

-- Verify window function results
SELECT title, author, price, rating,
       ROW_NUMBER() OVER (PARTITION BY author ORDER BY rating DESC) as author_rank
FROM union_test_a
WHERE author = 'Author 1'
ORDER BY author_rank
LIMIT 5;
  title   |  author  | price | rating | author_rank 
----------+----------+-------+--------+-------------
 Book A20 | Author 1 |   110 |      5 |           1
 Book A50 | Author 1 |   260 |      5 |           2
 Book A10 | Author 1 |    60 |      4 |           3
 Book A40 | Author 1 |   210 |      4 |           4
 Book A30 | Author 1 |   160 |      3 |           5
(5 rows)

-- Clean up
DROP INDEX IF EXISTS union_test_a_idx;
DROP INDEX IF EXISTS union_test_b_idx;
DROP TABLE IF EXISTS union_test_a;
DROP TABLE IF EXISTS union_test_b; 
-- Reset parallel workers setting to default
RESET max_parallel_workers_per_gather;
