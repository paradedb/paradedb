-- Test type conversion edge cases with mixed fast fields
-- This test verifies that mixed fast fields handle various type conversions correctly
-- Create test table with various field types for conversion testing
DROP TABLE IF EXISTS type_conversion_test;
CREATE TABLE type_conversion_test (
    id SERIAL PRIMARY KEY,
    -- Text fields
    text_field TEXT,
    varchar_field VARCHAR(100),
    char_field CHAR(10),
    -- Numeric fields
    int_field INTEGER,
    smallint_field SMALLINT,
    bigint_field BIGINT,
    float_field FLOAT,
    numeric_field NUMERIC(10,2),
    decimal_field DECIMAL(10,2),
    real_field REAL,
    -- Boolean fields
    bool_field BOOLEAN,
    -- Date/Time fields
    date_field DATE,
    time_field TIME,
    timestamp_field TIMESTAMP,
    -- Special fields
    uuid_field UUID,
    json_field JSONB
);
-- Insert test data with edge cases for conversion
INSERT INTO type_conversion_test (
    text_field, varchar_field, char_field,
    int_field, smallint_field, bigint_field, float_field, numeric_field, decimal_field, real_field,
    bool_field, date_field, time_field, timestamp_field,
    uuid_field, json_field
) VALUES
    -- Case 1: Standard values
    (
        'Regular text', 'Regular varchar', 'Char     ',
        100, 10, 1000000, 3.14159, 123.45, 678.90, 2.71828,
        true, '2023-01-01', '12:30:00', '2023-01-01 12:30:00',
        '123e4567-e89b-12d3-a456-426614174000', '{"key": "value"}'
    ),
    -- Case 2: Numeric edge cases
    (
        '123', '456', '789',
        2147483647, 32767, 9223372036854775807, 1.7976931348623157e+308, 9999999.99, 9999999.99, 3.40282e+38,
        false, '2023-01-02', '00:00:01', '2023-01-02 00:00:01',
        '00000000-0000-0000-0000-000000000000', '{"number": 12345}'
    ),
    -- Case 3: Empty/NULL edge cases
    (
        '', '', '',
        0, 0, 0, 0.0, 0.00, 0.00, 0.0,
        NULL, '1970-01-01', '00:00:00', '1970-01-01 00:00:00',
        '00000000-0000-0000-0000-000000000000', '{}'
    ),
    -- Case 4: Special characters
    (
        'Text with special chars: !@#$%^&*()', 'Varchar with "quotes" and \'apostrophes\'', '~`[]{}\\|',
invalid command \'',
        -2147483648, -32768, -9223372036854775808, -1.7976931348623157e+308, -9999999.99, -9999999.99, -3.40282e+38,
        true, '9999-12-31', '23:59:59', '9999-12-31 23:59:59',
        'ffffffff-ffff-ffff-ffff-ffffffffffff', '{"array": [1, 2, 3]}'
    ),
    -- Case 5: Numeric strings
    (
        '12345.67890', '98765.43210', '1234567890',
        12345, 1234, 12345678901234, 12345.67890, 12345.67, 98765.43, 12345.67,
        false, '2023-05-15', '15:45:30', '2023-05-15 15:45:30',
        'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', '{"numeric": 12345.67890}'
    );
ERROR:  syntax error at or near "apostrophes" at character 1221
-- Create search index with mixed fast fields
DROP INDEX IF EXISTS type_conv_idx;
CREATE INDEX type_conv_idx ON type_conversion_test
USING columnstore (
    text_field, varchar_field, char_field,
    int_field, bigint_field, float_field, numeric_field,
    bool_field, date_field
)
WITH (type='hnsw');
ERROR:  access method "columnstore" does not exist
-- Enable execution method tracing
SET pg_search.explain_analyze_verbose TO TRUE;
-- Test 1: Basic text to text conversions
EXPLAIN ANALYZE
SELECT text_field, varchar_field, char_field
FROM type_conversion_test
WHERE text_field LIKE '%text%' OR varchar_field LIKE '%varchar%';
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Seq Scan on type_conversion_test  (cost=0.00..12.70 rows=1 width=294) (actual time=0.004..0.004 rows=0 loops=1)
   Filter: ((text_field ~~ '%text%'::text) OR ((varchar_field)::text ~~ '%varchar%'::text))
 Planning Time: 0.752 ms
 Execution Time: 0.046 ms
(4 rows)

-- Test 2: Converting numeric string to number
EXPLAIN ANALYZE
SELECT text_field::numeric as converted_num, numeric_field
FROM type_conversion_test
WHERE text_field ~ '^[0-9.]+$';
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Seq Scan on type_conversion_test  (cost=0.00..12.34 rows=18 width=48) (actual time=0.004..0.004 rows=0 loops=1)
   Filter: (text_field ~ '^[0-9.]+$'::text)
 Planning Time: 0.175 ms
 Execution Time: 0.014 ms
(4 rows)

-- Test 3: Numeric range filtering with casts
EXPLAIN ANALYZE
SELECT int_field, bigint_field, float_field
FROM type_conversion_test
WHERE int_field::float > 100 AND float_field::int < 12346;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Seq Scan on type_conversion_test  (cost=0.00..13.60 rows=20 width=20) (actual time=0.004..0.004 rows=0 loops=1)
   Filter: (((int_field)::double precision > '100'::double precision) AND ((float_field)::integer < 12346))
 Planning Time: 0.079 ms
 Execution Time: 0.015 ms
(4 rows)

-- Test 4: String concatenation with different types
EXPLAIN ANALYZE
SELECT text_field || ' - ' || int_field::text as text_with_num
FROM type_conversion_test
WHERE bool_field = true;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Seq Scan on type_conversion_test  (cost=0.00..12.70 rows=90 width=32) (actual time=0.004..0.004 rows=0 loops=1)
   Filter: bool_field
 Planning Time: 0.092 ms
 Execution Time: 0.020 ms
(4 rows)

-- Test 5: Mixed type expressions in filtering
EXPLAIN ANALYZE
SELECT text_field, int_field, float_field
FROM type_conversion_test
WHERE (int_field::text = '100' OR text_field = '123') 
  AND float_field BETWEEN 2 AND 10000;
                                                                               QUERY PLAN                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Seq Scan on type_conversion_test  (cost=0.00..14.50 rows=1 width=44) (actual time=0.004..0.004 rows=0 loops=1)
   Filter: ((float_field >= '2'::double precision) AND (float_field <= '10000'::double precision) AND (((int_field)::text = '100'::text) OR (text_field = '123'::text)))
 Planning Time: 0.065 ms
 Execution Time: 0.016 ms
(4 rows)

-- Test 6: Date conversions
EXPLAIN ANALYZE
SELECT date_field, timestamp_field
FROM type_conversion_test
WHERE date_field = timestamp_field::date;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Seq Scan on type_conversion_test  (cost=0.00..12.70 rows=1 width=12) (actual time=0.004..0.004 rows=0 loops=1)
   Filter: (date_field = (timestamp_field)::date)
 Planning Time: 0.164 ms
 Execution Time: 0.015 ms
(4 rows)

-- Test 7: CASE expression with type conversion
EXPLAIN ANALYZE
SELECT 
    id,
    CASE 
        WHEN text_field ~ '^[0-9]+$' THEN text_field::integer * 2
        ELSE int_field
    END as converted_value
FROM type_conversion_test;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Seq Scan on type_conversion_test  (cost=0.00..13.60 rows=180 width=8) (actual time=0.003..0.003 rows=0 loops=1)
 Planning Time: 0.061 ms
 Execution Time: 0.016 ms
(3 rows)

-- Test 8: JSON extraction with type conversion
EXPLAIN ANALYZE
SELECT 
    id,
    json_field,
    (json_field->>'number')::numeric AS extracted_number
FROM type_conversion_test
WHERE json_field ? 'number';
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Seq Scan on type_conversion_test  (cost=0.00..12.27 rows=2 width=68) (actual time=0.004..0.004 rows=0 loops=1)
   Filter: (json_field ? 'number'::text)
 Planning Time: 0.047 ms
 Execution Time: 0.018 ms
(4 rows)

-- Test 9: Complex mixed type filtering
EXPLAIN ANALYZE
SELECT text_field, int_field, bool_field
FROM type_conversion_test
WHERE 
    CASE 
        WHEN bool_field THEN int_field > 50
        ELSE text_field LIKE '%text%'
    END;
                                                   QUERY PLAN                                                    
-----------------------------------------------------------------------------------------------------------------
 Seq Scan on type_conversion_test  (cost=0.00..12.70 rows=90 width=37) (actual time=0.004..0.004 rows=0 loops=1)
   Filter: CASE WHEN bool_field THEN (int_field > 50) ELSE (text_field ~~ '%text%'::text) END
 Planning Time: 0.072 ms
 Execution Time: 0.016 ms
(4 rows)

-- Verify actual conversion results
SELECT 
    id,
    text_field,
    text_field::numeric as text_to_num,
    int_field,
    int_field::text as int_to_text,
    bool_field,
    CASE WHEN bool_field THEN 'Yes' ELSE 'No' END as bool_to_text
FROM type_conversion_test
WHERE text_field ~ '^[0-9.]+$' OR int_field > 1000;
 id | text_field | text_to_num | int_field | int_to_text | bool_field | bool_to_text 
----+------------+-------------+-----------+-------------+------------+--------------
(0 rows)

-- Test character set conversion issues
SELECT 
    id,
    text_field,
    varchar_field,
    char_field,
    TRIM(char_field) as trimmed_char,
    LENGTH(char_field) as char_length,
    LENGTH(TRIM(char_field)) as trimmed_length
FROM type_conversion_test
WHERE char_field <> '';
 id | text_field | varchar_field | char_field | trimmed_char | char_length | trimmed_length 
----+------------+---------------+------------+--------------+-------------+----------------
(0 rows)

-- Clean up
DROP INDEX IF EXISTS type_conv_idx;
DROP TABLE IF EXISTS type_conversion_test; 
