-- Test multi-index search with mixed fast fields
-- This test verifies that queries using multiple indices with mixed fast fields work correctly
-- Create main test tables
DROP TABLE IF EXISTS products;
DROP TABLE IF EXISTS categories;
DROP TABLE IF EXISTS reviews;
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name TEXT,
    description TEXT,
    price NUMERIC(10,2),
    stock_count INTEGER,
    weight FLOAT,
    is_available BOOLEAN,
    created_at TIMESTAMP
);
CREATE TABLE categories (
    id SERIAL PRIMARY KEY,
    name TEXT,
    description TEXT,
    product_count INTEGER,
    is_active BOOLEAN
);
CREATE TABLE reviews (
    id SERIAL PRIMARY KEY,
    product_id INTEGER REFERENCES products(id),
    reviewer_name TEXT,
    content TEXT,
    rating INTEGER,
    helpful_votes INTEGER,
    created_at TIMESTAMP
);
-- Insert test data
INSERT INTO products (name, description, price, stock_count, weight, is_available, created_at)
SELECT
    'Product ' || i,
    'Description for product ' || i || '. This product has various features and specifications.',
    (50.00 + (random() * 950))::numeric(10,2),
    (random() * 200)::integer,
    (0.1 + random() * 20)::float,
    random() < 0.8,  -- 80% are available
    now() - (random() * 365 * 2)::integer * interval '1 day'
FROM generate_series(1, 100) i;
INSERT INTO categories (name, description, product_count, is_active)
VALUES
    ('Electronics', 'Electronic devices and accessories', 40, true),
    ('Books', 'Books and publications', 30, true),
    ('Clothing', 'Apparel and fashion items', 25, true),
    ('Home & Kitchen', 'Home goods and kitchen items', 20, true),
    ('Toys', 'Toys and games', 15, true),
    ('Sports', 'Sporting goods and equipment', 10, true),
    ('Beauty', 'Beauty and personal care items', 5, false),
    ('Automotive', 'Car parts and accessories', 8, true),
    ('Office', 'Office supplies and equipment', 12, true),
    ('Outdoors', 'Outdoor equipment and accessories', 18, true);
-- Insert reviews (10 reviews per product for first 20 products)
INSERT INTO reviews (product_id, reviewer_name, content, rating, helpful_votes, created_at)
SELECT
    (i % 20) + 1,  -- product_id 1-20
    'Reviewer ' || ((i % 50) + 1),  -- 50 different reviewers
    CASE (i % 5)
        WHEN 0 THEN 'Great product, very satisfied with my purchase!'
        WHEN 1 THEN 'Good quality but a bit expensive.'
        WHEN 2 THEN 'Average product, meets basic expectations.'
        WHEN 3 THEN 'Not very impressed, could be better.'
        WHEN 4 THEN 'Terrible product, complete waste of money!'
    END,
    (i % 5) + 1,  -- rating 1-5
    (random() * 50)::integer,  -- helpful votes
    now() - (random() * 180)::integer * interval '1 day'  -- last 6 months
FROM generate_series(1, 200) i;
-- Create join table between products and categories (many-to-many)
DROP TABLE IF EXISTS product_categories;
CREATE TABLE product_categories (
    product_id INTEGER REFERENCES products(id),
    category_id INTEGER REFERENCES categories(id),
    PRIMARY KEY (product_id, category_id)
);
-- Assign each product to 1-3 categories
INSERT INTO product_categories (product_id, category_id)
SELECT
    p.id,
    c.id
FROM products p
CROSS JOIN LATERAL (
    SELECT id FROM categories
    ORDER BY random()
    LIMIT floor(random() * 3) + 1
) c;
-- Create search indices with mixed fast fields
DROP INDEX IF EXISTS products_idx;
DROP INDEX IF EXISTS categories_idx;
DROP INDEX IF EXISTS reviews_idx;
CREATE INDEX products_idx ON products
USING columnstore (name, description, price, stock_count, is_available)
WITH (type='hnsw');
ERROR:  access method "columnstore" does not exist
CREATE INDEX categories_idx ON categories
USING columnstore (name, description, product_count, is_active)
WITH (type='hnsw');
ERROR:  access method "columnstore" does not exist
CREATE INDEX reviews_idx ON reviews
USING columnstore (reviewer_name, content, rating, helpful_votes)
WITH (type='hnsw');
ERROR:  access method "columnstore" does not exist
-- Enable execution method tracing
SET pg_search.explain_analyze_verbose TO TRUE;
-- Test 1: Join between products and categories with search
EXPLAIN ANALYZE
SELECT p.name, p.price, c.name as category
FROM products p
JOIN product_categories pc ON p.id = pc.product_id
JOIN categories c ON pc.category_id = c.id
WHERE p.name ILIKE '%product%' AND c.is_active = true
ORDER BY p.price DESC
LIMIT 10;
                                                                        QUERY PLAN                                                                         
-----------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=33.41..33.42 rows=2 width=80) (actual time=0.750..0.753 rows=10 loops=1)
   ->  Sort  (cost=33.41..33.42 rows=2 width=80) (actual time=0.749..0.751 rows=10 loops=1)
         Sort Key: p.price DESC
         Sort Method: top-N heapsort  Memory: 26kB
         ->  Nested Loop  (cost=4.39..33.40 rows=2 width=80) (actual time=0.052..0.608 rows=100 loops=1)
               ->  Nested Loop  (cost=4.24..32.65 rows=4 width=52) (actual time=0.030..0.461 rows=100 loops=1)
                     ->  Seq Scan on products p  (cost=0.00..17.62 rows=1 width=52) (actual time=0.017..0.102 rows=100 loops=1)
                           Filter: (name ~~* '%product%'::text)
                     ->  Bitmap Heap Scan on product_categories pc  (cost=4.24..14.91 rows=11 width=8) (actual time=0.002..0.002 rows=1 loops=100)
                           Recheck Cond: (p.id = product_id)
                           Heap Blocks: exact=100
                           ->  Bitmap Index Scan on product_categories_pkey  (cost=0.00..4.24 rows=11 width=0) (actual time=0.001..0.001 rows=1 loops=100)
                                 Index Cond: (product_id = p.id)
               ->  Index Scan using categories_pkey on categories c  (cost=0.15..0.19 rows=1 width=36) (actual time=0.001..0.001 rows=1 loops=100)
                     Index Cond: (id = pc.category_id)
                     Filter: is_active
 Planning Time: 0.685 ms
 Execution Time: 0.827 ms
(18 rows)

-- Test 2: Join between products and reviews with search
EXPLAIN ANALYZE
SELECT p.name, r.rating, r.content
FROM products p
JOIN reviews r ON p.id = r.product_id
WHERE p.description ILIKE '%product%' AND r.rating >= 4
ORDER BY r.helpful_votes DESC
LIMIT 5;
                                                           QUERY PLAN                                                           
--------------------------------------------------------------------------------------------------------------------------------
 Limit  (cost=37.01..37.01 rows=1 width=72) (actual time=0.354..0.356 rows=5 loops=1)
   ->  Sort  (cost=37.01..37.01 rows=1 width=72) (actual time=0.354..0.355 rows=5 loops=1)
         Sort Key: r.helpful_votes DESC
         Sort Method: top-N heapsort  Memory: 25kB
         ->  Hash Join  (cost=17.64..37.00 rows=1 width=72) (actual time=0.274..0.317 rows=80 loops=1)
               Hash Cond: (r.product_id = p.id)
               ->  Seq Scan on reviews r  (cost=0.00..18.75 rows=233 width=44) (actual time=0.012..0.038 rows=80 loops=1)
                     Filter: (rating >= 4)
                     Rows Removed by Filter: 120
               ->  Hash  (cost=17.62..17.62 rows=1 width=36) (actual time=0.248..0.248 rows=100 loops=1)
                     Buckets: 1024  Batches: 1  Memory Usage: 13kB
                     ->  Seq Scan on products p  (cost=0.00..17.62 rows=1 width=36) (actual time=0.008..0.177 rows=100 loops=1)
                           Filter: (description ~~* '%product%'::text)
 Planning Time: 0.209 ms
 Execution Time: 0.396 ms
(15 rows)

-- Test 3: Three-way join with mixed field conditions
EXPLAIN ANALYZE
SELECT p.name, c.name as category, AVG(r.rating) as avg_rating
FROM products p
JOIN product_categories pc ON p.id = pc.product_id
JOIN categories c ON pc.category_id = c.id
JOIN reviews r ON p.id = r.product_id
WHERE p.price < 500 AND c.product_count > 10
GROUP BY p.name, c.name
HAVING AVG(r.rating) > 3
ORDER BY avg_rating DESC;
                                                                 QUERY PLAN                                                                  
---------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=119.18..119.42 rows=96 width=96) (actual time=0.152..0.153 rows=0 loops=1)
   Sort Key: (avg(r.rating)) DESC
   Sort Method: quicksort  Memory: 25kB
   ->  HashAggregate  (cost=111.69..116.01 rows=96 width=96) (actual time=0.116..0.118 rows=0 loops=1)
         Group Key: p.name, c.name
         Filter: (avg(r.rating) > '3'::numeric)
         Batches: 1  Memory Usage: 37kB
         ->  Hash Join  (cost=65.26..109.53 rows=288 width=68) (actual time=0.111..0.112 rows=0 loops=1)
               Hash Cond: (pc.product_id = p.id)
               ->  Hash Join  (cost=23.34..61.90 rows=754 width=36) (actual time=0.110..0.111 rows=0 loops=1)
                     Hash Cond: (pc.category_id = c.id)
                     ->  Seq Scan on product_categories pc  (cost=0.00..32.60 rows=2260 width=8) (actual time=0.007..0.015 rows=100 loops=1)
                     ->  Hash  (cost=20.00..20.00 rows=267 width=36) (actual time=0.068..0.068 rows=7 loops=1)
                           Buckets: 1024  Batches: 1  Memory Usage: 9kB
                           ->  Seq Scan on categories c  (cost=0.00..20.00 rows=267 width=36) (actual time=0.005..0.007 rows=7 loops=1)
                                 Filter: (product_count > 10)
                                 Rows Removed by Filter: 3
               ->  Hash  (cost=39.01..39.01 rows=233 width=44) (never executed)
                     ->  Hash Join  (cost=20.16..39.01 rows=233 width=44) (never executed)
                           Hash Cond: (r.product_id = p.id)
                           ->  Seq Scan on reviews r  (cost=0.00..17.00 rows=700 width=8) (never executed)
                           ->  Hash  (cost=17.62..17.62 rows=203 width=36) (never executed)
                                 ->  Seq Scan on products p  (cost=0.00..17.62 rows=203 width=36) (never executed)
                                       Filter: (price < '500'::numeric)
 Planning Time: 0.670 ms
 Execution Time: 0.299 ms
(26 rows)

-- Test 4: Complex query with multiple indices and mixed fields
EXPLAIN ANALYZE
WITH top_products AS (
    SELECT p.id, p.name, p.price, p.stock_count
    FROM products p
    WHERE p.price BETWEEN 100 AND 800
      AND p.is_available = true
    ORDER BY p.price DESC
    LIMIT 50
),
product_ratings AS (
    SELECT r.product_id, AVG(r.rating) as avg_rating, COUNT(*) as review_count
    FROM reviews r
    WHERE r.rating >= 3
    GROUP BY r.product_id
    HAVING COUNT(*) >= 2
)
SELECT tp.name, tp.price, pr.avg_rating, c.name as category
FROM top_products tp
JOIN product_ratings pr ON tp.id = pr.product_id
JOIN product_categories pc ON tp.id = pc.product_id
JOIN categories c ON pc.category_id = c.id
WHERE c.is_active = true
ORDER BY pr.avg_rating DESC, tp.price DESC;
                                                                              QUERY PLAN                                                                               
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=50.13..50.16 rows=12 width=112) (actual time=0.399..0.401 rows=8 loops=1)
   Sort Key: (avg(r.rating)) DESC, tp.price DESC
   Sort Method: quicksort  Memory: 25kB
   ->  Nested Loop  (cost=40.01..49.91 rows=12 width=112) (actual time=0.338..0.373 rows=8 loops=1)
         ->  Nested Loop  (cost=39.86..45.57 rows=23 width=84) (actual time=0.301..0.326 rows=8 loops=1)
               Join Filter: (pc.product_id = tp.id)
               ->  Hash Join  (cost=39.71..42.68 rows=2 width=88) (actual time=0.227..0.239 rows=8 loops=1)
                     Hash Cond: (r.product_id = tp.id)
                     ->  HashAggregate  (cost=20.50..22.76 rows=50 width=44) (actual time=0.058..0.067 rows=12 loops=1)
                           Group Key: r.product_id
                           Filter: (count(*) >= 2)
                           Batches: 1  Memory Usage: 40kB
                           ->  Seq Scan on reviews r  (cost=0.00..18.75 rows=233 width=8) (actual time=0.006..0.030 rows=120 loops=1)
                                 Filter: (rating >= 3)
                                 Rows Removed by Filter: 80
                     ->  Hash  (cost=19.18..19.18 rows=2 width=52) (actual time=0.156..0.157 rows=47 loops=1)
                           Buckets: 1024  Batches: 1  Memory Usage: 11kB
                           ->  Subquery Scan on tp  (cost=19.16..19.18 rows=2 width=52) (actual time=0.111..0.126 rows=47 loops=1)
                                 ->  Limit  (cost=19.16..19.16 rows=2 width=56) (actual time=0.110..0.118 rows=47 loops=1)
                                       ->  Sort  (cost=19.16..19.16 rows=2 width=56) (actual time=0.110..0.113 rows=47 loops=1)
                                             Sort Key: p.price DESC
                                             Sort Method: quicksort  Memory: 28kB
                                             ->  Seq Scan on products p  (cost=0.00..19.15 rows=2 width=56) (actual time=0.010..0.035 rows=47 loops=1)
                                                   Filter: (is_available AND (price >= '100'::numeric) AND (price <= '800'::numeric))
                                                   Rows Removed by Filter: 53
               ->  Index Only Scan using product_categories_pkey on product_categories pc  (cost=0.15..1.31 rows=11 width=8) (actual time=0.010..0.010 rows=1 loops=8)
                     Index Cond: (product_id = r.product_id)
                     Heap Fetches: 8
         ->  Index Scan using categories_pkey on categories c  (cost=0.15..0.19 rows=1 width=36) (actual time=0.005..0.005 rows=1 loops=8)
               Index Cond: (id = pc.category_id)
               Filter: is_active
 Planning Time: 0.515 ms
 Execution Time: 0.494 ms
(33 rows)

-- Test 5: Union of results from different tables
EXPLAIN ANALYZE
SELECT 'Product' as type, name as item_name, description as content
FROM products
WHERE name ILIKE '%10%' OR description ILIKE '%feature%'
UNION ALL
SELECT 'Category' as type, name as item_name, description as content
FROM categories
WHERE name ILIKE '%e%'
UNION ALL
SELECT 'Review' as type, reviewer_name as item_name, content
FROM reviews
WHERE content ILIKE '%great%'
ORDER BY type, item_name;
                                                     QUERY PLAN                                                     
--------------------------------------------------------------------------------------------------------------------
 Sort  (cost=107.97..110.28 rows=923 width=96) (actual time=0.678..0.687 rows=145 loops=1)
   Sort Key: ('Product'::text), products.name
   Sort Method: quicksort  Memory: 40kB
   ->  Append  (cost=0.00..62.52 rows=923 width=96) (actual time=0.013..0.497 rows=145 loops=1)
         ->  Seq Scan on products  (cost=0.00..19.15 rows=122 width=96) (actual time=0.012..0.236 rows=100 loops=1)
               Filter: ((name ~~* '%10%'::text) OR (description ~~* '%feature%'::text))
         ->  Seq Scan on categories  (cost=0.00..20.00 rows=800 width=96) (actual time=0.005..0.012 rows=5 loops=1)
               Filter: (name ~~* '%e%'::text)
               Rows Removed by Filter: 5
         ->  Seq Scan on reviews  (cost=0.00..18.75 rows=1 width=96) (actual time=0.012..0.232 rows=40 loops=1)
               Filter: (content ~~* '%great%'::text)
               Rows Removed by Filter: 160
 Planning Time: 0.168 ms
 Execution Time: 0.722 ms
(14 rows)

-- Test 6: Subquery with both numeric and text field filtering
EXPLAIN ANALYZE
SELECT p.name, p.price, p.stock_count
FROM products p
WHERE p.id IN (
    SELECT pc.product_id
    FROM product_categories pc
    JOIN categories c ON pc.category_id = c.id
    WHERE c.name ILIKE '%electronics%' OR c.name ILIKE '%clothing%'
)
AND p.stock_count > 50
AND p.price < 500
ORDER BY p.price;
                                                                        QUERY PLAN                                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=59.20..59.20 rows=1 width=52) (actual time=0.058..0.059 rows=0 loops=1)
   Sort Key: p.price
   Sort Method: quicksort  Memory: 25kB
   ->  Nested Loop  (cost=58.05..59.19 rows=1 width=52) (actual time=0.039..0.040 rows=0 loops=1)
         ->  HashAggregate  (cost=57.90..57.93 rows=3 width=4) (actual time=0.039..0.040 rows=0 loops=1)
               Group Key: pc.product_id
               Batches: 1  Memory Usage: 24kB
               ->  Nested Loop  (cost=25.11..57.89 rows=3 width=4) (actual time=0.039..0.039 rows=0 loops=1)
                     ->  Seq Scan on categories c  (cost=0.00..22.00 rows=1 width=4) (actual time=0.009..0.025 rows=2 loops=1)
                           Filter: ((name ~~* '%electronics%'::text) OR (name ~~* '%clothing%'::text))
                           Rows Removed by Filter: 8
                     ->  Bitmap Heap Scan on product_categories pc  (cost=25.11..35.78 rows=11 width=8) (actual time=0.006..0.006 rows=0 loops=2)
                           Recheck Cond: (category_id = c.id)
                           ->  Bitmap Index Scan on product_categories_pkey  (cost=0.00..25.11 rows=11 width=0) (actual time=0.003..0.003 rows=0 loops=2)
                                 Index Cond: (category_id = c.id)
         ->  Index Scan using products_pkey on products p  (cost=0.15..0.41 rows=1 width=56) (never executed)
               Index Cond: (id = pc.product_id)
               Filter: ((stock_count > 50) AND (price < '500'::numeric))
 Planning Time: 0.272 ms
 Execution Time: 0.122 ms
(20 rows)

-- Test 7: Join with conditional logic and mixed fields
EXPLAIN ANALYZE
SELECT 
    p.name,
    p.price,
    CASE 
        WHEN r.rating IS NULL THEN 'No reviews'
        WHEN r.rating < 3 THEN 'Poor reviews'
        WHEN r.rating < 4 THEN 'Average reviews'
        ELSE 'Great reviews'
    END as review_status
FROM products p
LEFT JOIN (
    SELECT product_id, AVG(rating) as rating
    FROM reviews
    GROUP BY product_id
) r ON p.id = r.product_id
WHERE p.is_available = true
  AND p.price BETWEEN 200 AND 600
ORDER BY 
    CASE 
        WHEN r.rating IS NULL THEN 0
        ELSE r.rating
    END DESC,
    p.price;
                                                       QUERY PLAN                                                        
-------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=44.72..44.72 rows=2 width=112) (actual time=0.236..0.238 rows=23 loops=1)
   Sort Key: (CASE WHEN ((avg(reviews.rating)) IS NULL) THEN '0'::numeric ELSE (avg(reviews.rating)) END) DESC, p.price
   Sort Method: quicksort  Memory: 26kB
   ->  Hash Right Join  (cost=39.67..44.71 rows=2 width=112) (actual time=0.171..0.189 rows=23 loops=1)
         Hash Cond: (reviews.product_id = p.id)
         ->  HashAggregate  (cost=20.50..23.00 rows=200 width=36) (actual time=0.063..0.074 rows=20 loops=1)
               Group Key: reviews.product_id
               Batches: 1  Memory Usage: 40kB
               ->  Seq Scan on reviews  (cost=0.00..17.00 rows=700 width=8) (actual time=0.004..0.021 rows=200 loops=1)
         ->  Hash  (cost=19.15..19.15 rows=2 width=52) (actual time=0.098..0.098 rows=23 loops=1)
               Buckets: 1024  Batches: 1  Memory Usage: 10kB
               ->  Seq Scan on products p  (cost=0.00..19.15 rows=2 width=52) (actual time=0.009..0.030 rows=23 loops=1)
                     Filter: (is_available AND (price >= '200'::numeric) AND (price <= '600'::numeric))
                     Rows Removed by Filter: 77
 Planning Time: 0.157 ms
 Execution Time: 0.295 ms
(16 rows)

-- Test 8: Multi-index intersection
EXPLAIN ANALYZE
SELECT p.name, p.price, r.content, r.rating
FROM products p
JOIN reviews r ON p.id = r.product_id
JOIN product_categories pc ON p.id = pc.product_id
JOIN categories c ON pc.category_id = c.id
WHERE p.name ILIKE '%product%'
  AND r.rating > 3
  AND c.name = 'Electronics'
  AND p.is_available = true
ORDER BY r.rating DESC, p.price DESC;
                                                                               QUERY PLAN                                                                               
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort  (cost=38.48..38.49 rows=1 width=84) (actual time=0.376..0.377 rows=0 loops=1)
   Sort Key: r.rating DESC, p.price DESC
   Sort Method: quicksort  Memory: 25kB
   ->  Nested Loop  (cost=17.94..38.47 rows=1 width=84) (actual time=0.358..0.359 rows=0 loops=1)
         ->  Nested Loop  (cost=17.79..37.69 rows=4 width=88) (actual time=0.150..0.273 rows=60 loops=1)
               Join Filter: (p.id = pc.product_id)
               ->  Hash Join  (cost=17.64..37.00 rows=1 width=92) (actual time=0.116..0.155 rows=60 loops=1)
                     Hash Cond: (r.product_id = p.id)
                     ->  Seq Scan on reviews r  (cost=0.00..18.75 rows=233 width=40) (actual time=0.008..0.031 rows=80 loops=1)
                           Filter: (rating > 3)
                           Rows Removed by Filter: 120
                     ->  Hash  (cost=17.62..17.62 rows=1 width=52) (actual time=0.099..0.100 rows=70 loops=1)
                           Buckets: 1024  Batches: 1  Memory Usage: 12kB
                           ->  Seq Scan on products p  (cost=0.00..17.62 rows=1 width=52) (actual time=0.007..0.065 rows=70 loops=1)
                                 Filter: (is_available AND (name ~~* '%product%'::text))
                                 Rows Removed by Filter: 30
               ->  Index Only Scan using product_categories_pkey on product_categories pc  (cost=0.15..0.55 rows=11 width=8) (actual time=0.001..0.002 rows=1 loops=60)
                     Index Cond: (product_id = r.product_id)
                     Heap Fetches: 60
         ->  Index Scan using categories_pkey on categories c  (cost=0.15..0.19 rows=1 width=4) (actual time=0.001..0.001 rows=0 loops=60)
               Index Cond: (id = pc.category_id)
               Filter: (name = 'Electronics'::text)
               Rows Removed by Filter: 1
 Planning Time: 0.380 ms
 Execution Time: 0.429 ms
(25 rows)

-- Verify actual results of multi-index search
SELECT p.name, p.price, c.name as category
FROM products p
JOIN product_categories pc ON p.id = pc.product_id
JOIN categories c ON pc.category_id = c.id
WHERE p.name ILIKE '%product 1%' AND c.is_active = true
ORDER BY p.price DESC
LIMIT 5;
    name    | price  | category 
------------+--------+----------
 Product 16 | 994.99 | Sports
 Product 10 | 953.35 | Sports
 Product 12 | 891.74 | Sports
 Product 19 | 824.40 | Sports
 Product 13 | 761.78 | Sports
(5 rows)

-- Clean up
DROP INDEX IF EXISTS products_idx;
DROP INDEX IF EXISTS categories_idx;
DROP INDEX IF EXISTS reviews_idx;
DROP TABLE IF EXISTS product_categories;
DROP TABLE IF EXISTS reviews;
DROP TABLE IF EXISTS products;
DROP TABLE IF EXISTS categories; 
