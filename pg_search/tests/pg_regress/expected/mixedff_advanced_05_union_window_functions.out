-- Tests UNION and window functions with mixed fast fields
\i common/mixedff_advanced_setup.sql
CREATE EXTENSION IF NOT EXISTS pg_search;
-- Disable parallel workers to avoid differences in plans
SET max_parallel_workers_per_gather = 0;
SET enable_indexscan to OFF;
SET paradedb.enable_mixed_fast_field_exec = true;
-- Drop any existing test tables from this group
DROP TABLE IF EXISTS documents CASCADE;
DROP TABLE IF EXISTS files CASCADE; 
DROP TABLE IF EXISTS pages CASCADE;
DROP TABLE IF EXISTS mixed_numeric_string_test CASCADE;
DROP TABLE IF EXISTS categories CASCADE;
DROP TABLE IF EXISTS products CASCADE;
DROP TABLE IF EXISTS conversion_test CASCADE;
-- Create test table for mixed fast and non-fast fields
CREATE TABLE mixed_numeric_string_test (
    id TEXT PRIMARY KEY,
    numeric_field1 INTEGER NOT NULL,
    numeric_field2 BIGINT NOT NULL,
    string_field1 TEXT NOT NULL,
    string_field2 TEXT NOT NULL,
    string_field3 TEXT NOT NULL,
    content TEXT
);
CREATE INDEX mixed_test_search ON mixed_numeric_string_test USING bm25 (
    id,
    numeric_field1,
    numeric_field2,
    string_field1,
    string_field2,
    string_field3,
    content
) WITH (
    key_field = 'id',
    text_fields = '{"string_field1": {"tokenizer": {"type": "default"}, "fast": true}, "string_field2": {"tokenizer": {"type": "default"}, "fast": true}, "string_field3": {"tokenizer": {"type": "default"}, "fast": true}, "content": {"tokenizer": {"type": "default"}}}',
    numeric_fields = '{"numeric_field1": {"fast": true}, "numeric_field2": {"fast": true}}'
);
psql:common/mixedff_advanced_setup.sql:40: WARNING:  the `raw` tokenizer is deprecated
-- Insert test data
INSERT INTO mixed_numeric_string_test (id, numeric_field1, numeric_field2, string_field1, string_field2, string_field3, content) VALUES
('mix1', 100, 10000, 'Apple', 'Red', 'Fruit', 'This is a red apple'),
('mix2', 200, 20000, 'Banana', 'Yellow', 'Fruit', 'This is a yellow banana'),
('mix3', 300, 30000, 'Carrot', 'Orange', 'Vegetable', 'This is an orange carrot'),
('mix4', 400, 40000, 'Donut', 'Brown', 'Dessert', 'This is a chocolate donut'),
('mix5', 500, 50000, 'Egg', 'White', 'Protein', 'This is a white egg');
-- Data for window functions and UNION
DO $$
DECLARE
    i INTEGER;
BEGIN
    FOR i IN 1..10 LOOP
        INSERT INTO mixed_numeric_string_test (
            id, 
            numeric_field1, 
            numeric_field2, 
            string_field1, 
            string_field2, 
            string_field3, 
            content
        ) VALUES (
            'window' || i,
            (i * 10),
            (i * 100),
            'Group' || (i % 3),
            'Window' || (i % 2),
            'Test',
            'Window function test with searchable terms'
        );
    END LOOP;
END $$;
-- Set up document tables for advanced features
CREATE TABLE documents (
    id TEXT PRIMARY KEY,
    title TEXT NOT NULL,
    content TEXT,
    parents TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);
CREATE TABLE files (
    id TEXT NOT NULL UNIQUE,
    documentId TEXT NOT NULL,
    title TEXT NOT NULL,
    file_path TEXT NOT NULL,
    file_size INTEGER,
    created_at TIMESTAMP DEFAULT NOW(),
    PRIMARY KEY (id, documentId),
    FOREIGN KEY (documentId) REFERENCES documents(id)
);
CREATE TABLE pages (
    id TEXT NOT NULL UNIQUE,
    fileId TEXT NOT NULL,
    page_number INTEGER NOT NULL,
    content TEXT NOT NULL,
    metadata JSONB,
    created_at TIMESTAMP DEFAULT NOW(),
    PRIMARY KEY (id, fileId),
    FOREIGN KEY (fileId) REFERENCES files(id)
);
-- Create BM25 indexes
CREATE INDEX documents_search ON documents USING bm25 (
    id,
    title,
    parents,
    content
) WITH (
    key_field = 'id',
    text_fields = '{"title": {"tokenizer": {"type": "default"}, "fast": true}, "parents": {"tokenizer": {"type": "default"}, "fast": true}, "content": {"tokenizer": {"type": "default"}, "fast": true}}'
);
psql:common/mixedff_advanced_setup.sql:116: WARNING:  the `raw` tokenizer is deprecated
CREATE INDEX files_search ON files USING bm25 (
    id,
    documentId,
    title,
    file_path
) WITH (
    key_field = 'id',
    text_fields = '{"documentid": {"tokenizer": {"type": "keyword"}, "fast": true}, "title": {"tokenizer": {"type": "default"}, "fast": true}, "file_path": {"tokenizer": {"type": "default"}, "fast": true}}'
);
psql:common/mixedff_advanced_setup.sql:126: WARNING:  the `raw` tokenizer is deprecated
CREATE INDEX pages_search ON pages USING bm25 (
    id,
    fileId,
    content,
    page_number
) WITH (
    key_field = 'id',
    text_fields = '{"fileid": {"tokenizer": {"type": "keyword"}, "fast": true}, "content": {"tokenizer": {"type": "default"}}}',
    numeric_fields = '{"page_number": {"fast": true}}'
);
psql:common/mixedff_advanced_setup.sql:137: WARNING:  the `raw` tokenizer is deprecated
-- Insert sample data
INSERT INTO documents (id, title, content, parents) VALUES
('doc1', 'Invoice 2023', 'This is an invoice for services rendered in 2023', 'Factures'),
('doc2', 'Receipt 2023', 'This is a receipt for payment received in 2023', 'Factures'),
('doc3', 'Contract 2023', 'This is a contract for services in 2023', 'Contracts');
INSERT INTO files (id, documentId, title, file_path, file_size) VALUES
('file1', 'doc1', 'Invoice PDF', '/invoices/2023.pdf', 1024),
('file2', 'doc1', 'Invoice Receipt', '/invoices/2023_receipt.pdf', 512),
('file3', 'doc2', 'Receipt', '/receipts/2023.pdf', 256),
('file4', 'doc3', 'Contract Document', '/contracts/2023.pdf', 2048);
INSERT INTO pages (id, fileId, page_number, content) VALUES
('page1', 'file1', 1, 'Page 1 of Invoice PDF with Socienty General details'),
('page2', 'file1', 2, 'Page 2 of Invoice PDF with payment information'),
('page3', 'file2', 1, 'Page 1 of Invoice Receipt with bank details'),
('page4', 'file3', 1, 'Page 1 of Receipt with Socienty General information'),
('page5', 'file3', 2, 'Page 2 of Receipt with transaction ID'),
('page6', 'file4', 1, 'Page 1 of Contract Document with terms and conditions');
-- Create recursive CTE test data
CREATE TABLE categories (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    parent_id INTEGER REFERENCES categories(id)
);
CREATE INDEX category_search ON categories USING bm25 (
    id,
    name,
    description
) WITH (
    key_field = 'id',
    text_fields = '{"name": {"tokenizer": {"type": "default"}, "fast": true}, "description": {"tokenizer": {"type": "default"}, "fast": true}}'
);
INSERT INTO categories (name, description, parent_id) VALUES
('Electronics', 'Electronic devices and accessories', NULL),
('Computers', 'Desktop and laptop computers', 1),
('Smartphones', 'Mobile phones and accessories', 1),
('Clothing', 'Apparel and fashion items', NULL),
('Men''s Clothing', 'Clothing for men', 4),
('Women''s Clothing', 'Clothing for women', 4),
('Food', 'Edible products', NULL),
('Dairy', 'Milk and dairy products', 7),
('Bakery', 'Bread and baked goods', 7);
-- Create products for multi-index search
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    category_id INTEGER REFERENCES categories(id),
    price FLOAT NOT NULL
);
CREATE INDEX product_search ON products USING bm25 (
    id,
    name,
    category_id,
    price
) WITH (
    key_field = 'id',
    text_fields = '{"name": {"tokenizer": {"type": "default"}, "fast": true}}',
    numeric_fields = '{"category_id": {"fast": true}, "price": {"fast": true}}'
);
INSERT INTO products (name, category_id, price) VALUES
('Laptop Pro', 2, 1299.99),
('Smartphone X', 3, 899.99),
('Men''s Shirt', 5, 49.99),
('Women''s Dress', 6, 199.99),
('Milk Carton', 8, 3.99),
('Bread Loaf', 9, 5.99);
-- Create table for type conversion testing
CREATE TABLE conversion_test (
    id TEXT PRIMARY KEY,
    smallint_field SMALLINT,
    integer_field INTEGER,
    bigint_field BIGINT,
    numeric_field FLOAT,
    real_field REAL,
    double_field DOUBLE PRECISION,
    bool_from_int BOOLEAN,
    timestamp_field TIMESTAMP,
    content TEXT
);
CREATE INDEX conversion_search ON conversion_test USING bm25 (
    id, 
    smallint_field, 
    integer_field, 
    bigint_field, 
    numeric_field, 
    real_field, 
    double_field, 
    bool_from_int,
    timestamp_field,
    content
) WITH (
    key_field = 'id',
    text_fields = '{"content": {"tokenizer": {"type": "default"}}}',
    numeric_fields = '{
        "smallint_field": {"fast": true}, 
        "integer_field": {"fast": true}, 
        "bigint_field": {"fast": true}, 
        "numeric_field": {"fast": true}, 
        "real_field": {"fast": true}, 
        "double_field": {"fast": true}
    }',
    boolean_fields = '{"bool_from_int": {"fast": true}}'
);
psql:common/mixedff_advanced_setup.sql:251: WARNING:  the `raw` tokenizer is deprecated
INSERT INTO conversion_test VALUES
('conv1', 32767, 2147483647, 9223372036854775807, 9999999.99, 3.402e38, 1.7976931348623157e308, true, '1988-04-29', 'conversion test'),
('conv2', -32768, -2147483648, -9223372036854775808, -9999999.99, -3.402e38, -1.7976931348623157e308, false, '1999-12-31', 'conversion test'),
('conv3', 0, 0, 0, 0.0, 0.0, 0.0, false, '2000-01-01', 'conversion test');
-- Add a product with a distinct string for testing
INSERT INTO mixed_numeric_string_test (id, numeric_field1, numeric_field2, string_field1, string_field2, string_field3, content) VALUES
('unique1', 42, 4242, 'Unique Product Z', 'Test', 'Item', 'This is a uniqueproductZ for testing mixed fields'); 
-- Create test tables
DROP TABLE IF EXISTS union_test_a;
DROP TABLE IF EXISTS union_test_b;
CREATE TABLE union_test_a (
    id SERIAL PRIMARY KEY,
    title TEXT,
    author TEXT,
    rating FLOAT,
    year INTEGER,
    price FLOAT,
    is_published BOOLEAN
);
CREATE TABLE union_test_b (
    id SERIAL PRIMARY KEY,
    title TEXT,
    author TEXT,
    rating FLOAT,
    year INTEGER,
    price FLOAT,
    is_published BOOLEAN
);
-- Insert test data with deterministic values
INSERT INTO union_test_a (title, author, rating, year, price, is_published)
SELECT
    'Book A' || i,
    'Author ' || (1 + (i % 10)),
    (3 + (i % 3))::float,  -- Ratings from 3 to 5
    2000 + (i % 22),
    (10 + (i * 5))::float,   -- Deterministic prices
    i % 3 != 0               -- Deterministic boolean pattern
FROM generate_series(1, 50) i;
INSERT INTO union_test_b (title, author, rating, year, price, is_published)
SELECT
    'Book B' || i,
    'Author ' || (1 + (i % 15)),
    (1 + (i % 5))::float,  -- Ratings from 1 to 5
    1980 + (i % 40),
    (15 + (i * 3))::float,   -- Deterministic prices
    i % 4 != 0               -- Deterministic boolean pattern
FROM generate_series(1, 50) i;
-- Create indices with mixed fast fields
DROP INDEX IF EXISTS union_test_a_idx;
DROP INDEX IF EXISTS union_test_b_idx;
CREATE INDEX union_test_a_idx ON union_test_a
USING bm25 (id, title, author, rating, year, price, is_published)
WITH (
    key_field = 'id',
    text_fields = '{"title": {"tokenizer": {"type": "default"}, "fast": true}, "author": {"tokenizer": {"type": "default"}, "fast": true}}',
    numeric_fields = '{"rating": {"fast": true}, "year": {"fast": true}, "price": {"fast": true}}',
    boolean_fields = '{"is_published": {"fast": true}}'
);
CREATE INDEX union_test_b_idx ON union_test_b
USING bm25 (id, title, author, rating, year, price, is_published)
WITH (
    key_field = 'id',
    text_fields = '{"title": {"tokenizer": {"type": "default"}, "fast": true}, "author": {"tokenizer": {"type": "default"}, "fast": true}}',
    numeric_fields = '{"rating": {"fast": true}, "year": {"fast": true}, "price": {"fast": true}}',
    boolean_fields = '{"is_published": {"fast": true}}'
);
\echo 'Test: UNION operations'
Test: UNION operations
-- Test 1: Basic UNION with mixed field types
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT title, author, rating, price
FROM union_test_a
WHERE title @@@ 'Book A' AND rating > 4
UNION
SELECT title, author, rating, price
FROM union_test_b
WHERE title @@@ 'Book B' AND rating > 3
ORDER BY rating DESC, title;
                                                                                                                                         QUERY PLAN                                                                                                                                          
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: union_test_a.rating DESC, union_test_a.title
   ->  HashAggregate
         Group Key: union_test_a.title, union_test_a.author, union_test_a.rating, union_test_a.price
         ->  Append
               ->  Custom Scan (ParadeDB Scan) on union_test_a
                     Table: union_test_a
                     Index: union_test_a_idx
                     Exec Method: MixedFastFieldExecState
                     Fast Fields: author, title, price, rating
                     String Fast Fields: author, title
                     Numeric Fast Fields: price, rating
                     Scores: false
                     Tantivy Query: {"boolean":{"must":[{"with_index":{"query":{"parse_with_field":{"field":"title","query_string":"Book A","lenient":null,"conjunction_mode":null}}}},{"range":{"field":"rating","lower_bound":{"excluded":4.0},"upper_bound":null,"is_datetime":false}}]}}
               ->  Custom Scan (ParadeDB Scan) on union_test_b
                     Table: union_test_b
                     Index: union_test_b_idx
                     Exec Method: MixedFastFieldExecState
                     Fast Fields: author, title, price, rating
                     String Fast Fields: author, title
                     Numeric Fast Fields: price, rating
                     Scores: false
                     Tantivy Query: {"boolean":{"must":[{"with_index":{"query":{"parse_with_field":{"field":"title","query_string":"Book B","lenient":null,"conjunction_mode":null}}}},{"range":{"field":"rating","lower_bound":{"excluded":3.0},"upper_bound":null,"is_datetime":false}}]}}
(23 rows)

SELECT title, author, rating, price
FROM union_test_a
WHERE title @@@ 'Book A' AND rating > 4
UNION
SELECT title, author, rating, price
FROM union_test_b
WHERE title @@@ 'Book B' AND rating > 3
ORDER BY rating DESC, title;
  title   |  author   | rating | price 
----------+-----------+--------+-------
 Book A11 | Author 2  |      5 |    65
 Book A14 | Author 5  |      5 |    80
 Book A17 | Author 8  |      5 |    95
 Book A2  | Author 3  |      5 |    20
 Book A20 | Author 1  |      5 |   110
 Book A23 | Author 4  |      5 |   125
 Book A26 | Author 7  |      5 |   140
 Book A29 | Author 10 |      5 |   155
 Book A32 | Author 3  |      5 |   170
 Book A35 | Author 6  |      5 |   185
 Book A38 | Author 9  |      5 |   200
 Book A41 | Author 2  |      5 |   215
 Book A44 | Author 5  |      5 |   230
 Book A47 | Author 8  |      5 |   245
 Book A5  | Author 6  |      5 |    35
 Book A50 | Author 1  |      5 |   260
 Book A8  | Author 9  |      5 |    50
 Book B14 | Author 15 |      5 |    57
 Book B19 | Author 5  |      5 |    72
 Book B24 | Author 10 |      5 |    87
 Book B29 | Author 15 |      5 |   102
 Book B34 | Author 5  |      5 |   117
 Book B39 | Author 10 |      5 |   132
 Book B4  | Author 5  |      5 |    27
 Book B44 | Author 15 |      5 |   147
 Book B49 | Author 5  |      5 |   162
 Book B9  | Author 10 |      5 |    42
 Book B13 | Author 14 |      4 |    54
 Book B18 | Author 4  |      4 |    69
 Book B23 | Author 9  |      4 |    84
 Book B28 | Author 14 |      4 |    99
 Book B3  | Author 4  |      4 |    24
 Book B33 | Author 4  |      4 |   114
 Book B38 | Author 9  |      4 |   129
 Book B43 | Author 14 |      4 |   144
 Book B48 | Author 4  |      4 |   159
 Book B8  | Author 9  |      4 |    39
(37 rows)

-- Test 2: UNION ALL with numeric fields for filtering
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT title, price, year
FROM union_test_a
WHERE price < 30 AND year > 2000 and title @@@ 'Book A'
UNION ALL
SELECT title, price, year
FROM union_test_b
WHERE price < 45 AND year > 1982 and title @@@ 'Book B'
ORDER BY price;
                                                                                                                                                                                       QUERY PLAN                                                                                                                                                                                        
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: union_test_a.price
   ->  Append
         ->  Custom Scan (ParadeDB Scan) on union_test_a
               Table: union_test_a
               Index: union_test_a_idx
               Exec Method: MixedFastFieldExecState
               Fast Fields: title, price, year
               String Fast Fields: title
               Numeric Fast Fields: price, year
               Scores: false
               Tantivy Query: {"boolean":{"must":[{"range":{"field":"price","lower_bound":null,"upper_bound":{"excluded":30.0},"is_datetime":false}},{"range":{"field":"year","lower_bound":{"excluded":2000},"upper_bound":null,"is_datetime":false}},{"with_index":{"query":{"parse_with_field":{"field":"title","query_string":"Book A","lenient":null,"conjunction_mode":null}}}}]}}
         ->  Custom Scan (ParadeDB Scan) on union_test_b
               Table: union_test_b
               Index: union_test_b_idx
               Exec Method: MixedFastFieldExecState
               Fast Fields: title, price, year
               String Fast Fields: title
               Numeric Fast Fields: price, year
               Scores: false
               Tantivy Query: {"boolean":{"must":[{"range":{"field":"price","lower_bound":null,"upper_bound":{"excluded":45.0},"is_datetime":false}},{"range":{"field":"year","lower_bound":{"excluded":1982},"upper_bound":null,"is_datetime":false}},{"with_index":{"query":{"parse_with_field":{"field":"title","query_string":"Book B","lenient":null,"conjunction_mode":null}}}}]}}
(21 rows)

SELECT title, price, year
FROM union_test_a
WHERE price < 30 AND year > 2000 and title @@@ 'Book A'
UNION ALL
SELECT title, price, year
FROM union_test_b
WHERE price < 45 AND year > 1982 and title @@@ 'Book B'
ORDER BY price;
  title  | price | year 
---------+-------+------
 Book A1 |    15 | 2001
 Book A2 |    20 | 2002
 Book B3 |    24 | 1983
 Book A3 |    25 | 2003
 Book B4 |    27 | 1984
 Book B5 |    30 | 1985
 Book B6 |    33 | 1986
 Book B7 |    36 | 1987
 Book B8 |    39 | 1988
 Book B9 |    42 | 1989
(10 rows)

-- Test 3: Window function - ROW_NUMBER() with mixed fields
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT title, author, price, rating,
       ROW_NUMBER() OVER (PARTITION BY author, price ORDER BY rating DESC) as author_rank
FROM union_test_a
WHERE title @@@ 'Book A'
ORDER BY title, author, author_rank;
                                                                            QUERY PLAN                                                                             
-------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: title, author, (row_number() OVER (?))
   ->  WindowAgg
         ->  Sort
               Sort Key: author, price, rating DESC
               ->  Custom Scan (ParadeDB Scan) on union_test_a
                     Table: union_test_a
                     Index: union_test_a_idx
                     Exec Method: MixedFastFieldExecState
                     Fast Fields: author, title, price, rating
                     String Fast Fields: author, title
                     Numeric Fast Fields: price, rating
                     Scores: false
                     Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"title","query_string":"Book A","lenient":null,"conjunction_mode":null}}}}
(14 rows)

SELECT title, author, price, rating,
       ROW_NUMBER() OVER (PARTITION BY author, price ORDER BY rating DESC) as author_rank
FROM union_test_a
WHERE title @@@ 'Book A'
ORDER BY title, author, author_rank;
  title   |  author   | price | rating | author_rank 
----------+-----------+-------+--------+-------------
 Book A1  | Author 2  |    15 |      4 |           1
 Book A10 | Author 1  |    60 |      4 |           1
 Book A11 | Author 2  |    65 |      5 |           1
 Book A12 | Author 3  |    70 |      3 |           1
 Book A13 | Author 4  |    75 |      4 |           1
 Book A14 | Author 5  |    80 |      5 |           1
 Book A15 | Author 6  |    85 |      3 |           1
 Book A16 | Author 7  |    90 |      4 |           1
 Book A17 | Author 8  |    95 |      5 |           1
 Book A18 | Author 9  |   100 |      3 |           1
 Book A19 | Author 10 |   105 |      4 |           1
 Book A2  | Author 3  |    20 |      5 |           1
 Book A20 | Author 1  |   110 |      5 |           1
 Book A21 | Author 2  |   115 |      3 |           1
 Book A22 | Author 3  |   120 |      4 |           1
 Book A23 | Author 4  |   125 |      5 |           1
 Book A24 | Author 5  |   130 |      3 |           1
 Book A25 | Author 6  |   135 |      4 |           1
 Book A26 | Author 7  |   140 |      5 |           1
 Book A27 | Author 8  |   145 |      3 |           1
 Book A28 | Author 9  |   150 |      4 |           1
 Book A29 | Author 10 |   155 |      5 |           1
 Book A3  | Author 4  |    25 |      3 |           1
 Book A30 | Author 1  |   160 |      3 |           1
 Book A31 | Author 2  |   165 |      4 |           1
 Book A32 | Author 3  |   170 |      5 |           1
 Book A33 | Author 4  |   175 |      3 |           1
 Book A34 | Author 5  |   180 |      4 |           1
 Book A35 | Author 6  |   185 |      5 |           1
 Book A36 | Author 7  |   190 |      3 |           1
 Book A37 | Author 8  |   195 |      4 |           1
 Book A38 | Author 9  |   200 |      5 |           1
 Book A39 | Author 10 |   205 |      3 |           1
 Book A4  | Author 5  |    30 |      4 |           1
 Book A40 | Author 1  |   210 |      4 |           1
 Book A41 | Author 2  |   215 |      5 |           1
 Book A42 | Author 3  |   220 |      3 |           1
 Book A43 | Author 4  |   225 |      4 |           1
 Book A44 | Author 5  |   230 |      5 |           1
 Book A45 | Author 6  |   235 |      3 |           1
 Book A46 | Author 7  |   240 |      4 |           1
 Book A47 | Author 8  |   245 |      5 |           1
 Book A48 | Author 9  |   250 |      3 |           1
 Book A49 | Author 10 |   255 |      4 |           1
 Book A5  | Author 6  |    35 |      5 |           1
 Book A50 | Author 1  |   260 |      5 |           1
 Book A6  | Author 7  |    40 |      3 |           1
 Book A7  | Author 8  |    45 |      4 |           1
 Book A8  | Author 9  |    50 |      5 |           1
 Book A9  | Author 10 |    55 |      3 |           1
(50 rows)

-- Test 4: Window function - Running average price by author
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT title, author, price,
       AVG(price) OVER (PARTITION BY author ORDER BY price) as running_avg_price
FROM union_test_a
WHERE author @@@ 'Author'
ORDER BY title, author, price;
                                                                             QUERY PLAN                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: title, author, price
   ->  WindowAgg
         ->  Sort
               Sort Key: author, price
               ->  Custom Scan (ParadeDB Scan) on union_test_a
                     Table: union_test_a
                     Index: union_test_a_idx
                     Exec Method: MixedFastFieldExecState
                     Fast Fields: author, title, price
                     String Fast Fields: author, title
                     Numeric Fast Fields: price
                     Scores: false
                     Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"author","query_string":"Author","lenient":null,"conjunction_mode":null}}}}
(14 rows)

SELECT title, author, price,
       AVG(price) OVER (PARTITION BY author ORDER BY price) as running_avg_price
FROM union_test_a
WHERE author @@@ 'Author'
ORDER BY title, author, price;
  title   |  author   | price | running_avg_price 
----------+-----------+-------+-------------------
 Book A1  | Author 2  |    15 |                15
 Book A10 | Author 1  |    60 |                60
 Book A11 | Author 2  |    65 |                40
 Book A12 | Author 3  |    70 |                45
 Book A13 | Author 4  |    75 |                50
 Book A14 | Author 5  |    80 |                55
 Book A15 | Author 6  |    85 |                60
 Book A16 | Author 7  |    90 |                65
 Book A17 | Author 8  |    95 |                70
 Book A18 | Author 9  |   100 |                75
 Book A19 | Author 10 |   105 |                80
 Book A2  | Author 3  |    20 |                20
 Book A20 | Author 1  |   110 |                85
 Book A21 | Author 2  |   115 |                65
 Book A22 | Author 3  |   120 |                70
 Book A23 | Author 4  |   125 |                75
 Book A24 | Author 5  |   130 |                80
 Book A25 | Author 6  |   135 |                85
 Book A26 | Author 7  |   140 |                90
 Book A27 | Author 8  |   145 |                95
 Book A28 | Author 9  |   150 |               100
 Book A29 | Author 10 |   155 |               105
 Book A3  | Author 4  |    25 |                25
 Book A30 | Author 1  |   160 |               110
 Book A31 | Author 2  |   165 |                90
 Book A32 | Author 3  |   170 |                95
 Book A33 | Author 4  |   175 |               100
 Book A34 | Author 5  |   180 |               105
 Book A35 | Author 6  |   185 |               110
 Book A36 | Author 7  |   190 |               115
 Book A37 | Author 8  |   195 |               120
 Book A38 | Author 9  |   200 |               125
 Book A39 | Author 10 |   205 |               130
 Book A4  | Author 5  |    30 |                30
 Book A40 | Author 1  |   210 |               135
 Book A41 | Author 2  |   215 |               115
 Book A42 | Author 3  |   220 |               120
 Book A43 | Author 4  |   225 |               125
 Book A44 | Author 5  |   230 |               130
 Book A45 | Author 6  |   235 |               135
 Book A46 | Author 7  |   240 |               140
 Book A47 | Author 8  |   245 |               145
 Book A48 | Author 9  |   250 |               150
 Book A49 | Author 10 |   255 |               155
 Book A5  | Author 6  |    35 |                35
 Book A50 | Author 1  |   260 |               160
 Book A6  | Author 7  |    40 |                40
 Book A7  | Author 8  |    45 |                45
 Book A8  | Author 9  |    50 |                50
 Book A9  | Author 10 |    55 |                55
(50 rows)

-- Test 5: Window function with UNION and mixed filters
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
WITH combined_books AS (
    SELECT title, author, rating, 'A' as source
    FROM union_test_a
    WHERE rating > 3.5 and title @@@ 'Book A'
    UNION
    SELECT title, author, rating, 'B' as source
    FROM union_test_b
    WHERE rating > 2.5 and title @@@ 'Book A'
)
SELECT title, author, rating, source,
       RANK() OVER (PARTITION BY author ORDER BY rating DESC) as author_rank
FROM combined_books
ORDER BY title, author, author_rank;
                                                                                                                                                  QUERY PLAN                                                                                                                                                   
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: combined_books.title, combined_books.author, (rank() OVER (?))
   ->  WindowAgg
         ->  Sort
               Sort Key: combined_books.author, combined_books.rating DESC
               ->  Subquery Scan on combined_books
                     ->  HashAggregate
                           Group Key: union_test_a.title, union_test_a.author, union_test_a.rating, ('A'::text)
                           ->  Append
                                 ->  Custom Scan (ParadeDB Scan) on union_test_a
                                       Table: union_test_a
                                       Index: union_test_a_idx
                                       Exec Method: NormalScanExecState
                                       Fast Fields: author, title, rating
                                       String Fast Fields: author, title
                                       Numeric Fast Fields: rating
                                       Scores: false
                                       Tantivy Query: {"boolean":{"must":[{"range":{"field":"rating","lower_bound":{"excluded":3.5},"upper_bound":null,"is_datetime":false}},{"with_index":{"query":{"parse_with_field":{"field":"title","query_string":"Book A","lenient":null,"conjunction_mode":null}}}}]}}
                                 ->  Custom Scan (ParadeDB Scan) on union_test_b
                                       Table: union_test_b
                                       Index: union_test_b_idx
                                       Exec Method: NormalScanExecState
                                       Fast Fields: author, title, rating
                                       String Fast Fields: author, title
                                       Numeric Fast Fields: rating
                                       Scores: false
                                       Tantivy Query: {"boolean":{"must":[{"range":{"field":"rating","lower_bound":{"excluded":2.5},"upper_bound":null,"is_datetime":false}},{"with_index":{"query":{"parse_with_field":{"field":"title","query_string":"Book A","lenient":null,"conjunction_mode":null}}}}]}}
(27 rows)

WITH combined_books AS (
    SELECT title, author, rating, 'A' as source
    FROM union_test_a
    WHERE rating > 3.5 and title @@@ 'Book A'
    UNION
    SELECT title, author, rating, 'B' as source
    FROM union_test_b
    WHERE rating > 2.5 and title @@@ 'Book A'
)
SELECT title, author, rating, source,
       RANK() OVER (PARTITION BY author ORDER BY rating DESC) as author_rank
FROM combined_books
ORDER BY title, author, author_rank;
  title   |  author   | rating | source | author_rank 
----------+-----------+--------+--------+-------------
 Book A1  | Author 2  |      4 | A      |           3
 Book A10 | Author 1  |      4 | A      |           3
 Book A11 | Author 2  |      5 | A      |           1
 Book A13 | Author 4  |      4 | A      |           2
 Book A14 | Author 5  |      5 | A      |           1
 Book A16 | Author 7  |      4 | A      |           2
 Book A17 | Author 8  |      5 | A      |           1
 Book A19 | Author 10 |      4 | A      |           5
 Book A2  | Author 3  |      5 | A      |           1
 Book A20 | Author 1  |      5 | A      |           1
 Book A22 | Author 3  |      4 | A      |           3
 Book A23 | Author 4  |      5 | A      |           1
 Book A25 | Author 6  |      4 | A      |           3
 Book A26 | Author 7  |      5 | A      |           1
 Book A28 | Author 9  |      4 | A      |           3
 Book A29 | Author 10 |      5 | A      |           1
 Book A31 | Author 2  |      4 | A      |           3
 Book A32 | Author 3  |      5 | A      |           1
 Book A34 | Author 5  |      4 | A      |           7
 Book A35 | Author 6  |      5 | A      |           1
 Book A37 | Author 8  |      4 | A      |           3
 Book A38 | Author 9  |      5 | A      |           1
 Book A4  | Author 5  |      4 | A      |           7
 Book A40 | Author 1  |      4 | A      |           3
 Book A41 | Author 2  |      5 | A      |           1
 Book A43 | Author 4  |      4 | A      |           2
 Book A44 | Author 5  |      5 | A      |           1
 Book A46 | Author 7  |      4 | A      |           2
 Book A47 | Author 8  |      5 | A      |           1
 Book A49 | Author 10 |      4 | A      |           5
 Book A5  | Author 6  |      5 | A      |           1
 Book A50 | Author 1  |      5 | A      |           1
 Book A7  | Author 8  |      4 | A      |           3
 Book A8  | Author 9  |      5 | A      |           1
 Book B12 | Author 13 |      3 | B      |           1
 Book B13 | Author 14 |      4 | B      |           1
 Book B14 | Author 15 |      5 | B      |           1
 Book B17 | Author 3  |      3 | B      |           4
 Book B18 | Author 4  |      4 | B      |           2
 Book B19 | Author 5  |      5 | B      |           1
 Book B2  | Author 3  |      3 | B      |           4
 Book B22 | Author 8  |      3 | B      |           5
 Book B23 | Author 9  |      4 | B      |           3
 Book B24 | Author 10 |      5 | B      |           1
 Book B27 | Author 13 |      3 | B      |           1
 Book B28 | Author 14 |      4 | B      |           1
 Book B29 | Author 15 |      5 | B      |           1
 Book B3  | Author 4  |      4 | B      |           2
 Book B32 | Author 3  |      3 | B      |           4
 Book B33 | Author 4  |      4 | B      |           2
 Book B34 | Author 5  |      5 | B      |           1
 Book B37 | Author 8  |      3 | B      |           5
 Book B38 | Author 9  |      4 | B      |           3
 Book B39 | Author 10 |      5 | B      |           1
 Book B4  | Author 5  |      5 | B      |           1
 Book B42 | Author 13 |      3 | B      |           1
 Book B43 | Author 14 |      4 | B      |           1
 Book B44 | Author 15 |      5 | B      |           1
 Book B47 | Author 3  |      3 | B      |           4
 Book B48 | Author 4  |      4 | B      |           2
 Book B49 | Author 5  |      5 | B      |           1
 Book B7  | Author 8  |      3 | B      |           5
 Book B8  | Author 9  |      4 | B      |           3
 Book B9  | Author 10 |      5 | B      |           1
(64 rows)

-- Test 6: UNION with boolean and text fields
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT title, author, is_published
FROM union_test_a
WHERE is_published = true AND author @@@ 'Author 1'
UNION
SELECT title, author, is_published
FROM union_test_b
WHERE is_published = true AND author @@@ 'Author 1'
ORDER BY author, title;
                                                                                                                              QUERY PLAN                                                                                                                              
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: union_test_a.author, union_test_a.title
   ->  Unique
         ->  Merge Append
               Sort Key: union_test_a.title, union_test_a.author, union_test_a.is_published
               ->  Sort
                     Sort Key: union_test_a.title, union_test_a.author, union_test_a.is_published
                     ->  Custom Scan (ParadeDB Scan) on union_test_a
                           Table: union_test_a
                           Index: union_test_a_idx
                           Exec Method: MixedFastFieldExecState
                           Fast Fields: author, title, is_published
                           String Fast Fields: author, title
                           Numeric Fast Fields: is_published
                           Scores: false
                           Tantivy Query: {"boolean":{"must":[{"term":{"field":"is_published","value":true,"is_datetime":false}},{"with_index":{"query":{"parse_with_field":{"field":"author","query_string":"Author 1","lenient":null,"conjunction_mode":null}}}}]}}
               ->  Sort
                     Sort Key: union_test_b.title, union_test_b.author, union_test_b.is_published
                     ->  Custom Scan (ParadeDB Scan) on union_test_b
                           Table: union_test_b
                           Index: union_test_b_idx
                           Exec Method: MixedFastFieldExecState
                           Fast Fields: author, title, is_published
                           String Fast Fields: author, title
                           Numeric Fast Fields: is_published
                           Scores: false
                           Tantivy Query: {"boolean":{"must":[{"term":{"field":"is_published","value":true,"is_datetime":false}},{"with_index":{"query":{"parse_with_field":{"field":"author","query_string":"Author 1","lenient":null,"conjunction_mode":null}}}}]}}
(27 rows)

SELECT title, author, is_published
FROM union_test_a
WHERE is_published = true AND author @@@ 'Author 1'
UNION
SELECT title, author, is_published
FROM union_test_b
WHERE is_published = true AND author @@@ 'Author 1'
ORDER BY author, title;
  title   |  author   | is_published 
----------+-----------+--------------
 Book A10 | Author 1  | t
 Book A20 | Author 1  | t
 Book A40 | Author 1  | t
 Book A50 | Author 1  | t
 Book B15 | Author 1  | t
 Book B30 | Author 1  | t
 Book B45 | Author 1  | t
 Book A19 | Author 10 | t
 Book A29 | Author 10 | t
 Book A49 | Author 10 | t
 Book B39 | Author 10 | t
 Book B9  | Author 10 | t
 Book B10 | Author 11 | t
 Book B25 | Author 11 | t
 Book B11 | Author 12 | t
 Book B26 | Author 12 | t
 Book B41 | Author 12 | t
 Book B27 | Author 13 | t
 Book B42 | Author 13 | t
 Book B13 | Author 14 | t
 Book B43 | Author 14 | t
 Book B14 | Author 15 | t
 Book B29 | Author 15 | t
 Book A1  | Author 2  | t
 Book A11 | Author 2  | t
 Book A31 | Author 2  | t
 Book A41 | Author 2  | t
 Book B1  | Author 2  | t
 Book B31 | Author 2  | t
 Book B46 | Author 2  | t
 Book A2  | Author 3  | t
 Book A22 | Author 3  | t
 Book A32 | Author 3  | t
 Book B17 | Author 3  | t
 Book B2  | Author 3  | t
 Book B47 | Author 3  | t
 Book A13 | Author 4  | t
 Book A23 | Author 4  | t
 Book A43 | Author 4  | t
 Book B18 | Author 4  | t
 Book B3  | Author 4  | t
 Book B33 | Author 4  | t
 Book A14 | Author 5  | t
 Book A34 | Author 5  | t
 Book A4  | Author 5  | t
 Book A44 | Author 5  | t
 Book B19 | Author 5  | t
 Book B34 | Author 5  | t
 Book B49 | Author 5  | t
 Book A25 | Author 6  | t
 Book A35 | Author 6  | t
 Book A5  | Author 6  | t
 Book B35 | Author 6  | t
 Book B5  | Author 6  | t
 Book B50 | Author 6  | t
 Book A16 | Author 7  | t
 Book A26 | Author 7  | t
 Book A46 | Author 7  | t
 Book B21 | Author 7  | t
 Book B6  | Author 7  | t
 Book A17 | Author 8  | t
 Book A37 | Author 8  | t
 Book A47 | Author 8  | t
 Book A7  | Author 8  | t
 Book B22 | Author 8  | t
 Book B37 | Author 8  | t
 Book B7  | Author 8  | t
 Book A28 | Author 9  | t
 Book A38 | Author 9  | t
 Book A8  | Author 9  | t
 Book B23 | Author 9  | t
 Book B38 | Author 9  | t
(72 rows)

-- Test 7: Window functions with multiple partitions and mixed fields
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT author, 
       AVG(rating) as avg_rating,
       AVG(price) as avg_price,
       COUNT(*) as book_count,
       RANK() OVER (ORDER BY AVG(rating) DESC) as rating_rank,
       RANK() OVER (ORDER BY AVG(price)) as price_rank
FROM union_test_a
WHERE author @@@ 'Author'
GROUP BY author
ORDER BY avg_rating DESC;
                                                                                   QUERY PLAN                                                                                   
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 WindowAgg
   ->  Sort
         Sort Key: (avg(rating)) DESC
         ->  WindowAgg
               ->  Sort
                     Sort Key: (avg(price))
                     ->  HashAggregate
                           Group Key: author
                           ->  Custom Scan (ParadeDB Scan) on union_test_a
                                 Table: union_test_a
                                 Index: union_test_a_idx
                                 Exec Method: MixedFastFieldExecState
                                 Fast Fields: author, price, rating
                                 String Fast Fields: author
                                 Numeric Fast Fields: price, rating
                                 Scores: false
                                 Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"author","query_string":"Author","lenient":null,"conjunction_mode":null}}}}
(17 rows)

SELECT author, 
       AVG(rating) as avg_rating,
       AVG(price) as avg_price,
       COUNT(*) as book_count,
       RANK() OVER (ORDER BY AVG(rating) DESC) as rating_rank,
       RANK() OVER (ORDER BY AVG(price)) as price_rank
FROM union_test_a
WHERE author @@@ 'Author'
GROUP BY author
ORDER BY avg_rating DESC;
  author   | avg_rating | avg_price | book_count | rating_rank | price_rank 
-----------+------------+-----------+------------+-------------+------------
 Author 2  |        4.2 |       115 |          5 |           1 |          1
 Author 5  |        4.2 |       130 |          5 |           1 |          4
 Author 8  |        4.2 |       145 |          5 |           1 |          7
 Author 1  |        4.2 |       160 |          5 |           1 |         10
 Author 6  |          4 |       135 |          5 |           5 |          5
 Author 3  |          4 |       120 |          5 |           5 |          2
 Author 9  |          4 |       150 |          5 |           5 |          8
 Author 7  |        3.8 |       140 |          5 |           8 |          6
 Author 10 |        3.8 |       155 |          5 |           8 |          9
 Author 4  |        3.8 |       125 |          5 |           8 |          3
(10 rows)

-- Test 8: UNION with INTERSECT and different field types
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
(SELECT author FROM union_test_a WHERE rating > 4.5 and title @@@ 'Book A')
INTERSECT
(SELECT author FROM union_test_b WHERE rating > 4.0 and title @@@ 'Book A');
                                                                                                                                         QUERY PLAN                                                                                                                                          
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 HashSetOp Intersect
   ->  Append
         ->  Subquery Scan on "*SELECT* 2"
               ->  Custom Scan (ParadeDB Scan) on union_test_b
                     Table: union_test_b
                     Index: union_test_b_idx
                     Exec Method: StringFastFieldExecState
                     Fast Fields: author
                     String Agg Field: author
                     Scores: false
                     Tantivy Query: {"boolean":{"must":[{"range":{"field":"rating","lower_bound":{"excluded":4.0},"upper_bound":null,"is_datetime":false}},{"with_index":{"query":{"parse_with_field":{"field":"title","query_string":"Book A","lenient":null,"conjunction_mode":null}}}}]}}
         ->  Subquery Scan on "*SELECT* 1"
               ->  Custom Scan (ParadeDB Scan) on union_test_a
                     Table: union_test_a
                     Index: union_test_a_idx
                     Exec Method: StringFastFieldExecState
                     Fast Fields: author
                     String Agg Field: author
                     Scores: false
                     Tantivy Query: {"boolean":{"must":[{"range":{"field":"rating","lower_bound":{"excluded":4.5},"upper_bound":null,"is_datetime":false}},{"with_index":{"query":{"parse_with_field":{"field":"title","query_string":"Book A","lenient":null,"conjunction_mode":null}}}}]}}
(20 rows)

(SELECT author FROM union_test_a WHERE rating > 4.5 and title @@@ 'Book A')
INTERSECT
(SELECT author FROM union_test_b WHERE rating > 4.0 and title @@@ 'Book A');
  author   
-----------
 Author 5
 Author 10
(2 rows)

-- Verify actual results of UNION (not just execution method)
SELECT title, author, rating, price
FROM union_test_a
WHERE title @@@ 'Book A1' AND rating > 4
UNION
SELECT title, author, rating, price
FROM union_test_b
WHERE title @@@ 'Book B1' AND rating > 3
ORDER BY rating DESC, title
LIMIT 10;
  title   |  author   | rating | price 
----------+-----------+--------+-------
 Book A11 | Author 2  |      5 |    65
 Book A14 | Author 5  |      5 |    80
 Book A17 | Author 8  |      5 |    95
 Book A2  | Author 3  |      5 |    20
 Book A20 | Author 1  |      5 |   110
 Book A23 | Author 4  |      5 |   125
 Book A26 | Author 7  |      5 |   140
 Book A29 | Author 10 |      5 |   155
 Book A32 | Author 3  |      5 |   170
 Book A35 | Author 6  |      5 |   185
(10 rows)

-- Verify window function results
SELECT title, author, price, rating,
       ROW_NUMBER() OVER (PARTITION BY author, price ORDER BY rating DESC) as author_rank
FROM union_test_a
WHERE author @@@ 'Author 1'
ORDER BY title, author, price
LIMIT 5;
  title   |  author  | price | rating | author_rank 
----------+----------+-------+--------+-------------
 Book A1  | Author 2 |    15 |      4 |           1
 Book A10 | Author 1 |    60 |      4 |           1
 Book A11 | Author 2 |    65 |      5 |           1
 Book A12 | Author 3 |    70 |      3 |           1
 Book A13 | Author 4 |    75 |      4 |           1
(5 rows)

\i common/mixedff_advanced_cleanup.sql
-- Cleanup for advanced features tests (13-21)
-- Drop the tables used in these tests (in reverse order to handle dependencies)
DROP TABLE IF EXISTS conversion_test CASCADE;
DROP TABLE IF EXISTS products CASCADE;
DROP TABLE IF EXISTS categories CASCADE;
DROP TABLE IF EXISTS pages CASCADE;
DROP TABLE IF EXISTS files CASCADE;
DROP TABLE IF EXISTS documents CASCADE;
DROP TABLE IF EXISTS mixed_numeric_string_test CASCADE;
DROP INDEX IF EXISTS union_test_a_idx CASCADE;
DROP INDEX IF EXISTS union_test_b_idx CASCADE;
DROP TABLE IF EXISTS union_test_a CASCADE;
DROP TABLE IF EXISTS union_test_b CASCADE; 
-- Reset parallel workers setting to default
RESET max_parallel_workers_per_gather;
RESET enable_indexscan;
RESET paradedb.enable_mixed_fast_field_exec;
SELECT 'Advanced features tests cleanup complete' AS status; 
                  status                  
------------------------------------------
 Advanced features tests cleanup complete
(1 row)

