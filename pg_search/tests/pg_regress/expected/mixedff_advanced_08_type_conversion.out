-- Tests type conversion edge cases with mixed fast fields
\i common/mixedff_advanced_setup.sql
CREATE EXTENSION IF NOT EXISTS pg_search;
-- Disable parallel workers to avoid differences in plans
SET max_parallel_workers_per_gather = 0;
SET enable_indexscan to OFF;
-- Drop any existing test tables from this group
DROP TABLE IF EXISTS documents CASCADE;
DROP TABLE IF EXISTS files CASCADE; 
DROP TABLE IF EXISTS pages CASCADE;
DROP TABLE IF EXISTS mixed_numeric_string_test CASCADE;
DROP TABLE IF EXISTS categories CASCADE;
DROP TABLE IF EXISTS products CASCADE;
DROP TABLE IF EXISTS conversion_test CASCADE;
-- Create test table for mixed fast and non-fast fields
CREATE TABLE mixed_numeric_string_test (
    id TEXT PRIMARY KEY,
    numeric_field1 INTEGER NOT NULL,
    numeric_field2 BIGINT NOT NULL,
    string_field1 TEXT NOT NULL,
    string_field2 TEXT NOT NULL,
    string_field3 TEXT NOT NULL,
    content TEXT
);
CREATE INDEX mixed_test_search ON mixed_numeric_string_test USING bm25 (
    id,
    numeric_field1,
    numeric_field2,
    string_field1,
    string_field2,
    string_field3,
    content
) WITH (
    key_field = 'id',
    text_fields = '{"string_field1": {"tokenizer": {"type": "default"}, "fast": true}, "string_field2": {"tokenizer": {"type": "default"}, "fast": true}, "string_field3": {"tokenizer": {"type": "default"}, "fast": true}, "content": {"tokenizer": {"type": "default"}}}',
    numeric_fields = '{"numeric_field1": {"fast": true}, "numeric_field2": {"fast": true}}'
);
psql:common/mixedff_advanced_setup.sql:39: WARNING:  the `raw` tokenizer is deprecated
-- Insert test data
INSERT INTO mixed_numeric_string_test (id, numeric_field1, numeric_field2, string_field1, string_field2, string_field3, content) VALUES
('mix1', 100, 10000, 'Apple', 'Red', 'Fruit', 'This is a red apple'),
('mix2', 200, 20000, 'Banana', 'Yellow', 'Fruit', 'This is a yellow banana'),
('mix3', 300, 30000, 'Carrot', 'Orange', 'Vegetable', 'This is an orange carrot'),
('mix4', 400, 40000, 'Donut', 'Brown', 'Dessert', 'This is a chocolate donut'),
('mix5', 500, 50000, 'Egg', 'White', 'Protein', 'This is a white egg');
-- Data for window functions and UNION
DO $$
DECLARE
    i INTEGER;
BEGIN
    FOR i IN 1..10 LOOP
        INSERT INTO mixed_numeric_string_test (
            id, 
            numeric_field1, 
            numeric_field2, 
            string_field1, 
            string_field2, 
            string_field3, 
            content
        ) VALUES (
            'window' || i,
            (i * 10),
            (i * 100),
            'Group' || (i % 3),
            'Window' || (i % 2),
            'Test',
            'Window function test with searchable terms'
        );
    END LOOP;
END $$;
-- Set up document tables for advanced features
CREATE TABLE documents (
    id TEXT PRIMARY KEY,
    title TEXT NOT NULL,
    content TEXT,
    parents TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);
CREATE TABLE files (
    id TEXT NOT NULL UNIQUE,
    documentId TEXT NOT NULL,
    title TEXT NOT NULL,
    file_path TEXT NOT NULL,
    file_size INTEGER,
    created_at TIMESTAMP DEFAULT NOW(),
    PRIMARY KEY (id, documentId),
    FOREIGN KEY (documentId) REFERENCES documents(id)
);
CREATE TABLE pages (
    id TEXT NOT NULL UNIQUE,
    fileId TEXT NOT NULL,
    page_number INTEGER NOT NULL,
    content TEXT NOT NULL,
    metadata JSONB,
    created_at TIMESTAMP DEFAULT NOW(),
    PRIMARY KEY (id, fileId),
    FOREIGN KEY (fileId) REFERENCES files(id)
);
-- Create BM25 indexes
CREATE INDEX documents_search ON documents USING bm25 (
    id,
    title,
    parents,
    content
) WITH (
    key_field = 'id',
    text_fields = '{"title": {"tokenizer": {"type": "default"}, "fast": true}, "parents": {"tokenizer": {"type": "default"}, "fast": true}, "content": {"tokenizer": {"type": "default"}, "fast": true}}'
);
psql:common/mixedff_advanced_setup.sql:115: WARNING:  the `raw` tokenizer is deprecated
CREATE INDEX files_search ON files USING bm25 (
    id,
    documentId,
    title,
    file_path
) WITH (
    key_field = 'id',
    text_fields = '{"documentid": {"tokenizer": {"type": "keyword"}, "fast": true}, "title": {"tokenizer": {"type": "default"}, "fast": true}, "file_path": {"tokenizer": {"type": "default"}, "fast": true}}'
);
psql:common/mixedff_advanced_setup.sql:125: WARNING:  the `raw` tokenizer is deprecated
CREATE INDEX pages_search ON pages USING bm25 (
    id,
    fileId,
    content,
    page_number
) WITH (
    key_field = 'id',
    text_fields = '{"fileid": {"tokenizer": {"type": "keyword"}, "fast": true}, "content": {"tokenizer": {"type": "default"}}}',
    numeric_fields = '{"page_number": {"fast": true}}'
);
psql:common/mixedff_advanced_setup.sql:136: WARNING:  the `raw` tokenizer is deprecated
-- Insert sample data
INSERT INTO documents (id, title, content, parents) VALUES
('doc1', 'Invoice 2023', 'This is an invoice for services rendered in 2023', 'Factures'),
('doc2', 'Receipt 2023', 'This is a receipt for payment received in 2023', 'Factures'),
('doc3', 'Contract 2023', 'This is a contract for services in 2023', 'Contracts');
INSERT INTO files (id, documentId, title, file_path, file_size) VALUES
('file1', 'doc1', 'Invoice PDF', '/invoices/2023.pdf', 1024),
('file2', 'doc1', 'Invoice Receipt', '/invoices/2023_receipt.pdf', 512),
('file3', 'doc2', 'Receipt', '/receipts/2023.pdf', 256),
('file4', 'doc3', 'Contract Document', '/contracts/2023.pdf', 2048);
INSERT INTO pages (id, fileId, page_number, content) VALUES
('page1', 'file1', 1, 'Page 1 of Invoice PDF with Socienty General details'),
('page2', 'file1', 2, 'Page 2 of Invoice PDF with payment information'),
('page3', 'file2', 1, 'Page 1 of Invoice Receipt with bank details'),
('page4', 'file3', 1, 'Page 1 of Receipt with Socienty General information'),
('page5', 'file3', 2, 'Page 2 of Receipt with transaction ID'),
('page6', 'file4', 1, 'Page 1 of Contract Document with terms and conditions');
-- Create recursive CTE test data
CREATE TABLE categories (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    parent_id INTEGER REFERENCES categories(id)
);
CREATE INDEX category_search ON categories USING bm25 (
    id,
    name,
    description
) WITH (
    key_field = 'id',
    text_fields = '{"name": {"tokenizer": {"type": "default"}, "fast": true}, "description": {"tokenizer": {"type": "default"}, "fast": true}}'
);
INSERT INTO categories (name, description, parent_id) VALUES
('Electronics', 'Electronic devices and accessories', NULL),
('Computers', 'Desktop and laptop computers', 1),
('Smartphones', 'Mobile phones and accessories', 1),
('Clothing', 'Apparel and fashion items', NULL),
('Men''s Clothing', 'Clothing for men', 4),
('Women''s Clothing', 'Clothing for women', 4),
('Food', 'Edible products', NULL),
('Dairy', 'Milk and dairy products', 7),
('Bakery', 'Bread and baked goods', 7);
-- Create products for multi-index search
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    category_id INTEGER REFERENCES categories(id),
    price NUMERIC(10,2) NOT NULL
);
CREATE INDEX product_search ON products USING bm25 (
    id,
    name,
    category_id,
    price
) WITH (
    key_field = 'id',
    text_fields = '{"name": {"tokenizer": {"type": "default"}, "fast": true}}',
    numeric_fields = '{"category_id": {"fast": true}, "price": {"fast": true}}'
);
INSERT INTO products (name, category_id, price) VALUES
('Laptop Pro', 2, 1299.99),
('Smartphone X', 3, 899.99),
('Men''s Shirt', 5, 49.99),
('Women''s Dress', 6, 199.99),
('Milk Carton', 8, 3.99),
('Bread Loaf', 9, 5.99);
-- Create table for type conversion testing
CREATE TABLE conversion_test (
    id TEXT PRIMARY KEY,
    smallint_field SMALLINT,
    integer_field INTEGER,
    bigint_field BIGINT,
    numeric_field NUMERIC(10,2),
    real_field REAL,
    double_field DOUBLE PRECISION,
    bool_from_int BOOLEAN,
    timestamp_field TIMESTAMP,
    content TEXT
);
CREATE INDEX conversion_search ON conversion_test USING bm25 (
    id, 
    smallint_field, 
    integer_field, 
    bigint_field, 
    numeric_field, 
    real_field, 
    double_field, 
    bool_from_int,
    timestamp_field,
    content
) WITH (
    key_field = 'id',
    text_fields = '{"content": {"tokenizer": {"type": "default"}}}',
    numeric_fields = '{
        "smallint_field": {"fast": true}, 
        "integer_field": {"fast": true}, 
        "bigint_field": {"fast": true}, 
        "numeric_field": {"fast": true}, 
        "real_field": {"fast": true}, 
        "double_field": {"fast": true}
    }',
    boolean_fields = '{"bool_from_int": {"fast": true}}'
);
psql:common/mixedff_advanced_setup.sql:250: WARNING:  the `raw` tokenizer is deprecated
INSERT INTO conversion_test VALUES
('conv1', 32767, 2147483647, 9223372036854775807, 9999999.99, 3.402e38, 1.7976931348623157e308, true, '1988-04-29', 'conversion test'),
('conv2', -32768, -2147483648, -9223372036854775808, -9999999.99, -3.402e38, -1.7976931348623157e308, false, '1999-12-31', 'conversion test'),
('conv3', 0, 0, 0, 0.0, 0.0, 0.0, false, '2000-01-01', 'conversion test');
-- Add a product with a distinct string for testing
INSERT INTO mixed_numeric_string_test (id, numeric_field1, numeric_field2, string_field1, string_field2, string_field3, content) VALUES
('unique1', 42, 4242, 'Unique Product Z', 'Test', 'Item', 'This is a uniqueproductZ for testing mixed fields'); 
-- Create test tables
DROP TABLE IF EXISTS union_test_a;
DROP TABLE IF EXISTS union_test_b;
CREATE TABLE union_test_a (
    id SERIAL PRIMARY KEY,
    title TEXT,
    author TEXT,
    rating NUMERIC,
    year INTEGER,
    price FLOAT,
    is_published BOOLEAN
);
CREATE TABLE union_test_b (
    id SERIAL PRIMARY KEY,
    title TEXT,
    author TEXT,
    rating NUMERIC,
    year INTEGER,
    price FLOAT,
    is_published BOOLEAN
);
-- Insert test data with deterministic values
INSERT INTO union_test_a (title, author, rating, year, price, is_published)
SELECT
    'Book A' || i,
    'Author ' || (1 + (i % 10)),
    (3 + (i % 3))::numeric,  -- Ratings from 3 to 5
    2000 + (i % 22),
    (10 + (i * 5))::float,   -- Deterministic prices
    i % 3 != 0               -- Deterministic boolean pattern
FROM generate_series(1, 50) i;
INSERT INTO union_test_b (title, author, rating, year, price, is_published)
SELECT
    'Book B' || i,
    'Author ' || (1 + (i % 15)),
    (1 + (i % 5))::numeric,  -- Ratings from 1 to 5
    1980 + (i % 40),
    (15 + (i * 3))::float,   -- Deterministic prices
    i % 4 != 0               -- Deterministic boolean pattern
FROM generate_series(1, 50) i;
-- Create indices with mixed fast fields
DROP INDEX IF EXISTS union_test_a_idx;
DROP INDEX IF EXISTS union_test_b_idx;
CREATE INDEX union_test_a_idx ON union_test_a
USING bm25 (id, title, author, rating, year, price, is_published)
WITH (
    key_field = 'id',
    text_fields = '{"title": {"tokenizer": {"type": "default"}, "fast": true}, "author": {"tokenizer": {"type": "default"}, "fast": true}}',
    numeric_fields = '{"rating": {"fast": true}, "year": {"fast": true}, "price": {"fast": true}}',
    boolean_fields = '{"is_published": {"fast": true}}'
);
CREATE INDEX union_test_b_idx ON union_test_b
USING bm25 (id, title, author, rating, year, price, is_published)
WITH (
    key_field = 'id',
    text_fields = '{"title": {"tokenizer": {"type": "default"}, "fast": true}, "author": {"tokenizer": {"type": "default"}, "fast": true}}',
    numeric_fields = '{"rating": {"fast": true}, "year": {"fast": true}, "price": {"fast": true}}',
    boolean_fields = '{"is_published": {"fast": true}}'
);
\echo 'Test: Type conversion edge cases'
Test: Type conversion edge cases
-- Create test table with various field types for conversion testing
DROP TABLE IF EXISTS type_conversion_test;
CREATE TABLE type_conversion_test (
    id SERIAL PRIMARY KEY,
    -- Text fields
    text_field TEXT,
    varchar_field VARCHAR(100),
    char_field CHAR(10),
    -- Numeric fields
    int_field INTEGER,
    smallint_field SMALLINT,
    bigint_field BIGINT,
    float_field FLOAT,
    numeric_field NUMERIC(10,2),
    decimal_field DECIMAL(10,2),
    real_field REAL,
    -- Boolean fields
    bool_field BOOLEAN,
    -- Date/Time fields
    date_field DATE,
    time_field TIME,
    timestamp_field TIMESTAMP,
    -- Special fields
    uuid_field UUID,
    json_field JSONB
);
-- Insert test data with edge cases for conversion
INSERT INTO type_conversion_test (
    text_field, varchar_field, char_field,
    int_field, smallint_field, bigint_field, float_field, numeric_field, decimal_field, real_field,
    bool_field, date_field, time_field, timestamp_field,
    uuid_field, json_field
) VALUES
    -- Case 1: Standard values
    (
        'Regular text', 'Regular varchar', 'Char     ',
        100, 10, 1000000, 3.14159, 123.45, 678.90, 2.71828,
        true, '2023-01-01', '12:30:00', '2023-01-01 12:30:00',
        '123e4567-e89b-12d3-a456-426614174000', '{"key": "value"}'
    ),
    -- Case 2: Numeric edge cases
    (
        '123', '456', '789',
        2147483647, 32767, 9223372036854775807, 1.7976931348623157e+308, 9999999.99, 9999999.99, 3.40282e+38,
        false, '2023-01-02', '00:00:01', '2023-01-02 00:00:01',
        '00000000-0000-0000-0000-000000000000', '{"number": 12345}'
    ),
    -- Case 3: Empty/NULL edge cases
    (
        '', '', '',
        0, 0, 0, 0.0, 0.00, 0.00, 0.0,
        NULL, '1970-01-01', '00:00:00', '1970-01-01 00:00:00',
        '00000000-0000-0000-0000-000000000000', '{}'
    ),
    -- Case 4: Special characters
    (
        'Text with special chars: !@#$%^&*()', 'Varchar with "quotes" and \'apostrophes\'', '~`[]{}\\|',
invalid command \'',
        -2147483648, -32768, -9223372036854775808, -1.7976931348623157e+308, -9999999.99, -9999999.99, -3.40282e+38,
        true, '9999-12-31', '23:59:59', '9999-12-31 23:59:59',
        'ffffffff-ffff-ffff-ffff-ffffffffffff', '{"array": [1, 2, 3]}'
    ),
    -- Case 5: Numeric strings
    (
        '12345.67890', '98765.43210', '1234567890',
        12345, 1234, 12345678901234, 12345.67890, 12345.67, 98765.43, 12345.67,
        false, '2023-05-15', '15:45:30', '2023-05-15 15:45:30',
        'a0eebc99-9c0b-4ef8-bb6d-6bb9bd380a11', '{"numeric": 12345.67890}'
    );
ERROR:  syntax error at or near "apostrophes" at character 1221
-- Create search index with mixed fast fields
DROP INDEX IF EXISTS type_conv_idx;
CREATE INDEX type_conv_idx ON type_conversion_test
USING bm25 (
    id, text_field, varchar_field, char_field,
    int_field, bigint_field, float_field, numeric_field,
    bool_field, date_field
)
WITH (
    key_field = 'id',
    text_fields = '{"text_field": {"tokenizer": {"type": "default"}, "fast": true}, "varchar_field": {"tokenizer": {"type": "default"}, "fast": true}, "char_field": {"tokenizer": {"type": "default"}, "fast": true}}',
    numeric_fields = '{"int_field": {"fast": true}, "bigint_field": {"fast": true}, "float_field": {"fast": true}, "numeric_field": {"fast": true}}',
    boolean_fields = '{"bool_field": {"fast": true}}'
);
ERROR:  cannot index column 'char_field' with type BuiltIn(BPCHAROID): invalid postgres oid passed to search index schema: BuiltIn(BPCHAROID)
-- Test 1: Basic text to text conversions
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT text_field, varchar_field, char_field
FROM type_conversion_test
WHERE text_field @@@ 'text' OR varchar_field @@@ 'varchar';
ERROR:  relation `public.type_conversion_test` must have a `USING bm25` index
SELECT text_field, varchar_field, char_field
FROM type_conversion_test
WHERE text_field @@@ 'text' OR varchar_field @@@ 'varchar';
ERROR:  relation `public.type_conversion_test` must have a `USING bm25` index
-- Test 2: Converting numeric string to number
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT text_field::numeric as converted_num, numeric_field
FROM type_conversion_test
WHERE text_field ~ '^[0-9.]+$';
                 QUERY PLAN                 
--------------------------------------------
 Seq Scan on type_conversion_test
   Filter: (text_field ~ '^[0-9.]+$'::text)
(2 rows)

SELECT text_field::numeric as converted_num, numeric_field
FROM type_conversion_test
WHERE text_field ~ '^[0-9.]+$';
 converted_num | numeric_field 
---------------+---------------
(0 rows)

-- Test 3: Numeric range filtering with casts
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT int_field, bigint_field, float_field
FROM type_conversion_test
WHERE int_field::float > 100 AND float_field::int < 12346;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Seq Scan on type_conversion_test
   Filter: (((int_field)::double precision > '100'::double precision) AND ((float_field)::integer < 12346))
(2 rows)

SELECT int_field, bigint_field, float_field
FROM type_conversion_test
WHERE int_field::float > 100 AND float_field::int < 12346;
 int_field | bigint_field | float_field 
-----------+--------------+-------------
(0 rows)

-- Test 4: String concatenation with different types
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT text_field || ' - ' || int_field::text as text_with_num
FROM type_conversion_test
WHERE bool_field = true;
            QUERY PLAN            
----------------------------------
 Seq Scan on type_conversion_test
   Filter: bool_field
(2 rows)

SELECT text_field || ' - ' || int_field::text as text_with_num
FROM type_conversion_test
WHERE bool_field = true;
 text_with_num 
---------------
(0 rows)

-- Test 5: Mixed type expressions in filtering
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT text_field, int_field, float_field
FROM type_conversion_test
WHERE (int_field::text = '100' OR text_field = '123') 
  AND float_field BETWEEN 2 AND 10000;
                                                                               QUERY PLAN                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Seq Scan on type_conversion_test
   Filter: ((float_field >= '2'::double precision) AND (float_field <= '10000'::double precision) AND (((int_field)::text = '100'::text) OR (text_field = '123'::text)))
(2 rows)

SELECT text_field, int_field, float_field
FROM type_conversion_test
WHERE (int_field::text = '100' OR text_field = '123') 
  AND float_field BETWEEN 2 AND 10000;
 text_field | int_field | float_field 
------------+-----------+-------------
(0 rows)

-- Test 6: Date conversions
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT date_field, timestamp_field
FROM type_conversion_test
WHERE date_field = timestamp_field::date;
                    QUERY PLAN                    
--------------------------------------------------
 Seq Scan on type_conversion_test
   Filter: (date_field = (timestamp_field)::date)
(2 rows)

SELECT date_field, timestamp_field
FROM type_conversion_test
WHERE date_field = timestamp_field::date;
 date_field | timestamp_field 
------------+-----------------
(0 rows)

-- Test 7: CASE expression with type conversion
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT 
    id,
    CASE 
        WHEN text_field ~ '^[0-9]+$' THEN text_field::integer * 2
        ELSE int_field
    END as converted_value
FROM type_conversion_test;
            QUERY PLAN            
----------------------------------
 Seq Scan on type_conversion_test
(1 row)

SELECT 
    id,
    CASE 
        WHEN text_field ~ '^[0-9]+$' THEN text_field::integer * 2
        ELSE int_field
    END as converted_value
FROM type_conversion_test;
 id | converted_value 
----+-----------------
(0 rows)

-- Test 8: JSON extraction with type conversion
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT 
    id,
    json_field,
    (json_field->>'number')::numeric AS extracted_number
FROM type_conversion_test
WHERE json_field ? 'number';
               QUERY PLAN                
-----------------------------------------
 Seq Scan on type_conversion_test
   Filter: (json_field ? 'number'::text)
(2 rows)

SELECT 
    id,
    json_field,
    (json_field->>'number')::numeric AS extracted_number
FROM type_conversion_test
WHERE json_field ? 'number';
 id | json_field | extracted_number 
----+------------+------------------
(0 rows)

-- Test 9: Complex mixed type filtering
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT text_field, int_field, bool_field
FROM type_conversion_test
WHERE 
    CASE 
        WHEN bool_field THEN int_field > 50
        ELSE text_field @@@ 'text'
    END;
ERROR:  relation `public.type_conversion_test` must have a `USING bm25` index
SELECT text_field, int_field, bool_field
FROM type_conversion_test
WHERE 
    CASE 
        WHEN bool_field THEN int_field > 50
        ELSE text_field @@@ 'text'
    END;
ERROR:  relation `public.type_conversion_test` must have a `USING bm25` index
-- Verify actual conversion results
SELECT 
    id,
    text_field,
    text_field::numeric as text_to_num,
    int_field,
    int_field::text as int_to_text,
    bool_field,
    CASE WHEN bool_field THEN 'Yes' ELSE 'No' END as bool_to_text
FROM type_conversion_test
WHERE text_field ~ '^[0-9.]+$' OR int_field > 1000;
 id | text_field | text_to_num | int_field | int_to_text | bool_field | bool_to_text 
----+------------+-------------+-----------+-------------+------------+--------------
(0 rows)

-- Test character set conversion issues
SELECT 
    id,
    text_field,
    varchar_field,
    char_field,
    TRIM(char_field) as trimmed_char,
    LENGTH(char_field) as char_length,
    LENGTH(TRIM(char_field)) as trimmed_length
FROM type_conversion_test
WHERE char_field <> '';
 id | text_field | varchar_field | char_field | trimmed_char | char_length | trimmed_length 
----+------------+---------------+------------+--------------+-------------+----------------
(0 rows)

-- Clean up
DROP INDEX IF EXISTS type_conv_idx;
DROP TABLE IF EXISTS type_conversion_test; 
\i common/mixedff_advanced_cleanup.sql 
-- Cleanup for advanced features tests (13-21)
-- Drop the tables used in these tests (in reverse order to handle dependencies)
DROP TABLE IF EXISTS conversion_test CASCADE;
DROP TABLE IF EXISTS products CASCADE;
DROP TABLE IF EXISTS categories CASCADE;
DROP TABLE IF EXISTS pages CASCADE;
DROP TABLE IF EXISTS files CASCADE;
DROP TABLE IF EXISTS documents CASCADE;
DROP TABLE IF EXISTS mixed_numeric_string_test CASCADE;
DROP INDEX IF EXISTS union_test_a_idx CASCADE;
DROP INDEX IF EXISTS union_test_b_idx CASCADE;
DROP TABLE IF EXISTS union_test_a CASCADE;
DROP TABLE IF EXISTS union_test_b CASCADE; 
-- Reset parallel workers setting to default
RESET max_parallel_workers_per_gather;
RESET enable_indexscan;
SELECT 'Advanced features tests cleanup complete' AS status; 
                  status                  
------------------------------------------
 Advanced features tests cleanup complete
(1 row)

