-- Test multi-index search with mixed fast fields
-- This test verifies that queries using multiple indices with mixed fast fields work correctly
\i common/mixedff_advanced_setup.sql
CREATE EXTENSION IF NOT EXISTS pg_search;
-- Disable parallel workers to avoid differences in plans
SET max_parallel_workers_per_gather = 0;
SET enable_indexscan to OFF;
SET paradedb.enable_mixed_fast_field_exec = true;
-- The `advanced` tests allow any number of columns to be used with fast fields, in order to test
-- more permutations of selected columns.
SET paradedb.mixed_fast_field_exec_column_threshold = 100;
-- Drop any existing test tables from this group
DROP TABLE IF EXISTS documents CASCADE;
DROP TABLE IF EXISTS files CASCADE; 
DROP TABLE IF EXISTS pages CASCADE;
DROP TABLE IF EXISTS mixed_numeric_string_test CASCADE;
DROP TABLE IF EXISTS categories CASCADE;
DROP TABLE IF EXISTS products CASCADE;
DROP TABLE IF EXISTS conversion_test CASCADE;
-- Create test table for mixed fast and non-fast fields
CREATE TABLE mixed_numeric_string_test (
    id TEXT PRIMARY KEY,
    numeric_field1 INTEGER NOT NULL,
    numeric_field2 BIGINT NOT NULL,
    string_field1 TEXT NOT NULL,
    string_field2 TEXT NOT NULL,
    string_field3 TEXT NOT NULL,
    content TEXT
);
CREATE INDEX mixed_test_search ON mixed_numeric_string_test USING bm25 (
    id,
    numeric_field1,
    numeric_field2,
    string_field1,
    string_field2,
    string_field3,
    content
) WITH (
    key_field = 'id',
    text_fields = '{"string_field1": {"tokenizer": {"type": "default"}, "fast": true}, "string_field2": {"tokenizer": {"type": "default"}, "fast": true}, "string_field3": {"tokenizer": {"type": "default"}, "fast": true}, "content": {"tokenizer": {"type": "default"}}}',
    numeric_fields = '{"numeric_field1": {"fast": true}, "numeric_field2": {"fast": true}}'
);
psql:common/mixedff_advanced_setup.sql:43: WARNING:  the `raw` tokenizer is deprecated
-- Insert test data
INSERT INTO mixed_numeric_string_test (id, numeric_field1, numeric_field2, string_field1, string_field2, string_field3, content) VALUES
('mix1', 100, 10000, 'Apple', 'Red', 'Fruit', 'This is a red apple'),
('mix2', 200, 20000, 'Banana', 'Yellow', 'Fruit', 'This is a yellow banana'),
('mix3', 300, 30000, 'Carrot', 'Orange', 'Vegetable', 'This is an orange carrot'),
('mix4', 400, 40000, 'Donut', 'Brown', 'Dessert', 'This is a chocolate donut'),
('mix5', 500, 50000, 'Egg', 'White', 'Protein', 'This is a white egg');
-- Data for window functions and UNION
DO $$
DECLARE
    i INTEGER;
BEGIN
    FOR i IN 1..10 LOOP
        INSERT INTO mixed_numeric_string_test (
            id, 
            numeric_field1, 
            numeric_field2, 
            string_field1, 
            string_field2, 
            string_field3, 
            content
        ) VALUES (
            'window' || i,
            (i * 10),
            (i * 100),
            'Group' || (i % 3),
            'Window' || (i % 2),
            'Test',
            'Window function test with searchable terms'
        );
    END LOOP;
END $$;
-- Set up document tables for advanced features
CREATE TABLE documents (
    id TEXT PRIMARY KEY,
    title TEXT NOT NULL,
    content TEXT,
    parents TEXT NOT NULL,
    created_at TIMESTAMP DEFAULT NOW()
);
CREATE TABLE files (
    id TEXT NOT NULL UNIQUE,
    documentId TEXT NOT NULL,
    title TEXT NOT NULL,
    file_path TEXT NOT NULL,
    file_size INTEGER,
    created_at TIMESTAMP DEFAULT NOW(),
    PRIMARY KEY (id, documentId),
    FOREIGN KEY (documentId) REFERENCES documents(id)
);
CREATE TABLE pages (
    id TEXT NOT NULL UNIQUE,
    fileId TEXT NOT NULL,
    page_number INTEGER NOT NULL,
    content TEXT NOT NULL,
    metadata JSONB,
    created_at TIMESTAMP DEFAULT NOW(),
    PRIMARY KEY (id, fileId),
    FOREIGN KEY (fileId) REFERENCES files(id)
);
-- Create BM25 indexes
CREATE INDEX documents_search ON documents USING bm25 (
    id,
    title,
    parents,
    content
) WITH (
    key_field = 'id',
    text_fields = '{"title": {"tokenizer": {"type": "default"}, "fast": true}, "parents": {"tokenizer": {"type": "default"}, "fast": true}, "content": {"tokenizer": {"type": "default"}, "fast": true}}'
);
psql:common/mixedff_advanced_setup.sql:119: WARNING:  the `raw` tokenizer is deprecated
CREATE INDEX files_search ON files USING bm25 (
    id,
    documentId,
    title,
    file_path
) WITH (
    key_field = 'id',
    text_fields = '{"documentid": {"tokenizer": {"type": "keyword"}, "fast": true}, "title": {"tokenizer": {"type": "default"}, "fast": true}, "file_path": {"tokenizer": {"type": "default"}, "fast": true}}'
);
psql:common/mixedff_advanced_setup.sql:129: WARNING:  the `raw` tokenizer is deprecated
CREATE INDEX pages_search ON pages USING bm25 (
    id,
    fileId,
    content,
    page_number
) WITH (
    key_field = 'id',
    text_fields = '{"fileid": {"tokenizer": {"type": "keyword"}, "fast": true}, "content": {"tokenizer": {"type": "default"}}}',
    numeric_fields = '{"page_number": {"fast": true}}'
);
psql:common/mixedff_advanced_setup.sql:140: WARNING:  the `raw` tokenizer is deprecated
-- Insert sample data
INSERT INTO documents (id, title, content, parents) VALUES
('doc1', 'Invoice 2023', 'This is an invoice for services rendered in 2023', 'Factures'),
('doc2', 'Receipt 2023', 'This is a receipt for payment received in 2023', 'Factures'),
('doc3', 'Contract 2023', 'This is a contract for services in 2023', 'Contracts');
INSERT INTO files (id, documentId, title, file_path, file_size) VALUES
('file1', 'doc1', 'Invoice PDF', '/invoices/2023.pdf', 1024),
('file2', 'doc1', 'Invoice Receipt', '/invoices/2023_receipt.pdf', 512),
('file3', 'doc2', 'Receipt', '/receipts/2023.pdf', 256),
('file4', 'doc3', 'Contract Document', '/contracts/2023.pdf', 2048);
INSERT INTO pages (id, fileId, page_number, content) VALUES
('page1', 'file1', 1, 'Page 1 of Invoice PDF with Socienty General details'),
('page2', 'file1', 2, 'Page 2 of Invoice PDF with payment information'),
('page3', 'file2', 1, 'Page 1 of Invoice Receipt with bank details'),
('page4', 'file3', 1, 'Page 1 of Receipt with Socienty General information'),
('page5', 'file3', 2, 'Page 2 of Receipt with transaction ID'),
('page6', 'file4', 1, 'Page 1 of Contract Document with terms and conditions');
-- Create recursive CTE test data
CREATE TABLE categories (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    description TEXT,
    parent_id INTEGER REFERENCES categories(id)
);
CREATE INDEX category_search ON categories USING bm25 (
    id,
    name,
    description
) WITH (
    key_field = 'id',
    text_fields = '{"name": {"tokenizer": {"type": "default"}, "fast": true}, "description": {"tokenizer": {"type": "default"}, "fast": true}}'
);
INSERT INTO categories (name, description, parent_id) VALUES
('Electronics', 'Electronic devices and accessories', NULL),
('Computers', 'Desktop and laptop computers', 1),
('Smartphones', 'Mobile phones and accessories', 1),
('Clothing', 'Apparel and fashion items', NULL),
('Men''s Clothing', 'Clothing for men', 4),
('Women''s Clothing', 'Clothing for women', 4),
('Food', 'Edible products', NULL),
('Dairy', 'Milk and dairy products', 7),
('Bakery', 'Bread and baked goods', 7);
-- Create products for multi-index search
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    category_id INTEGER REFERENCES categories(id),
    price FLOAT NOT NULL
);
CREATE INDEX product_search ON products USING bm25 (
    id,
    name,
    category_id,
    price
) WITH (
    key_field = 'id',
    text_fields = '{"name": {"tokenizer": {"type": "default"}, "fast": true}}',
    numeric_fields = '{"category_id": {"fast": true}, "price": {"fast": true}}'
);
INSERT INTO products (name, category_id, price) VALUES
('Laptop Pro', 2, 1299.99),
('Smartphone X', 3, 899.99),
('Men''s Shirt', 5, 49.99),
('Women''s Dress', 6, 199.99),
('Milk Carton', 8, 3.99),
('Bread Loaf', 9, 5.99);
-- Create table for type conversion testing
CREATE TABLE conversion_test (
    id TEXT PRIMARY KEY,
    smallint_field SMALLINT,
    integer_field INTEGER,
    bigint_field BIGINT,
    numeric_field FLOAT,
    real_field REAL,
    double_field DOUBLE PRECISION,
    bool_from_int BOOLEAN,
    timestamp_field TIMESTAMP,
    content TEXT
);
CREATE INDEX conversion_search ON conversion_test USING bm25 (
    id, 
    smallint_field, 
    integer_field, 
    bigint_field, 
    numeric_field, 
    real_field, 
    double_field, 
    bool_from_int,
    timestamp_field,
    content
) WITH (
    key_field = 'id',
    text_fields = '{"content": {"tokenizer": {"type": "default"}}}',
    numeric_fields = '{
        "smallint_field": {"fast": true}, 
        "integer_field": {"fast": true}, 
        "bigint_field": {"fast": true}, 
        "numeric_field": {"fast": true}, 
        "real_field": {"fast": true}, 
        "double_field": {"fast": true}
    }',
    boolean_fields = '{"bool_from_int": {"fast": true}}'
);
psql:common/mixedff_advanced_setup.sql:254: WARNING:  the `raw` tokenizer is deprecated
INSERT INTO conversion_test VALUES
('conv1', 32767, 2147483647, 9223372036854775807, 9999999.99, 3.402e38, 1.7976931348623157e308, true, '1988-04-29', 'conversion test'),
('conv2', -32768, -2147483648, -9223372036854775808, -9999999.99, -3.402e38, -1.7976931348623157e308, false, '1999-12-31', 'conversion test'),
('conv3', 0, 0, 0, 0.0, 0.0, 0.0, false, '2000-01-01', 'conversion test');
-- Add a product with a distinct string for testing
INSERT INTO mixed_numeric_string_test (id, numeric_field1, numeric_field2, string_field1, string_field2, string_field3, content) VALUES
('unique1', 42, 4242, 'Unique Product Z', 'Test', 'Item', 'This is a uniqueproductZ for testing mixed fields'); 
-- Create test tables
DROP TABLE IF EXISTS union_test_a;
DROP TABLE IF EXISTS union_test_b;
CREATE TABLE union_test_a (
    id SERIAL PRIMARY KEY,
    title TEXT,
    author TEXT,
    rating FLOAT,
    year INTEGER,
    price FLOAT,
    is_published BOOLEAN
);
CREATE TABLE union_test_b (
    id SERIAL PRIMARY KEY,
    title TEXT,
    author TEXT,
    rating FLOAT,
    year INTEGER,
    price FLOAT,
    is_published BOOLEAN
);
-- Insert test data with deterministic values
INSERT INTO union_test_a (title, author, rating, year, price, is_published)
SELECT
    'Book A' || i,
    'Author ' || (1 + (i % 10)),
    (3 + (i % 3))::float,  -- Ratings from 3 to 5
    2000 + (i % 22),
    (10 + (i * 5))::float,   -- Deterministic prices
    i % 3 != 0               -- Deterministic boolean pattern
FROM generate_series(1, 50) i;
INSERT INTO union_test_b (title, author, rating, year, price, is_published)
SELECT
    'Book B' || i,
    'Author ' || (1 + (i % 15)),
    (1 + (i % 5))::float,  -- Ratings from 1 to 5
    1980 + (i % 40),
    (15 + (i * 3))::float,   -- Deterministic prices
    i % 4 != 0               -- Deterministic boolean pattern
FROM generate_series(1, 50) i;
-- Create indices with mixed fast fields
DROP INDEX IF EXISTS union_test_a_idx;
DROP INDEX IF EXISTS union_test_b_idx;
CREATE INDEX union_test_a_idx ON union_test_a
USING bm25 (id, title, author, rating, year, price, is_published)
WITH (
    key_field = 'id',
    text_fields = '{"title": {"tokenizer": {"type": "default"}, "fast": true}, "author": {"tokenizer": {"type": "default"}, "fast": true}}',
    numeric_fields = '{"rating": {"fast": true}, "year": {"fast": true}, "price": {"fast": true}}',
    boolean_fields = '{"is_published": {"fast": true}}'
);
CREATE INDEX union_test_b_idx ON union_test_b
USING bm25 (id, title, author, rating, year, price, is_published)
WITH (
    key_field = 'id',
    text_fields = '{"title": {"tokenizer": {"type": "default"}, "fast": true}, "author": {"tokenizer": {"type": "default"}, "fast": true}}',
    numeric_fields = '{"rating": {"fast": true}, "year": {"fast": true}, "price": {"fast": true}}',
    boolean_fields = '{"is_published": {"fast": true}}'
);
-- Create main test tables
DROP TABLE IF EXISTS products;
DROP TABLE IF EXISTS categories;
DROP TABLE IF EXISTS reviews;
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name TEXT,
    description TEXT,
    price FLOAT,
    stock_count INTEGER,
    weight FLOAT,
    is_available BOOLEAN,
    created_at TIMESTAMP
);
CREATE TABLE categories (
    id SERIAL PRIMARY KEY,
    name TEXT,
    description TEXT,
    product_count INTEGER,
    is_active BOOLEAN
);
CREATE TABLE reviews (
    id SERIAL PRIMARY KEY,
    product_id INTEGER REFERENCES products(id),
    reviewer_name TEXT,
    content TEXT,
    rating INTEGER,
    helpful_votes INTEGER,
    created_at TIMESTAMP
);
-- Insert test data with deterministic values
INSERT INTO products (name, description, price, stock_count, weight, is_available, created_at)
SELECT
    'Product ' || i,
    'Description for product ' || i || '. This product has various features and specifications.',
    (50.00 + (i * 10))::float,          -- Deterministic prices
    (i * 2)::integer,                   -- Deterministic stock counts
    (0.1 + (i * 0.2))::float,           -- Deterministic weights
    i % 5 != 0,                         -- Deterministic availability pattern (80% available)
    '1988-04-29'::timestamp + (i * '1 day'::interval)  -- Deterministic dates
FROM generate_series(1, 100) i;
INSERT INTO categories (name, description, product_count, is_active)
VALUES
    ('Electronics', 'Electronic devices and accessories', 40, true),
    ('Books', 'Books and publications', 30, true),
    ('Clothing', 'Apparel and fashion items', 25, true),
    ('Home & Kitchen', 'Home goods and kitchen items', 20, true),
    ('Toys', 'Toys and games', 15, true),
    ('Sports', 'Sporting goods and equipment', 10, true),
    ('Beauty', 'Beauty and personal care items', 5, false),
    ('Automotive', 'Car parts and accessories', 8, true),
    ('Office', 'Office supplies and equipment', 12, true),
    ('Outdoors', 'Outdoor equipment and accessories', 18, true);
-- Insert reviews with deterministic values
INSERT INTO reviews (product_id, reviewer_name, content, rating, helpful_votes, created_at)
SELECT
    (i % 20) + 1,  -- product_id 1-20
    'Reviewer ' || ((i % 50) + 1),  -- 50 different reviewers
    CASE (i % 5)
        WHEN 0 THEN 'Great product, very satisfied with my purchase!'
        WHEN 1 THEN 'Good quality but a bit expensive.'
        WHEN 2 THEN 'Average product, meets basic expectations.'
        WHEN 3 THEN 'Not very impressed, could be better.'
        WHEN 4 THEN 'Terrible product, complete waste of money!'
    END,
    (i % 5) + 1,  -- rating 1-5
    (i % 50) * 2,  -- deterministic helpful votes
    '1988-04-29'::timestamp + (i * '1 day'::interval)  -- deterministic dates
FROM generate_series(1, 200) i;
-- Create join table between products and categories (many-to-many)
DROP TABLE IF EXISTS product_categories;
CREATE TABLE product_categories (
    product_id INTEGER REFERENCES products(id),
    category_id INTEGER REFERENCES categories(id),
    PRIMARY KEY (product_id, category_id)
);
-- Assign products to categories deterministically
INSERT INTO product_categories (product_id, category_id)
SELECT
    p.id,
    1 + (p.id % 10)  -- Assign to category 1-10 based on product id
FROM products p;
-- Add additional category assignments for some products (to have 1-3 categories per product)
INSERT INTO product_categories (product_id, category_id)
SELECT
    p.id,
    1 + ((p.id + 5) % 10)  -- Add a second category
FROM products p
WHERE p.id % 3 = 0;  -- Only for every 3rd product
INSERT INTO product_categories (product_id, category_id)
SELECT
    p.id,
    1 + ((p.id + 7) % 10)  -- Add a third category
FROM products p
WHERE p.id % 9 = 0;  -- Only for every 9th product
-- Create search indices with mixed fast fields
DROP INDEX IF EXISTS products_idx;
DROP INDEX IF EXISTS categories_idx;
DROP INDEX IF EXISTS reviews_idx;
CREATE INDEX products_idx ON products
USING bm25 (id, name, description, price, stock_count, is_available)
WITH (
    key_field = 'id',
    text_fields = '{"name": {"tokenizer": {"type": "default"}, "fast": true}, "description": {"tokenizer": {"type": "default"}}}',
    numeric_fields = '{"price": {"fast": true}, "stock_count": {"fast": true}}',
    boolean_fields = '{"is_available": {"fast": true}}'
);
CREATE INDEX categories_idx ON categories
USING bm25 (id, name, description, product_count, is_active)
WITH (
    key_field = 'id',
    text_fields = '{"name": {"tokenizer": {"type": "default"}, "fast": true}, "description": {"tokenizer": {"type": "default"}, "fast": true}}',
    numeric_fields = '{"product_count": {"fast": true}}',
    boolean_fields = '{"is_active": {"fast": true}}'
);
CREATE INDEX reviews_idx ON reviews
USING bm25 (id, reviewer_name, content, rating, helpful_votes)
WITH (
    key_field = 'id',
    text_fields = '{"reviewer_name": {"tokenizer": {"type": "default"}, "fast": true}, "content": {"tokenizer": {"type": "default"}}}',
    numeric_fields = '{"rating": {"fast": true}, "helpful_votes": {"fast": true}}'
);
-- Test 1: Join between products and categories with search
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT p.name, p.price, c.name as category
FROM products p
JOIN product_categories pc ON p.id = pc.product_id
JOIN categories c ON pc.category_id = c.id
WHERE p.name @@@ 'Product' AND c.is_active = true
ORDER BY p.price DESC
LIMIT 10;
                                                                               QUERY PLAN                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   ->  Sort
         Sort Key: p.price DESC
         ->  Hash Join
               Hash Cond: (pc.product_id = p.id)
               ->  Hash Join
                     Hash Cond: (pc.category_id = c.id)
                     ->  Seq Scan on product_categories pc
                     ->  Hash
                           ->  Seq Scan on categories c
                                 Filter: is_active
               ->  Hash
                     ->  Custom Scan (ParadeDB Scan) on products p
                           Table: products
                           Index: products_idx
                           Exec Method: MixedFastFieldExecState
                           Fast Fields: name, id, price
                           String Fast Fields: name
                           Numeric Fast Fields: id, price
                           Scores: false
                           Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"name","query_string":"Product","lenient":null,"conjunction_mode":null}}}}
(21 rows)

SELECT p.name, p.price, c.name as category
FROM products p
JOIN product_categories pc ON p.id = pc.product_id
JOIN categories c ON pc.category_id = c.id
WHERE p.name @@@ 'Product' AND c.is_active = true
ORDER BY p.price DESC
LIMIT 10;
    name     | price |    category    
-------------+-------+----------------
 Product 100 |  1050 | Electronics
 Product 99  |  1040 | Toys
 Product 99  |  1040 | Outdoors
 Product 98  |  1030 | Office
 Product 97  |  1020 | Automotive
 Product 96  |  1010 | Books
 Product 95  |  1000 | Sports
 Product 94  |   990 | Toys
 Product 93  |   980 | Home & Kitchen
 Product 93  |   980 | Office
(10 rows)

-- Test 2: Join between products and reviews with search
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT p.name, r.rating, r.content
FROM products p
JOIN reviews r ON p.id = r.product_id
WHERE p.description @@@ 'product' AND r.rating >= 4
ORDER BY r.helpful_votes DESC
LIMIT 5;
                                                                                   QUERY PLAN                                                                                   
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   ->  Sort
         Sort Key: r.helpful_votes DESC
         ->  Hash Join
               Hash Cond: (r.product_id = p.id)
               ->  Seq Scan on reviews r
                     Filter: (rating >= 4)
               ->  Hash
                     ->  Custom Scan (ParadeDB Scan) on products p
                           Table: products
                           Index: products_idx
                           Exec Method: MixedFastFieldExecState
                           Fast Fields: name, id
                           String Fast Fields: name
                           Numeric Fast Fields: id
                           Scores: false
                           Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"product","lenient":null,"conjunction_mode":null}}}}
(17 rows)

SELECT p.name, r.rating, r.content
FROM products p
JOIN reviews r ON p.id = r.product_id
WHERE p.description @@@ 'product' AND r.rating >= 4
ORDER BY r.helpful_votes DESC
LIMIT 5;
    name    | rating |                  content                   
------------+--------+--------------------------------------------
 Product 10 |      5 | Terrible product, complete waste of money!
 Product 20 |      5 | Terrible product, complete waste of money!
 Product 10 |      5 | Terrible product, complete waste of money!
 Product 20 |      5 | Terrible product, complete waste of money!
 Product 9  |      4 | Not very impressed, could be better.
(5 rows)

-- Test 3: Three-way join with mixed field conditions
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT p.name, c.name as category, AVG(r.rating) as avg_rating
FROM products p
JOIN product_categories pc ON p.id = pc.product_id
JOIN categories c ON pc.category_id = c.id
JOIN reviews r ON p.id = r.product_id
WHERE p.price < 500 AND c.product_count > 10 AND p.name @@@ 'Product'
GROUP BY p.name, c.name
HAVING AVG(r.rating) > 3
ORDER BY avg_rating, paradedb.score(p.id) DESC;
ERROR:  column "p.id" must appear in the GROUP BY clause or be used in an aggregate function at character 412
SELECT p.name, c.name as category, AVG(r.rating) as avg_rating
FROM products p
JOIN product_categories pc ON p.id = pc.product_id
JOIN categories c ON pc.category_id = c.id
JOIN reviews r ON p.id = r.product_id
WHERE p.price < 500 AND c.product_count > 10 AND p.name @@@ 'Product'
GROUP BY p.name, c.name
HAVING AVG(r.rating) > 3
ORDER BY avg_rating, paradedb.score(p.id) DESC;
ERROR:  column "p.id" must appear in the GROUP BY clause or be used in an aggregate function at character 367
-- Test 4: Complex query with multiple indices and mixed fields
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
WITH top_products AS (
    SELECT p.id, p.name, p.price, p.stock_count
    FROM products p
    WHERE p.price BETWEEN 100 AND 800
      AND p.is_available = true
      AND p.name @@@ 'Product'
    ORDER BY p.price DESC
    LIMIT 50
),
product_ratings AS (
    SELECT r.product_id, AVG(r.rating) as avg_rating, COUNT(*) as review_count
    FROM reviews r
    WHERE r.rating >= 3
    GROUP BY r.product_id
    HAVING COUNT(*) >= 2
)
SELECT tp.name, tp.price, pr.avg_rating, c.name as category
FROM top_products tp
JOIN product_ratings pr ON tp.id = pr.product_id
JOIN product_categories pc ON tp.id = pc.product_id
JOIN categories c ON pc.category_id = c.id
WHERE c.is_active = true
ORDER BY pr.avg_rating DESC, paradedb.score(tp.id), tp.price DESC;
                                                                                                                                                                                                                                   QUERY PLAN                                                                                                                                                                                                                                    
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: pr.avg_rating DESC, (paradedb.score(tp.id)), tp.price DESC
   ->  Hash Join
         Hash Cond: (pr.product_id = tp.id)
         ->  Hash Join
               Hash Cond: (pc.category_id = c.id)
               ->  Hash Join
                     Hash Cond: (pc.product_id = pr.product_id)
                     ->  Seq Scan on product_categories pc
                     ->  Hash
                           ->  Subquery Scan on pr
                                 ->  HashAggregate
                                       Group Key: r.product_id
                                       Filter: (count(*) >= 2)
                                       ->  Seq Scan on reviews r
                                             Filter: (rating >= 3)
               ->  Hash
                     ->  Seq Scan on categories c
                           Filter: is_active
         ->  Hash
               ->  Subquery Scan on tp
                     ->  Limit
                           ->  Custom Scan (ParadeDB Scan) on products p
                                 Table: products
                                 Index: products_idx
                                 Exec Method: TopNScanExecState
                                 Scores: false
                                    Sort Field: price
                                    Sort Direction: desc
                                    Top N Limit: 50
                                 Tantivy Query: {"boolean":{"must":[{"range":{"field":"price","lower_bound":{"included":100.0},"upper_bound":null,"is_datetime":false}},{"range":{"field":"price","lower_bound":null,"upper_bound":{"included":800.0},"is_datetime":false}},{"term":{"field":"is_available","value":true,"is_datetime":false}},{"with_index":{"query":{"parse_with_field":{"field":"name","query_string":"Product","lenient":null,"conjunction_mode":null}}}}]}}
(31 rows)

WITH top_products AS (
    SELECT p.id, p.name, p.price, p.stock_count
    FROM products p
    WHERE p.price BETWEEN 100 AND 800
      AND p.is_available = true
      AND p.name @@@ 'Product'
    ORDER BY p.price DESC
    LIMIT 50
),
product_ratings AS (
    SELECT r.product_id, AVG(r.rating) as avg_rating, COUNT(*) as review_count
    FROM reviews r
    WHERE r.rating >= 3
    GROUP BY r.product_id
    HAVING COUNT(*) >= 2
)
SELECT tp.name, tp.price, pr.avg_rating, c.name as category
FROM top_products tp
JOIN product_ratings pr ON tp.id = pr.product_id
JOIN product_categories pc ON tp.id = pc.product_id
JOIN categories c ON pc.category_id = c.id
WHERE c.is_active = true
ORDER BY pr.avg_rating DESC, paradedb.score(tp.id), tp.price DESC;
    name    | price |     avg_rating     |    category    
------------+-------+--------------------+----------------
 Product 19 |   240 | 4.0000000000000000 | Outdoors
 Product 14 |   190 | 4.0000000000000000 | Toys
 Product 18 |   230 | 3.0000000000000000 | Office
 Product 18 |   230 | 3.0000000000000000 | Home & Kitchen
 Product 18 |   230 | 3.0000000000000000 | Sports
 Product 13 |   180 | 3.0000000000000000 | Home & Kitchen
(6 rows)

-- Test 5: Union of results from different tables
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT 'Product' as type, name as item_name, description as content
FROM products
WHERE name @@@ '10' OR description @@@ 'feature'
UNION ALL
SELECT 'Category' as type, name as item_name, description as content
FROM categories
WHERE name @@@ 'e'
UNION ALL
SELECT 'Review' as type, reviewer_name as item_name, content
FROM reviews
WHERE content @@@ 'great'
ORDER BY type, item_name;
                                                                                                                                                      QUERY PLAN                                                                                                                                                       
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: ('Product'::text), products.name
   ->  Append
         ->  Custom Scan (ParadeDB Scan) on products
               Table: products
               Index: products_idx
               Exec Method: NormalScanExecState
               Scores: false
               Tantivy Query: {"boolean":{"should":[{"with_index":{"query":{"parse_with_field":{"field":"name","query_string":"10","lenient":null,"conjunction_mode":null}}}},{"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"feature","lenient":null,"conjunction_mode":null}}}}]}}
         ->  Custom Scan (ParadeDB Scan) on categories
               Table: categories
               Index: categories_idx
               Exec Method: NormalScanExecState
               Scores: false
               Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"name","query_string":"e","lenient":null,"conjunction_mode":null}}}}
         ->  Custom Scan (ParadeDB Scan) on reviews
               Table: reviews
               Index: reviews_idx
               Exec Method: NormalScanExecState
               Scores: false
               Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"content","query_string":"great","lenient":null,"conjunction_mode":null}}}}
(21 rows)

SELECT 'Product' as type, name as item_name, description as content
FROM products
WHERE name @@@ '10' OR description @@@ 'feature'
UNION ALL
SELECT 'Category' as type, name as item_name, description as content
FROM categories
WHERE name @@@ 'e'
UNION ALL
SELECT 'Review' as type, reviewer_name as item_name, content
FROM reviews
WHERE content @@@ 'great'
ORDER BY type, item_name;
  type   |  item_name  |                                      content                                      
---------+-------------+-----------------------------------------------------------------------------------
 Product | Product 10  | Description for product 10. This product has various features and specifications.
 Review  | Reviewer 1  | Great product, very satisfied with my purchase!
 Review  | Reviewer 1  | Great product, very satisfied with my purchase!
 Review  | Reviewer 1  | Great product, very satisfied with my purchase!
 Review  | Reviewer 1  | Great product, very satisfied with my purchase!
 Review  | Reviewer 11 | Great product, very satisfied with my purchase!
 Review  | Reviewer 11 | Great product, very satisfied with my purchase!
 Review  | Reviewer 11 | Great product, very satisfied with my purchase!
 Review  | Reviewer 11 | Great product, very satisfied with my purchase!
 Review  | Reviewer 16 | Great product, very satisfied with my purchase!
 Review  | Reviewer 16 | Great product, very satisfied with my purchase!
 Review  | Reviewer 16 | Great product, very satisfied with my purchase!
 Review  | Reviewer 16 | Great product, very satisfied with my purchase!
 Review  | Reviewer 21 | Great product, very satisfied with my purchase!
 Review  | Reviewer 21 | Great product, very satisfied with my purchase!
 Review  | Reviewer 21 | Great product, very satisfied with my purchase!
 Review  | Reviewer 21 | Great product, very satisfied with my purchase!
 Review  | Reviewer 26 | Great product, very satisfied with my purchase!
 Review  | Reviewer 26 | Great product, very satisfied with my purchase!
 Review  | Reviewer 26 | Great product, very satisfied with my purchase!
 Review  | Reviewer 26 | Great product, very satisfied with my purchase!
 Review  | Reviewer 31 | Great product, very satisfied with my purchase!
 Review  | Reviewer 31 | Great product, very satisfied with my purchase!
 Review  | Reviewer 31 | Great product, very satisfied with my purchase!
 Review  | Reviewer 31 | Great product, very satisfied with my purchase!
 Review  | Reviewer 36 | Great product, very satisfied with my purchase!
 Review  | Reviewer 36 | Great product, very satisfied with my purchase!
 Review  | Reviewer 36 | Great product, very satisfied with my purchase!
 Review  | Reviewer 36 | Great product, very satisfied with my purchase!
 Review  | Reviewer 41 | Great product, very satisfied with my purchase!
 Review  | Reviewer 41 | Great product, very satisfied with my purchase!
 Review  | Reviewer 41 | Great product, very satisfied with my purchase!
 Review  | Reviewer 41 | Great product, very satisfied with my purchase!
 Review  | Reviewer 46 | Great product, very satisfied with my purchase!
 Review  | Reviewer 46 | Great product, very satisfied with my purchase!
 Review  | Reviewer 46 | Great product, very satisfied with my purchase!
 Review  | Reviewer 46 | Great product, very satisfied with my purchase!
 Review  | Reviewer 6  | Great product, very satisfied with my purchase!
 Review  | Reviewer 6  | Great product, very satisfied with my purchase!
 Review  | Reviewer 6  | Great product, very satisfied with my purchase!
 Review  | Reviewer 6  | Great product, very satisfied with my purchase!
(41 rows)

-- Test 6: Subquery with both numeric and text field filtering
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT p.name, p.price, p.stock_count
FROM products p
WHERE p.id IN (
    SELECT pc.product_id
    FROM product_categories pc
    JOIN categories c ON pc.category_id = c.id
    WHERE c.name @@@ 'electronics OR clothing'
)
AND p.stock_count > 50
AND p.price < 500
ORDER BY p.price;
                                                                                       QUERY PLAN                                                                                        
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: p.price
   ->  Nested Loop Semi Join
         ->  Seq Scan on products p
               Filter: ((stock_count > 50) AND (price < '500'::double precision))
         ->  Hash Join
               Hash Cond: (pc.category_id = c.id)
               ->  Bitmap Heap Scan on product_categories pc
                     Recheck Cond: (p.id = product_id)
                     ->  Bitmap Index Scan on product_categories_pkey
                           Index Cond: (product_id = p.id)
               ->  Hash
                     ->  Custom Scan (ParadeDB Scan) on categories c
                           Table: categories
                           Index: categories_idx
                           Exec Method: NumericFastFieldExecState
                           Fast Fields: id
                           Scores: false
                           Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"name","query_string":"electronics OR clothing","lenient":null,"conjunction_mode":null}}}}
(19 rows)

SELECT p.name, p.price, p.stock_count
FROM products p
WHERE p.id IN (
    SELECT pc.product_id
    FROM product_categories pc
    JOIN categories c ON pc.category_id = c.id
    WHERE c.name @@@ 'electronics OR clothing'
)
AND p.stock_count > 50
AND p.price < 500
ORDER BY p.price;
    name    | price | stock_count 
------------+-------+-------------
 Product 27 |   320 |          54
 Product 30 |   350 |          60
 Product 32 |   370 |          64
 Product 40 |   450 |          80
 Product 42 |   470 |          84
(5 rows)

-- Test 7: Join with conditional logic and mixed fields
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT 
    p.name,
    p.price,
    CASE 
        WHEN r.rating IS NULL THEN 'No reviews'
        WHEN r.rating < 3 THEN 'Poor reviews'
        WHEN r.rating < 4 THEN 'Average reviews'
        ELSE 'Great reviews'
    END as review_status
FROM products p
LEFT JOIN (
    SELECT product_id, AVG(rating) as rating
    FROM reviews
    GROUP BY product_id
) r ON p.id = r.product_id
WHERE p.is_available = true
  AND p.price BETWEEN 200 AND 600
  AND p.name @@@ 'Product'
ORDER BY 
    CASE 
        WHEN r.rating IS NULL THEN 0
        ELSE r.rating
    END DESC,
    paradedb.score(p.id),
    p.price;
                                                                                                                                                                                                                             QUERY PLAN                                                                                                                                                                                                                              
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: (CASE WHEN ((avg(reviews.rating)) IS NULL) THEN '0'::numeric ELSE (avg(reviews.rating)) END) DESC, (paradedb.score(p.id)), p.price
   ->  Hash Right Join
         Hash Cond: (reviews.product_id = p.id)
         ->  HashAggregate
               Group Key: reviews.product_id
               ->  Seq Scan on reviews
         ->  Hash
               ->  Custom Scan (ParadeDB Scan) on products p
                     Table: products
                     Index: products_idx
                     Exec Method: NormalScanExecState
                     Scores: true
                     Tantivy Query: {"boolean":{"must":[{"term":{"field":"is_available","value":true,"is_datetime":false}},{"range":{"field":"price","lower_bound":{"included":200.0},"upper_bound":null,"is_datetime":false}},{"range":{"field":"price","lower_bound":null,"upper_bound":{"included":600.0},"is_datetime":false}},{"with_index":{"query":{"parse_with_field":{"field":"name","query_string":"Product","lenient":null,"conjunction_mode":null}}}}]}}
(14 rows)

SELECT 
    p.name,
    p.price,
    CASE 
        WHEN r.rating IS NULL THEN 'No reviews'
        WHEN r.rating < 3 THEN 'Poor reviews'
        WHEN r.rating < 4 THEN 'Average reviews'
        ELSE 'Great reviews'
    END as review_status
FROM products p
LEFT JOIN (
    SELECT product_id, AVG(rating) as rating
    FROM reviews
    GROUP BY product_id
) r ON p.id = r.product_id
WHERE p.is_available = true
  AND p.price BETWEEN 200 AND 600
  AND p.name @@@ 'Product'
ORDER BY 
    CASE 
        WHEN r.rating IS NULL THEN 0
        ELSE r.rating
    END DESC,
    paradedb.score(p.id),
    p.price;
    name    | price |  review_status  
------------+-------+-----------------
 Product 19 |   240 | Great reviews
 Product 18 |   230 | Average reviews
 Product 17 |   220 | Poor reviews
 Product 16 |   210 | Poor reviews
 Product 21 |   260 | No reviews
 Product 22 |   270 | No reviews
 Product 23 |   280 | No reviews
 Product 24 |   290 | No reviews
 Product 26 |   310 | No reviews
 Product 27 |   320 | No reviews
 Product 28 |   330 | No reviews
 Product 29 |   340 | No reviews
 Product 31 |   360 | No reviews
 Product 32 |   370 | No reviews
 Product 33 |   380 | No reviews
 Product 34 |   390 | No reviews
 Product 36 |   410 | No reviews
 Product 37 |   420 | No reviews
 Product 38 |   430 | No reviews
 Product 39 |   440 | No reviews
 Product 41 |   460 | No reviews
 Product 42 |   470 | No reviews
 Product 43 |   480 | No reviews
 Product 44 |   490 | No reviews
 Product 46 |   510 | No reviews
 Product 47 |   520 | No reviews
 Product 48 |   530 | No reviews
 Product 49 |   540 | No reviews
 Product 51 |   560 | No reviews
 Product 52 |   570 | No reviews
 Product 53 |   580 | No reviews
 Product 54 |   590 | No reviews
(32 rows)

-- Test 8: Multi-index intersection
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT p.name, p.price, r.content, r.rating
FROM products p
JOIN reviews r ON p.id = r.product_id
JOIN product_categories pc ON p.id = pc.product_id
JOIN categories c ON pc.category_id = c.id
WHERE p.name @@@ 'Product'
  AND r.rating > 3
  AND c.name = 'Electronics'
  AND p.is_available = true
ORDER BY r.rating DESC, p.price DESC;
                                                                                                                               QUERY PLAN                                                                                                                                
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: r.rating DESC, p.price DESC
   ->  Hash Join
         Hash Cond: (pc.product_id = p.id)
         ->  Nested Loop
               ->  Seq Scan on categories c
                     Filter: (name = 'Electronics'::text)
               ->  Bitmap Heap Scan on product_categories pc
                     Recheck Cond: (category_id = c.id)
                     ->  Bitmap Index Scan on product_categories_pkey
                           Index Cond: (category_id = c.id)
         ->  Hash
               ->  Hash Join
                     Hash Cond: (r.product_id = p.id)
                     ->  Seq Scan on reviews r
                           Filter: (rating > 3)
                     ->  Hash
                           ->  Custom Scan (ParadeDB Scan) on products p
                                 Table: products
                                 Index: products_idx
                                 Exec Method: MixedFastFieldExecState
                                 Fast Fields: name, id, price
                                 String Fast Fields: name
                                 Numeric Fast Fields: id, price
                                 Scores: false
                                 Tantivy Query: {"boolean":{"must":[{"with_index":{"query":{"parse_with_field":{"field":"name","query_string":"Product","lenient":null,"conjunction_mode":null}}}},{"term":{"field":"is_available","value":true,"is_datetime":false}}]}}
(26 rows)

SELECT p.name, p.price, r.content, r.rating
FROM products p
JOIN reviews r ON p.id = r.product_id
JOIN product_categories pc ON p.id = pc.product_id
JOIN categories c ON pc.category_id = c.id
WHERE p.name @@@ 'Product'
  AND r.rating > 3
  AND c.name = 'Electronics'
  AND p.is_available = true
ORDER BY r.rating DESC, p.price DESC;
 name | price | content | rating 
------+-------+---------+--------
(0 rows)

-- Verify actual results of multi-index search
SELECT p.name, p.price, c.name as category
FROM products p
JOIN product_categories pc ON p.id = pc.product_id
JOIN categories c ON pc.category_id = c.id
WHERE p.name @@@ 'Product 1'
  AND c.is_active = true
ORDER BY p.price DESC
LIMIT 5;
    name     | price |  category   
-------------+-------+-------------
 Product 100 |  1050 | Electronics
 Product 99  |  1040 | Toys
 Product 99  |  1040 | Outdoors
 Product 98  |  1030 | Office
 Product 97  |  1020 | Automotive
(5 rows)

-- Clean up
DROP INDEX IF EXISTS products_idx;
DROP INDEX IF EXISTS categories_idx;
DROP INDEX IF EXISTS reviews_idx;
DROP TABLE IF EXISTS product_categories;
DROP TABLE IF EXISTS reviews;
DROP TABLE IF EXISTS products;
DROP TABLE IF EXISTS categories; 
\i common/mixedff_advanced_cleanup.sql 
-- Cleanup for advanced features tests (13-21)
-- Drop the tables used in these tests (in reverse order to handle dependencies)
DROP TABLE IF EXISTS conversion_test CASCADE;
DROP TABLE IF EXISTS products CASCADE;
DROP TABLE IF EXISTS categories CASCADE;
DROP TABLE IF EXISTS pages CASCADE;
DROP TABLE IF EXISTS files CASCADE;
DROP TABLE IF EXISTS documents CASCADE;
DROP TABLE IF EXISTS mixed_numeric_string_test CASCADE;
DROP INDEX IF EXISTS union_test_a_idx CASCADE;
DROP INDEX IF EXISTS union_test_b_idx CASCADE;
DROP TABLE IF EXISTS union_test_a CASCADE;
DROP TABLE IF EXISTS union_test_b CASCADE; 
-- Reset parallel workers setting to default
RESET max_parallel_workers_per_gather;
RESET enable_indexscan;
RESET paradedb.enable_mixed_fast_field_exec;
RESET paradedb.mixed_fast_field_exec_column_threshold;
SELECT 'Advanced features tests cleanup complete' AS status; 
                  status                  
------------------------------------------
 Advanced features tests cleanup complete
(1 row)

