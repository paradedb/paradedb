-- Comprehensive tests for sort_by option in CREATE INDEX
-- Covers: syntax validation, sorted fetch, sawtooth patterns, errors
\i common/common_setup.sql
CREATE EXTENSION IF NOT EXISTS pg_search;
-- Disable parallel workers to avoid differences in plans
SET max_parallel_workers_per_gather = 0;
SET enable_indexscan to OFF;
SET paradedb.enable_mixed_fast_field_exec = true;
-- ============================================================================
-- SECTION 1: Basic syntax validation
-- ============================================================================
\echo '=== SECTION 1: Basic syntax validation ==='
=== SECTION 1: Basic syntax validation ===
DROP TABLE IF EXISTS sort_by_test CASCADE;
CREATE TABLE sort_by_test (
    id SERIAL PRIMARY KEY,
    name TEXT,
    score INTEGER,
    created_at TIMESTAMP
);
INSERT INTO sort_by_test (name, score, created_at) VALUES
    ('Alice', 100, '2023-01-01'),
    ('Bob', 200, '2023-06-01'),
    ('Charlie', 150, '2023-12-01');
-- Test 1.1: sort_by with ASC
\echo 'Test 1.1: sort_by with id ASC'
Test 1.1: sort_by with id ASC
CREATE INDEX sort_by_test_idx ON sort_by_test
    USING bm25 (id, name, score)
    WITH (key_field='id', sort_by='id ASC');
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name FROM sort_by_test WHERE sort_by_test @@@ 'name:Alice OR name:Bob' ORDER BY id;
                                                                             QUERY PLAN                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: id
   ->  Custom Scan (ParadeDB Scan) on sort_by_test
         Table: sort_by_test
         Index: sort_by_test_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"id","query_string":"name:Alice OR name:Bob","lenient":null,"conjunction_mode":null}}}}
(8 rows)

SELECT id, name FROM sort_by_test WHERE sort_by_test @@@ 'name:Alice OR name:Bob' ORDER BY id;
 id | name  
----+-------
  1 | Alice
  2 | Bob
(2 rows)

DROP INDEX sort_by_test_idx;
-- Test 1.2: sort_by with DESC
\echo 'Test 1.2: sort_by with id DESC'
Test 1.2: sort_by with id DESC
CREATE INDEX sort_by_test_idx ON sort_by_test
    USING bm25 (id, name, score)
    WITH (key_field='id', sort_by='id DESC');
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name FROM sort_by_test WHERE sort_by_test @@@ 'name:Alice OR name:Bob' ORDER BY id;
                                                                             QUERY PLAN                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: id
   ->  Custom Scan (ParadeDB Scan) on sort_by_test
         Table: sort_by_test
         Index: sort_by_test_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"id","query_string":"name:Alice OR name:Bob","lenient":null,"conjunction_mode":null}}}}
(8 rows)

SELECT id, name FROM sort_by_test WHERE sort_by_test @@@ 'name:Alice OR name:Bob' ORDER BY id;
 id | name  
----+-------
  1 | Alice
  2 | Bob
(2 rows)

DROP INDEX sort_by_test_idx;
-- Test 1.3: sort_by = 'none'
\echo 'Test 1.3: sort_by = none (disables segment sorting)'
Test 1.3: sort_by = none (disables segment sorting)
CREATE INDEX sort_by_test_idx ON sort_by_test
    USING bm25 (id, name, score)
    WITH (key_field='id', sort_by='none');
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name FROM sort_by_test WHERE sort_by_test @@@ 'name:Alice' ORDER BY id;
                                                                       QUERY PLAN                                                                       
--------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: id
   ->  Custom Scan (ParadeDB Scan) on sort_by_test
         Table: sort_by_test
         Index: sort_by_test_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"id","query_string":"name:Alice","lenient":null,"conjunction_mode":null}}}}
(8 rows)

SELECT id, name FROM sort_by_test WHERE sort_by_test @@@ 'name:Alice' ORDER BY id;
 id | name  
----+-------
  1 | Alice
(1 row)

DROP INDEX sort_by_test_idx;
DROP TABLE sort_by_test CASCADE;
-- ============================================================================
-- SECTION 2: Single segment sorted fetch
-- ============================================================================
\echo '=== SECTION 2: Single segment sorted fetch ==='
=== SECTION 2: Single segment sorted fetch ===
DROP TABLE IF EXISTS sort_by_test CASCADE;
CREATE TABLE sort_by_test (
    id SERIAL PRIMARY KEY,
    name TEXT,
    score INTEGER
);
-- Insert data in RANDOM order (not sorted by score)
INSERT INTO sort_by_test (name, score) VALUES
    ('Charlie', 50),
    ('Alice', 100),
    ('Eve', 30),
    ('Bob', 80),
    ('Diana', 60);
-- Test 2.1: sort_by score DESC - verify Tantivy returns sorted
\echo 'Test 2.1: sort_by score DESC - single segment'
Test 2.1: sort_by score DESC - single segment
CREATE INDEX sort_by_test_idx ON sort_by_test
    USING bm25 (id, name, score)
    WITH (key_field='id', sort_by='score DESC');
\echo 'Query without ORDER BY - should return in segment sorted order (DESC)'
Query without ORDER BY - should return in segment sorted order (DESC)
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name, score FROM sort_by_test
WHERE sort_by_test @@@ 'name:Alice OR name:Bob OR name:Charlie OR name:Diana OR name:Eve';
                                                                                               QUERY PLAN                                                                                               
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ParadeDB Scan) on sort_by_test
   Table: sort_by_test
   Index: sort_by_test_idx
   Exec Method: NormalScanExecState
   Scores: false
   Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"id","query_string":"name:Alice OR name:Bob OR name:Charlie OR name:Diana OR name:Eve","lenient":null,"conjunction_mode":null}}}}
(6 rows)

SELECT id, name, score FROM sort_by_test
WHERE sort_by_test @@@ 'name:Alice OR name:Bob OR name:Charlie OR name:Diana OR name:Eve';
 id |  name   | score 
----+---------+-------
  2 | Alice   |   100
  4 | Bob     |    80
  5 | Diana   |    60
  1 | Charlie |    50
  3 | Eve     |    30
(5 rows)

\echo 'Query with ORDER BY score DESC (matches sort_by)'
Query with ORDER BY score DESC (matches sort_by)
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name, score FROM sort_by_test
WHERE sort_by_test @@@ 'name:Alice OR name:Bob OR name:Charlie OR name:Diana OR name:Eve'
ORDER BY score DESC;
                                                                                                  QUERY PLAN                                                                                                  
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: score DESC
   ->  Custom Scan (ParadeDB Scan) on sort_by_test
         Table: sort_by_test
         Index: sort_by_test_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"id","query_string":"name:Alice OR name:Bob OR name:Charlie OR name:Diana OR name:Eve","lenient":null,"conjunction_mode":null}}}}
(8 rows)

SELECT id, name, score FROM sort_by_test
WHERE sort_by_test @@@ 'name:Alice OR name:Bob OR name:Charlie OR name:Diana OR name:Eve'
ORDER BY score DESC;
 id |  name   | score 
----+---------+-------
  2 | Alice   |   100
  4 | Bob     |    80
  5 | Diana   |    60
  1 | Charlie |    50
  3 | Eve     |    30
(5 rows)

\echo 'Query with ORDER BY score ASC (opposite of sort_by)'
Query with ORDER BY score ASC (opposite of sort_by)
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name, score FROM sort_by_test
WHERE sort_by_test @@@ 'name:Alice OR name:Bob OR name:Charlie OR name:Diana OR name:Eve'
ORDER BY score ASC;
                                                                                                  QUERY PLAN                                                                                                  
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: score
   ->  Custom Scan (ParadeDB Scan) on sort_by_test
         Table: sort_by_test
         Index: sort_by_test_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"id","query_string":"name:Alice OR name:Bob OR name:Charlie OR name:Diana OR name:Eve","lenient":null,"conjunction_mode":null}}}}
(8 rows)

SELECT id, name, score FROM sort_by_test
WHERE sort_by_test @@@ 'name:Alice OR name:Bob OR name:Charlie OR name:Diana OR name:Eve'
ORDER BY score ASC;
 id |  name   | score 
----+---------+-------
  3 | Eve     |    30
  1 | Charlie |    50
  5 | Diana   |    60
  4 | Bob     |    80
  2 | Alice   |   100
(5 rows)

\echo 'Query with ORDER BY score DESC LIMIT 3'
Query with ORDER BY score DESC LIMIT 3
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name, score FROM sort_by_test
WHERE sort_by_test @@@ 'name:Alice OR name:Bob OR name:Charlie OR name:Diana OR name:Eve'
ORDER BY score DESC
LIMIT 3;
                                                                                                  QUERY PLAN                                                                                                  
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   ->  Custom Scan (ParadeDB Scan) on sort_by_test
         Table: sort_by_test
         Index: sort_by_test_idx
         Exec Method: TopNScanExecState
         Scores: false
            TopN Order By: score desc
            TopN Limit: 3
         Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"id","query_string":"name:Alice OR name:Bob OR name:Charlie OR name:Diana OR name:Eve","lenient":null,"conjunction_mode":null}}}}
(9 rows)

SELECT id, name, score FROM sort_by_test
WHERE sort_by_test @@@ 'name:Alice OR name:Bob OR name:Charlie OR name:Diana OR name:Eve'
ORDER BY score DESC
LIMIT 3;
 id | name  | score 
----+-------+-------
  2 | Alice |   100
  4 | Bob   |    80
  5 | Diana |    60
(3 rows)

DROP INDEX sort_by_test_idx;
-- Test 2.2: sort_by score ASC
\echo 'Test 2.2: sort_by score ASC - single segment'
Test 2.2: sort_by score ASC - single segment
CREATE INDEX sort_by_test_idx ON sort_by_test
    USING bm25 (id, name, score)
    WITH (key_field='id', sort_by='score ASC');
\echo 'Query without ORDER BY - should return in ASC order'
Query without ORDER BY - should return in ASC order
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, name, score FROM sort_by_test
WHERE sort_by_test @@@ 'name:Alice OR name:Bob OR name:Charlie OR name:Diana OR name:Eve';
                                                                                               QUERY PLAN                                                                                               
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ParadeDB Scan) on sort_by_test
   Table: sort_by_test
   Index: sort_by_test_idx
   Exec Method: NormalScanExecState
   Scores: false
   Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"id","query_string":"name:Alice OR name:Bob OR name:Charlie OR name:Diana OR name:Eve","lenient":null,"conjunction_mode":null}}}}
(6 rows)

SELECT id, name, score FROM sort_by_test
WHERE sort_by_test @@@ 'name:Alice OR name:Bob OR name:Charlie OR name:Diana OR name:Eve';
 id |  name   | score 
----+---------+-------
  3 | Eve     |    30
  1 | Charlie |    50
  5 | Diana   |    60
  4 | Bob     |    80
  2 | Alice   |   100
(5 rows)

DROP TABLE sort_by_test CASCADE;
-- ============================================================================
-- SECTION 3: Multi-segment sawtooth pattern
-- ============================================================================
\echo '=== SECTION 3: Multi-segment sawtooth pattern ==='
=== SECTION 3: Multi-segment sawtooth pattern ===
DROP TABLE IF EXISTS sort_by_test CASCADE;
CREATE TABLE sort_by_test (
    id SERIAL PRIMARY KEY,
    category TEXT,
    score INTEGER
);
-- Insert first batch
INSERT INTO sort_by_test (category, score) VALUES
    ('A', 100), ('A', 90), ('A', 80), ('A', 70), ('A', 60);
-- Create index with sort_by score DESC
CREATE INDEX sort_by_test_idx ON sort_by_test
    USING bm25 (id, category, score)
    WITH (key_field='id', sort_by='score DESC');
\echo 'Segment count after first batch:'
Segment count after first batch:
SELECT count(*) as segment_count FROM paradedb.index_info('sort_by_test_idx');
 segment_count 
---------------
             1
(1 row)

-- Insert second batch (creates second segment)
INSERT INTO sort_by_test (category, score) VALUES
    ('A', 95), ('A', 85), ('A', 75), ('A', 65), ('A', 55);
\echo 'Segment count after second batch:'
Segment count after second batch:
SELECT count(*) as segment_count FROM paradedb.index_info('sort_by_test_idx');
 segment_count 
---------------
             2
(1 row)

-- Parameterized test helper function for ORDER BY variations
CREATE OR REPLACE FUNCTION test_sort_by_order(
    test_name TEXT,
    order_clause TEXT DEFAULT ''
) RETURNS SETOF RECORD AS $$
BEGIN
    RAISE NOTICE '%', test_name;
    RETURN QUERY EXECUTE format(
        'SELECT id, category, score FROM sort_by_test WHERE sort_by_test @@@ ''category:A'' %s',
        order_clause
    );
END;
$$ LANGUAGE plpgsql;
-- Test 3.1: Sawtooth pattern with DESC
\echo 'Test 3.1: Query without ORDER BY shows sawtooth pattern (DESC)'
Test 3.1: Query without ORDER BY shows sawtooth pattern (DESC)
\echo 'Expected: seg2 [95,85,75,65,55] then seg1 [100,90,80,70,60]'
Expected: seg2 [95,85,75,65,55] then seg1 [100,90,80,70,60]
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, category, score FROM sort_by_test
WHERE sort_by_test @@@ 'category:A';
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ParadeDB Scan) on sort_by_test
   Table: sort_by_test
   Index: sort_by_test_idx
   Exec Method: NormalScanExecState
   Scores: false
   Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"id","query_string":"category:A","lenient":null,"conjunction_mode":null}}}}
(6 rows)

SELECT * FROM test_sort_by_order('Test 3.1', '') AS t(id INT, category TEXT, score INT);
 id | category | score 
----+----------+-------
  6 | A        |    95
  7 | A        |    85
  8 | A        |    75
  9 | A        |    65
 10 | A        |    55
  1 | A        |   100
  2 | A        |    90
  3 | A        |    80
  4 | A        |    70
  5 | A        |    60
(10 rows)

\echo 'Test 3.2: Query with ORDER BY score DESC (matches sort_by) - global sort'
Test 3.2: Query with ORDER BY score DESC (matches sort_by) - global sort
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, category, score FROM sort_by_test
WHERE sort_by_test @@@ 'category:A'
ORDER BY score DESC;
                                                                       QUERY PLAN                                                                       
--------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: score DESC
   ->  Custom Scan (ParadeDB Scan) on sort_by_test
         Table: sort_by_test
         Index: sort_by_test_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"id","query_string":"category:A","lenient":null,"conjunction_mode":null}}}}
(8 rows)

SELECT * FROM test_sort_by_order('Test 3.2', 'ORDER BY score DESC') AS t(id INT, category TEXT, score INT);
 id | category | score 
----+----------+-------
  1 | A        |   100
  6 | A        |    95
  2 | A        |    90
  7 | A        |    85
  3 | A        |    80
  8 | A        |    75
  4 | A        |    70
  9 | A        |    65
  5 | A        |    60
 10 | A        |    55
(10 rows)

\echo 'Test 3.3: Query with ORDER BY score ASC (opposite of sort_by)'
Test 3.3: Query with ORDER BY score ASC (opposite of sort_by)
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, category, score FROM sort_by_test
WHERE sort_by_test @@@ 'category:A'
ORDER BY score ASC;
                                                                       QUERY PLAN                                                                       
--------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Sort Key: score
   ->  Custom Scan (ParadeDB Scan) on sort_by_test
         Table: sort_by_test
         Index: sort_by_test_idx
         Exec Method: NormalScanExecState
         Scores: false
         Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"id","query_string":"category:A","lenient":null,"conjunction_mode":null}}}}
(8 rows)

SELECT * FROM test_sort_by_order('Test 3.3', 'ORDER BY score ASC') AS t(id INT, category TEXT, score INT);
 id | category | score 
----+----------+-------
 10 | A        |    55
  5 | A        |    60
  9 | A        |    65
  4 | A        |    70
  8 | A        |    75
  3 | A        |    80
  7 | A        |    85
  2 | A        |    90
  6 | A        |    95
  1 | A        |   100
(10 rows)

DROP FUNCTION test_sort_by_order;
DROP TABLE sort_by_test CASCADE;
-- Test 3.4: Sawtooth pattern with ASC
\echo 'Test 3.4: Sawtooth pattern with ASC'
Test 3.4: Sawtooth pattern with ASC
DROP TABLE IF EXISTS sort_by_test CASCADE;
CREATE TABLE sort_by_test (
    id SERIAL PRIMARY KEY,
    category TEXT,
    score INTEGER
);
INSERT INTO sort_by_test (category, score) VALUES
    ('A', 60), ('A', 70), ('A', 80), ('A', 90), ('A', 100);
CREATE INDEX sort_by_test_idx ON sort_by_test
    USING bm25 (id, category, score)
    WITH (key_field='id', sort_by='score ASC');
INSERT INTO sort_by_test (category, score) VALUES
    ('A', 55), ('A', 65), ('A', 75), ('A', 85), ('A', 95);
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, category, score FROM sort_by_test
WHERE sort_by_test @@@ 'category:A';
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ParadeDB Scan) on sort_by_test
   Table: sort_by_test
   Index: sort_by_test_idx
   Exec Method: NormalScanExecState
   Scores: false
   Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"id","query_string":"category:A","lenient":null,"conjunction_mode":null}}}}
(6 rows)

SELECT id, category, score FROM sort_by_test
WHERE sort_by_test @@@ 'category:A';
 id | category | score 
----+----------+-------
  6 | A        |    55
  7 | A        |    65
  8 | A        |    75
  9 | A        |    85
 10 | A        |    95
  1 | A        |    60
  2 | A        |    70
  3 | A        |    80
  4 | A        |    90
  5 | A        |   100
(10 rows)

DROP TABLE sort_by_test CASCADE;
-- ============================================================================
-- SECTION 4: Default behavior (no sort_by specified)
-- ============================================================================
\echo '=== SECTION 4: Default behavior ==='
=== SECTION 4: Default behavior ===
-- Test 4.1: No sort_by specified (defaults to ctid ASC)
\echo 'Test 4.1: No sort_by specified - defaults to ctid ASC'
Test 4.1: No sort_by specified - defaults to ctid ASC
DROP TABLE IF EXISTS sort_by_test CASCADE;
CREATE TABLE sort_by_test (
    id SERIAL PRIMARY KEY,
    category TEXT,
    score INTEGER
);
INSERT INTO sort_by_test (category, score) VALUES
    ('A', 100), ('A', 90), ('A', 80);
CREATE INDEX sort_by_test_idx ON sort_by_test
    USING bm25 (id, category, score)
    WITH (key_field='id');
INSERT INTO sort_by_test (category, score) VALUES
    ('A', 95), ('A', 85), ('A', 75);
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, category, score FROM sort_by_test
WHERE sort_by_test @@@ 'category:A';
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ParadeDB Scan) on sort_by_test
   Table: sort_by_test
   Index: sort_by_test_idx
   Exec Method: NormalScanExecState
   Scores: false
   Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"id","query_string":"category:A","lenient":null,"conjunction_mode":null}}}}
(6 rows)

SELECT id, category, score FROM sort_by_test
WHERE sort_by_test @@@ 'category:A';
 id | category | score 
----+----------+-------
  4 | A        |    95
  5 | A        |    85
  6 | A        |    75
  1 | A        |   100
  2 | A        |    90
  3 | A        |    80
(6 rows)

DROP TABLE sort_by_test CASCADE;
-- Test 4.2: sort_by = 'none' (no segment sorting)
\echo 'Test 4.2: sort_by = none - no segment sorting'
Test 4.2: sort_by = none - no segment sorting
DROP TABLE IF EXISTS sort_by_test CASCADE;
CREATE TABLE sort_by_test (
    id SERIAL PRIMARY KEY,
    category TEXT,
    score INTEGER
);
INSERT INTO sort_by_test (category, score) VALUES
    ('A', 100), ('A', 90), ('A', 80);
CREATE INDEX sort_by_test_idx ON sort_by_test
    USING bm25 (id, category, score)
    WITH (key_field='id', sort_by='none');
INSERT INTO sort_by_test (category, score) VALUES
    ('A', 95), ('A', 85), ('A', 75);
EXPLAIN (FORMAT TEXT, COSTS OFF, TIMING OFF)
SELECT id, category, score FROM sort_by_test
WHERE sort_by_test @@@ 'category:A';
                                                                    QUERY PLAN                                                                    
--------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ParadeDB Scan) on sort_by_test
   Table: sort_by_test
   Index: sort_by_test_idx
   Exec Method: NormalScanExecState
   Scores: false
   Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"id","query_string":"category:A","lenient":null,"conjunction_mode":null}}}}
(6 rows)

SELECT id, category, score FROM sort_by_test
WHERE sort_by_test @@@ 'category:A';
 id | category | score 
----+----------+-------
  4 | A        |    95
  5 | A        |    85
  6 | A        |    75
  1 | A        |   100
  2 | A        |    90
  3 | A        |    80
(6 rows)

DROP TABLE sort_by_test CASCADE;
-- ============================================================================
-- SECTION 5: Error cases
-- ============================================================================
\echo '=== SECTION 5: Error cases ==='
=== SECTION 5: Error cases ===
DROP TABLE IF EXISTS sort_by_test CASCADE;
CREATE TABLE sort_by_test (
    id SERIAL PRIMARY KEY,
    name TEXT,
    score INTEGER
);
-- Test 5.1: Nonexistent field
\echo 'Test 5.1: sort_by with nonexistent field (should error)'
Test 5.1: sort_by with nonexistent field (should error)
CREATE INDEX sort_by_test_idx ON sort_by_test
    USING bm25 (id, name, score)
    WITH (key_field='id', sort_by='nonexistent ASC');
ERROR:  sort_by field 'nonexistent' does not exist in the index schema
-- Test 5.2: Non-fast field
\echo 'Test 5.2: sort_by with non-fast field (should error)'
Test 5.2: sort_by with non-fast field (should error)
CREATE INDEX sort_by_test_idx ON sort_by_test
    USING bm25 (id, name, score)
    WITH (key_field='id', sort_by='name ASC');
ERROR:  sort_by field 'name' must be a fast field. Add it to the index with 'fast: true'
-- Test 5.3: Invalid syntax
\echo 'Test 5.3: sort_by with invalid syntax (should error)'
Test 5.3: sort_by with invalid syntax (should error)
CREATE INDEX sort_by_test_idx ON sort_by_test
    USING bm25 (id, name, score)
    WITH (key_field='id', sort_by='id ASCENDING');
ERROR:  invalid sort_by value: unexpected token in sort key: ASCENDING
-- Test 5.4: NULLS FIRST/LAST not supported
\echo 'Test 5.4: sort_by with NULLS FIRST/LAST (should error - not supported)'
Test 5.4: sort_by with NULLS FIRST/LAST (should error - not supported)
CREATE INDEX sort_by_test_idx ON sort_by_test
    USING bm25 (id, name, score)
    WITH (key_field='id', sort_by='id ASC NULLS FIRST');
ERROR:  invalid sort_by value: NULLS FIRST/LAST is not currently supported
-- Test 5.5: Multiple fields not supported
\echo 'Test 5.5: sort_by with multiple fields (should error - not supported)'
Test 5.5: sort_by with multiple fields (should error - not supported)
CREATE INDEX sort_by_test_idx ON sort_by_test
    USING bm25 (id, name, score)
    WITH (key_field='id', sort_by='score DESC, id ASC');
ERROR:  sort_by specifies 2 fields, but only single-field sorting is currently supported
DROP TABLE sort_by_test CASCADE;
-- ============================================================================
-- SECTION 6: Mutable segment sort_by behavior
-- ============================================================================
-- This section verifies that mutable segments respect sort_by settings.
-- Data inserted AFTER index creation goes into mutable segments, which
-- should use the same IndexSettings as persistent segments.
-- ============================================================================
\echo '=== SECTION 6: Mutable segment sort_by behavior ==='
=== SECTION 6: Mutable segment sort_by behavior ===
DROP TABLE IF EXISTS mutable_sort_test CASCADE;
CREATE TABLE mutable_sort_test (
    id SERIAL PRIMARY KEY,
    category TEXT,
    score INTEGER
);
-- Create index FIRST with sort_by='score DESC'
\echo 'Creating index with sort_by=score DESC'
Creating index with sort_by=score DESC
CREATE INDEX mutable_sort_test_idx ON mutable_sort_test
    USING bm25 (id, category, score)
    WITH (key_field='id', sort_by='score DESC');
-- Now INSERT data - this goes into MUTABLE segment
-- Insert in random score order: 50, 100, 30, 80, 60
\echo 'Inserting data AFTER index creation (goes to mutable segment)'
Inserting data AFTER index creation (goes to mutable segment)
INSERT INTO mutable_sort_test (category, score) VALUES
    ('A', 50),   -- id=1
    ('A', 100),  -- id=2
    ('A', 30),   -- id=3
    ('A', 80),   -- id=4
    ('A', 60);   -- id=5
-- Query without ORDER BY - should return in score DESC order
\echo 'Test 6.1: Query mutable segment without ORDER BY'
Test 6.1: Query mutable segment without ORDER BY
\echo 'Expected: score DESC order (100, 80, 60, 50, 30)'
Expected: score DESC order (100, 80, 60, 50, 30)
SELECT id, category, score FROM mutable_sort_test
WHERE mutable_sort_test @@@ 'category:A';
 id | category | score 
----+----------+-------
  2 | A        |   100
  4 | A        |    80
  5 | A        |    60
  1 | A        |    50
  3 | A        |    30
(5 rows)

DROP TABLE mutable_sort_test CASCADE;
