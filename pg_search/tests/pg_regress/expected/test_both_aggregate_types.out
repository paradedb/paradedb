-- Demonstration: Both GROUP BY and non-GROUP BY aggregates work correctly
CREATE EXTENSION IF NOT EXISTS pg_search;
SET paradedb.enable_aggregate_custom_scan TO on;
-- Create test table
CREATE TABLE test_data (
    id SERIAL PRIMARY KEY,
    content TEXT,
    category TEXT,
    value INTEGER
);
INSERT INTO test_data (content, category, value) VALUES
    ('Important document A', 'docs', 10),
    ('Important report B', 'docs', 20),
    ('Critical analysis C', 'analysis', 30),
    ('Critical review D', 'analysis', 40),
    ('Standard file E', 'other', 50);
-- Create index with fast field
CREATE INDEX test_idx ON test_data
USING bm25 (id, content, category, value)
WITH (
    key_field='id',
    text_fields='{"content": {}, "category": {"fast": true}}',
    numeric_fields='{"value": {"fast": true}}'
);
-- Test 1: Non-GROUP BY aggregate (no grouping columns)
SELECT COUNT(*) as total_important
FROM test_data
WHERE content @@@ 'important';
 total_important 
-----------------
               2
(1 row)

-- Expected: 2
-- Test 2: GROUP BY with string field
SELECT category, COUNT(*) as count
FROM test_data
WHERE content @@@ 'critical'
GROUP BY category
ORDER BY category;
 category | count 
----------+-------
 analysis |     2
(1 row)

-- Expected: analysis | 2
-- Test 3: GROUP BY with numeric field  
SELECT value / 10 * 10 as value_range, COUNT(*) as count
FROM test_data
WHERE content @@@ 'important OR critical'
GROUP BY value / 10 * 10
ORDER BY value_range;
 value_range | count 
-------------+-------
          10 |     1
          20 |     1
          30 |     1
          40 |     1
(4 rows)

-- Expected: 
-- 10 | 1
-- 20 | 1
-- 30 | 1
-- 40 | 1
-- Show the execution plans
EXPLAIN (COSTS OFF, VERBOSE)
SELECT COUNT(*) FROM test_data WHERE content @@@ 'important';
                                                                      QUERY PLAN                                                                      
------------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ParadeDB Aggregate Scan) on public.test_data
   Output: now()
   Index: test_idx
   Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"content","query_string":"important","lenient":null,"conjunction_mode":null}}}}
   Human Readable Query: content:(important)
   Aggregate Definition: {"0":{"value_count":{"field":"ctid"}}}
(6 rows)

EXPLAIN (COSTS OFF, VERBOSE)
SELECT category, COUNT(*) FROM test_data WHERE content @@@ 'critical' GROUP BY category;
                                                                     QUERY PLAN                                                                      
-----------------------------------------------------------------------------------------------------------------------------------------------------
 Custom Scan (ParadeDB Aggregate Scan) on public.test_data
   Output: category, now()
   Index: test_idx
   Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"content","query_string":"critical","lenient":null,"conjunction_mode":null}}}}
   Human Readable Query: content:(critical)
   Aggregate Definition: {"group_0":{"terms":{"field":"category","size":10000},"aggs":{"agg_0":{"value_count":{"field":"ctid"}}}}}
(6 rows)

-- Clean up
DROP TABLE test_data CASCADE; 
