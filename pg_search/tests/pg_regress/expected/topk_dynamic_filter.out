-- Test for TopK dynamic filter pushdown through DataFusion
-- This test verifies that SortExec(TopK) propagates a DynamicFilterPhysicalExpr
-- down to PgSearchScan, enabling row pruning at the scan level for ORDER BY ... LIMIT queries.
-- Pruning occurs from two sources:
--   1) HashJoin dynamic filter: after building the hash table, HashJoinExec pushes
--      min/max bounds of join keys to the probe side, pruning rows that can't match.
--   2) TopK dynamic filter: after processing initial batches, SortExec pushes
--      the K-th threshold to leaf scans, pruning rows that can't make the top K.
SET max_parallel_workers_per_gather = 0;
SET enable_indexscan to OFF;
CREATE EXTENSION IF NOT EXISTS pg_search;
-- =============================================================================
-- SETUP
-- =============================================================================
DROP TABLE IF EXISTS products CASCADE;
DROP TABLE IF EXISTS suppliers CASCADE;
CREATE TABLE suppliers (
    id INTEGER PRIMARY KEY,
    name TEXT,
    region TEXT
);
-- 5 suppliers. Only some will match search predicates in individual tests.
INSERT INTO suppliers (id, name, region) VALUES
(1, 'AlphaSupply', 'north america domestic shipping'),
(2, 'BetaGoods', 'europe international logistics'),
(3, 'GammaParts', 'asia pacific global trade'),
(4, 'DeltaCorp', 'south america regional distribution'),
(5, 'EpsilonTech', 'africa emerging market wireless');
CREATE TABLE products (
    id INTEGER PRIMARY KEY,
    name TEXT,
    description TEXT,
    supplier_id INTEGER,
    price NUMERIC(10,2)
);
-- 30 products: all mention "premium" so they all match the search predicate.
-- supplier_id cycles 1-5, so each supplier has 6 products.
-- Prices spread from ~20 to ~300.
INSERT INTO products (id, name, description, supplier_id, price)
SELECT
    i,
    'Product ' || i,
    'premium quality item number ' || i || ' for professional use',
    (i % 5) + 1,
    round((10.0 + (i * 9.8))::numeric, 2)
FROM generate_series(1, 30) AS i;
CREATE INDEX products_bm25_idx ON products USING bm25 (id, name, description, supplier_id, price)
WITH (key_field = 'id', numeric_fields = '{"supplier_id": {"fast": true}, "price": {"fast": true}}');
CREATE INDEX suppliers_bm25_idx ON suppliers USING bm25 (id, name, region)
WITH (key_field = 'id');
SET paradedb.enable_join_custom_scan = on;
-- =============================================================================
-- TEST 1: EXPLAIN shows dynamic_filter=true on PgSearchScan with ORDER BY + LIMIT
-- =============================================================================
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT p.id, p.name, s.name AS supplier_name
FROM products p
JOIN suppliers s ON p.supplier_id = s.id
WHERE p.description @@@ 'premium'
ORDER BY p.id
LIMIT 3;
                                                                                           QUERY PLAN                                                                                           
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: p.id, p.name, s.name
   ->  Custom Scan (ParadeDB Join Scan)
         Output: p.id, p.name, s.name
         Join Type: Inner
         Relation 0: suppliers (s)
         Relation 1: products (p)
         Join Cond: p.supplier_id = s.id
         Limit: 3
         Order By: p.id asc
         DataFusion Physical Plan: 
           : ProjectionExec: expr=[id@2 as col_1, NULL as col_2, NULL as col_3, ctid_2@0 as ctid_2, ctid_1@1 as ctid_1]
           :   SortExec: TopK(fetch=3), expr=[id@2 ASC NULLS LAST], preserve_partitioning=[false]
           :     HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@1, supplier_id@1)], projection=[ctid_2@0, ctid_1@2, id@4]
           :       ProjectionExec: expr=[ctid@0 as ctid_2, id@1 as id]
           :         CooperativeExec
           :           PgSearchScan: "all", dynamic_filter=true
           :       ProjectionExec: expr=[ctid@0 as ctid_1, supplier_id@1 as supplier_id, id@2 as id]
           :         CooperativeExec
           :           PgSearchScan: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"premium","lenient":null,"conjunction_mode":null}}}}, dynamic_filter=true
(20 rows)

SELECT p.id, p.name, s.name AS supplier_name
FROM products p
JOIN suppliers s ON p.supplier_id = s.id
WHERE p.description @@@ 'premium'
ORDER BY p.id
LIMIT 3;
WARNING:  dynamic filter: batch 5 -> 5 rows (0 pruned)
WARNING:  dynamic filter total: 5 -> 5 rows (0 pruned, 0.0%)
WARNING:  dynamic filter: batch 30 -> 30 rows (0 pruned)
WARNING:  dynamic filter total: 30 -> 30 rows (0 pruned, 0.0%)
 id |   name    | supplier_name 
----+-----------+---------------
  1 | Product 1 | BetaGoods
  2 | Product 2 | GammaParts
  3 | Product 3 | DeltaCorp
(3 rows)

-- =============================================================================
-- TEST 2: Search predicate on the build side (suppliers) restricts join keys,
-- causing the HashJoin dynamic filter to prune probe-side (products) rows.
-- Only supplier 5 (EpsilonTech) matches 'wireless'. Products with supplier_id != 5
-- are pruned by the HashJoin dynamic filter on the probe side.
-- =============================================================================
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT p.id, p.name, s.name AS supplier_name
FROM products p
JOIN suppliers s ON p.supplier_id = s.id
WHERE s.region @@@ 'wireless'
ORDER BY p.id
LIMIT 3;
                                                                                         QUERY PLAN                                                                                         
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: p.id, p.name, s.name
   ->  Custom Scan (ParadeDB Join Scan)
         Output: p.id, p.name, s.name
         Join Type: Inner
         Relation 0: suppliers (s)
         Relation 1: products (p)
         Join Cond: p.supplier_id = s.id
         Limit: 3
         Order By: p.id asc
         DataFusion Physical Plan: 
           : ProjectionExec: expr=[id@2 as col_1, NULL as col_2, NULL as col_3, ctid_2@0 as ctid_2, ctid_1@1 as ctid_1]
           :   SortExec: TopK(fetch=3), expr=[id@2 ASC NULLS LAST], preserve_partitioning=[false]
           :     HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@1, supplier_id@1)], projection=[ctid_2@0, ctid_1@2, id@4]
           :       ProjectionExec: expr=[ctid@0 as ctid_2, id@1 as id]
           :         CooperativeExec
           :           PgSearchScan: {"with_index":{"query":{"parse_with_field":{"field":"region","query_string":"wireless","lenient":null,"conjunction_mode":null}}}}, dynamic_filter=true
           :       ProjectionExec: expr=[ctid@0 as ctid_1, supplier_id@1 as supplier_id, id@2 as id]
           :         CooperativeExec
           :           PgSearchScan: "all", dynamic_filter=true
(20 rows)

SELECT p.id, p.name, s.name AS supplier_name
FROM products p
JOIN suppliers s ON p.supplier_id = s.id
WHERE s.region @@@ 'wireless'
ORDER BY p.id
LIMIT 3;
WARNING:  dynamic filter: batch 1 -> 1 rows (0 pruned)
WARNING:  dynamic filter total: 1 -> 1 rows (0 pruned, 0.0%)
WARNING:  dynamic filter: batch 30 -> 6 rows (24 pruned)
WARNING:  dynamic filter total: 30 -> 6 rows (24 pruned, 80.0%)
 id |    name    | supplier_name 
----+------------+---------------
  4 | Product 4  | EpsilonTech
  9 | Product 9  | EpsilonTech
 14 | Product 14 | EpsilonTech
(3 rows)

-- =============================================================================
-- TEST 3: ORDER BY DESC + LIMIT
-- =============================================================================
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT p.id, p.name, s.name AS supplier_name
FROM products p
JOIN suppliers s ON p.supplier_id = s.id
WHERE p.description @@@ 'premium'
ORDER BY p.id DESC
LIMIT 2;
                                                                                           QUERY PLAN                                                                                           
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: p.id, p.name, s.name
   ->  Custom Scan (ParadeDB Join Scan)
         Output: p.id, p.name, s.name
         Join Type: Inner
         Relation 0: suppliers (s)
         Relation 1: products (p)
         Join Cond: p.supplier_id = s.id
         Limit: 2
         Order By: p.id desc
         DataFusion Physical Plan: 
           : ProjectionExec: expr=[id@2 as col_1, NULL as col_2, NULL as col_3, ctid_2@0 as ctid_2, ctid_1@1 as ctid_1]
           :   SortExec: TopK(fetch=2), expr=[id@2 DESC], preserve_partitioning=[false]
           :     HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@1, supplier_id@1)], projection=[ctid_2@0, ctid_1@2, id@4]
           :       ProjectionExec: expr=[ctid@0 as ctid_2, id@1 as id]
           :         CooperativeExec
           :           PgSearchScan: "all", dynamic_filter=true
           :       ProjectionExec: expr=[ctid@0 as ctid_1, supplier_id@1 as supplier_id, id@2 as id]
           :         CooperativeExec
           :           PgSearchScan: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"premium","lenient":null,"conjunction_mode":null}}}}, dynamic_filter=true
(20 rows)

SELECT p.id, p.name, s.name AS supplier_name
FROM products p
JOIN suppliers s ON p.supplier_id = s.id
WHERE p.description @@@ 'premium'
ORDER BY p.id DESC
LIMIT 2;
WARNING:  dynamic filter: batch 5 -> 5 rows (0 pruned)
WARNING:  dynamic filter total: 5 -> 5 rows (0 pruned, 0.0%)
WARNING:  dynamic filter: batch 30 -> 30 rows (0 pruned)
WARNING:  dynamic filter total: 30 -> 30 rows (0 pruned, 0.0%)
 id |    name    | supplier_name 
----+------------+---------------
 30 | Product 30 | AlphaSupply
 29 | Product 29 | EpsilonTech
(2 rows)

-- =============================================================================
-- TEST 4: ORDER BY price + LIMIT (numeric sort column)
-- =============================================================================
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT p.id, p.name, p.price, s.name AS supplier_name
FROM products p
JOIN suppliers s ON p.supplier_id = s.id
WHERE p.description @@@ 'premium'
ORDER BY p.price ASC
LIMIT 2;
                                                                                           QUERY PLAN                                                                                           
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: p.id, p.name, p.price, s.name
   ->  Custom Scan (ParadeDB Join Scan)
         Output: p.id, p.name, p.price, s.name
         Join Type: Inner
         Relation 0: suppliers (s)
         Relation 1: products (p)
         Join Cond: p.supplier_id = s.id
         Limit: 2
         Order By: p.price asc
         DataFusion Physical Plan: 
           : ProjectionExec: expr=[NULL as col_1, NULL as col_2, price@2 as col_3, NULL as col_4, ctid_2@0 as ctid_2, ctid_1@1 as ctid_1]
           :   SortExec: TopK(fetch=2), expr=[price@2 ASC NULLS LAST], preserve_partitioning=[false]
           :     HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@1, supplier_id@1)], projection=[ctid_2@0, ctid_1@2, price@4]
           :       ProjectionExec: expr=[ctid@0 as ctid_2, id@1 as id]
           :         CooperativeExec
           :           PgSearchScan: "all"
           :       ProjectionExec: expr=[ctid@0 as ctid_1, supplier_id@1 as supplier_id, price@2 as price]
           :         CooperativeExec
           :           PgSearchScan: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"premium","lenient":null,"conjunction_mode":null}}}}, dynamic_filter=true
(20 rows)

SELECT p.id, p.name, p.price, s.name AS supplier_name
FROM products p
JOIN suppliers s ON p.supplier_id = s.id
WHERE p.description @@@ 'premium'
ORDER BY p.price ASC
LIMIT 2;
WARNING:  dynamic filter: batch 30 -> 30 rows (0 pruned)
WARNING:  dynamic filter total: 30 -> 30 rows (0 pruned, 0.0%)
 id |   name    | price | supplier_name 
----+-----------+-------+---------------
  1 | Product 1 | 19.80 | BetaGoods
  2 | Product 2 | 29.60 | GammaParts
(2 rows)

-- =============================================================================
-- TEST 5: Both sides have search predicates with ORDER BY + LIMIT.
-- Only supplier 3 (GammaParts) matches 'global'. Products are further filtered.
-- =============================================================================
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT p.id, p.name, s.name AS supplier_name
FROM products p
JOIN suppliers s ON p.supplier_id = s.id
WHERE p.description @@@ 'premium' AND s.region @@@ 'global'
ORDER BY p.id
LIMIT 5;
                                                                                           QUERY PLAN                                                                                           
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: p.id, p.name, s.name
   ->  Custom Scan (ParadeDB Join Scan)
         Output: p.id, p.name, s.name
         Join Type: Inner
         Relation 0: suppliers (s)
         Relation 1: products (p)
         Join Cond: p.supplier_id = s.id
         Limit: 5
         Order By: p.id asc
         DataFusion Physical Plan: 
           : ProjectionExec: expr=[id@2 as col_1, NULL as col_2, NULL as col_3, ctid_2@0 as ctid_2, ctid_1@1 as ctid_1]
           :   SortExec: TopK(fetch=5), expr=[id@2 ASC NULLS LAST], preserve_partitioning=[false]
           :     HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@1, supplier_id@1)], projection=[ctid_2@0, ctid_1@2, id@4]
           :       ProjectionExec: expr=[ctid@0 as ctid_2, id@1 as id]
           :         CooperativeExec
           :           PgSearchScan: {"with_index":{"query":{"parse_with_field":{"field":"region","query_string":"global","lenient":null,"conjunction_mode":null}}}}, dynamic_filter=true
           :       ProjectionExec: expr=[ctid@0 as ctid_1, supplier_id@1 as supplier_id, id@2 as id]
           :         CooperativeExec
           :           PgSearchScan: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"premium","lenient":null,"conjunction_mode":null}}}}, dynamic_filter=true
(20 rows)

SELECT p.id, p.name, s.name AS supplier_name
FROM products p
JOIN suppliers s ON p.supplier_id = s.id
WHERE p.description @@@ 'premium' AND s.region @@@ 'global'
ORDER BY p.id
LIMIT 5;
WARNING:  dynamic filter: batch 1 -> 1 rows (0 pruned)
WARNING:  dynamic filter total: 1 -> 1 rows (0 pruned, 0.0%)
WARNING:  dynamic filter: batch 30 -> 6 rows (24 pruned)
WARNING:  dynamic filter total: 30 -> 6 rows (24 pruned, 80.0%)
 id |    name    | supplier_name 
----+------------+---------------
  2 | Product 2  | GammaParts
  7 | Product 7  | GammaParts
 12 | Product 12 | GammaParts
 17 | Product 17 | GammaParts
 22 | Product 22 | GammaParts
(5 rows)

-- =============================================================================
-- TEST 6: Without LIMIT - no dynamic filter should appear
-- =============================================================================
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT p.id, p.name, s.name AS supplier_name
FROM products p
JOIN suppliers s ON p.supplier_id = s.id
WHERE p.description @@@ 'premium'
ORDER BY p.id;
WARNING:  JoinScan not used: query must have a LIMIT clause
                                                                             QUERY PLAN                                                                             
--------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: p.id, p.name, s.name
   Sort Key: p.id
   ->  Hash Join
         Output: p.id, p.name, s.name
         Inner Unique: true
         Hash Cond: (p.supplier_id = s.id)
         ->  Custom Scan (ParadeDB Scan) on public.products p
               Output: p.id, p.name, p.supplier_id
               Table: products
               Index: products_bm25_idx
               Exec Method: NormalScanExecState
               Scores: false
               Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"premium","lenient":null,"conjunction_mode":null}}}}
         ->  Hash
               Output: s.name, s.id
               ->  Seq Scan on public.suppliers s
                     Output: s.name, s.id
(18 rows)

-- =============================================================================
-- CLEANUP
-- =============================================================================
DROP TABLE products CASCADE;
DROP TABLE suppliers CASCADE;
