-- Test for TopK dynamic filter pushdown through DataFusion
-- This test verifies that SortExec(TopK) propagates a DynamicFilterPhysicalExpr
-- down to PgSearchScan, enabling row pruning at the scan level for ORDER BY ... LIMIT queries.
SET max_parallel_workers_per_gather = 0;
SET enable_indexscan to OFF;
CREATE EXTENSION IF NOT EXISTS pg_search;
-- =============================================================================
-- SETUP
-- =============================================================================
DROP TABLE IF EXISTS products CASCADE;
DROP TABLE IF EXISTS suppliers CASCADE;
CREATE TABLE products (
    id INTEGER PRIMARY KEY,
    name TEXT,
    description TEXT,
    supplier_id INTEGER,
    price NUMERIC(10,2)
);
CREATE TABLE suppliers (
    id INTEGER PRIMARY KEY,
    name TEXT,
    contact_info TEXT,
    country TEXT
);
INSERT INTO suppliers (id, name, contact_info, country) VALUES
(101, 'TechCorp', 'contact@techcorp.com wireless technology', 'USA'),
(102, 'GlobalSupply', 'info@globalsupply.com international shipping', 'UK'),
(103, 'FastParts', 'sales@fastparts.com quick delivery', 'Germany'),
(104, 'QualityFirst', 'quality@first.com premium products', 'Japan');
INSERT INTO products (id, name, description, supplier_id, price) VALUES
(1, 'Wireless Mouse', 'Ergonomic wireless mouse with Bluetooth connectivity', 101, 29.99),
(2, 'USB Cable', 'High-speed USB-C cable for fast data transfer', 102, 9.99),
(3, 'Keyboard', 'Mechanical keyboard with RGB lighting', 101, 89.99),
(4, 'Monitor Stand', 'Adjustable monitor stand for ergonomic setup', 103, 49.99),
(5, 'Webcam', 'HD webcam for video conferencing', 104, 59.99),
(6, 'Headphones', 'Wireless noise-canceling headphones with premium sound', 101, 199.99),
(7, 'Mouse Pad', 'Large gaming mouse pad with wireless charging', 102, 39.69),
(8, 'Cable Organizer', 'Desktop cable organizer for clean setup', 103, 14.99),
(9, 'Docking Station', 'USB-C docking station with wireless display', 104, 149.99),
(10, 'Power Strip', 'Smart power strip with wireless control', 102, 24.99);
CREATE INDEX products_bm25_idx ON products USING bm25 (id, name, description, supplier_id, price)
WITH (key_field = 'id', numeric_fields = '{"supplier_id": {"fast": true}, "price": {"fast": true}}');
CREATE INDEX suppliers_bm25_idx ON suppliers USING bm25 (id, name, contact_info, country)
WITH (key_field = 'id');
SET paradedb.enable_join_custom_scan = on;
-- =============================================================================
-- TEST 1: EXPLAIN shows dynamic_filter=true on PgSearchScan with ORDER BY + LIMIT
-- =============================================================================
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT p.id, p.name, s.name AS supplier_name
FROM products p
JOIN suppliers s ON p.supplier_id = s.id
WHERE p.description @@@ 'wireless'
ORDER BY p.id
LIMIT 3;
                                                                                           QUERY PLAN                                                                                            
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: p.id, p.name, s.name
   ->  Custom Scan (ParadeDB Join Scan)
         Output: p.id, p.name, s.name
         Join Type: Inner
         Relation 0: suppliers (s)
         Relation 1: products (p)
         Join Cond: p.supplier_id = s.id
         Limit: 3
         Order By: p.id asc
         DataFusion Physical Plan: 
           : ProjectionExec: expr=[id@2 as col_1, NULL as col_2, NULL as col_3, ctid_2@0 as ctid_2, ctid_1@1 as ctid_1]
           :   SortExec: TopK(fetch=3), expr=[id@2 ASC NULLS LAST], preserve_partitioning=[false]
           :     HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@1, supplier_id@1)], projection=[ctid_2@0, ctid_1@2, id@4]
           :       ProjectionExec: expr=[ctid@0 as ctid_2, id@1 as id]
           :         CooperativeExec
           :           PgSearchScan: "all", dynamic_filter=true
           :       ProjectionExec: expr=[ctid@0 as ctid_1, supplier_id@1 as supplier_id, id@2 as id]
           :         CooperativeExec
           :           PgSearchScan: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"wireless","lenient":null,"conjunction_mode":null}}}}, dynamic_filter=true
(20 rows)

SELECT p.id, p.name, s.name AS supplier_name
FROM products p
JOIN suppliers s ON p.supplier_id = s.id
WHERE p.description @@@ 'wireless'
ORDER BY p.id
LIMIT 3;
 id |      name      | supplier_name 
----+----------------+---------------
  1 | Wireless Mouse | TechCorp
  6 | Headphones     | TechCorp
  7 | Mouse Pad      | GlobalSupply
(3 rows)

-- =============================================================================
-- TEST 2: ORDER BY DESC + LIMIT
-- =============================================================================
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT p.id, p.name, s.name AS supplier_name
FROM products p
JOIN suppliers s ON p.supplier_id = s.id
WHERE p.description @@@ 'wireless'
ORDER BY p.id DESC
LIMIT 2;
                                                                                           QUERY PLAN                                                                                            
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: p.id, p.name, s.name
   ->  Custom Scan (ParadeDB Join Scan)
         Output: p.id, p.name, s.name
         Join Type: Inner
         Relation 0: suppliers (s)
         Relation 1: products (p)
         Join Cond: p.supplier_id = s.id
         Limit: 2
         Order By: p.id desc
         DataFusion Physical Plan: 
           : ProjectionExec: expr=[id@2 as col_1, NULL as col_2, NULL as col_3, ctid_2@0 as ctid_2, ctid_1@1 as ctid_1]
           :   SortExec: TopK(fetch=2), expr=[id@2 DESC], preserve_partitioning=[false]
           :     HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@1, supplier_id@1)], projection=[ctid_2@0, ctid_1@2, id@4]
           :       ProjectionExec: expr=[ctid@0 as ctid_2, id@1 as id]
           :         CooperativeExec
           :           PgSearchScan: "all", dynamic_filter=true
           :       ProjectionExec: expr=[ctid@0 as ctid_1, supplier_id@1 as supplier_id, id@2 as id]
           :         CooperativeExec
           :           PgSearchScan: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"wireless","lenient":null,"conjunction_mode":null}}}}, dynamic_filter=true
(20 rows)

SELECT p.id, p.name, s.name AS supplier_name
FROM products p
JOIN suppliers s ON p.supplier_id = s.id
WHERE p.description @@@ 'wireless'
ORDER BY p.id DESC
LIMIT 2;
 id |      name       | supplier_name 
----+-----------------+---------------
 10 | Power Strip     | GlobalSupply
  9 | Docking Station | QualityFirst
(2 rows)

-- =============================================================================
-- TEST 3: ORDER BY numeric (price) + LIMIT
-- =============================================================================
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT p.id, p.name, p.price, s.name AS supplier_name
FROM products p
JOIN suppliers s ON p.supplier_id = s.id
WHERE p.description @@@ 'wireless'
ORDER BY p.price ASC
LIMIT 2;
                                                                                           QUERY PLAN                                                                                            
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: p.id, p.name, p.price, s.name
   ->  Custom Scan (ParadeDB Join Scan)
         Output: p.id, p.name, p.price, s.name
         Join Type: Inner
         Relation 0: suppliers (s)
         Relation 1: products (p)
         Join Cond: p.supplier_id = s.id
         Limit: 2
         Order By: p.price asc
         DataFusion Physical Plan: 
           : ProjectionExec: expr=[NULL as col_1, NULL as col_2, price@2 as col_3, NULL as col_4, ctid_2@0 as ctid_2, ctid_1@1 as ctid_1]
           :   SortExec: TopK(fetch=2), expr=[price@2 ASC NULLS LAST], preserve_partitioning=[false]
           :     HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@1, supplier_id@1)], projection=[ctid_2@0, ctid_1@2, price@4]
           :       ProjectionExec: expr=[ctid@0 as ctid_2, id@1 as id]
           :         CooperativeExec
           :           PgSearchScan: "all"
           :       ProjectionExec: expr=[ctid@0 as ctid_1, supplier_id@1 as supplier_id, price@2 as price]
           :         CooperativeExec
           :           PgSearchScan: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"wireless","lenient":null,"conjunction_mode":null}}}}, dynamic_filter=true
(20 rows)

SELECT p.id, p.name, p.price, s.name AS supplier_name
FROM products p
JOIN suppliers s ON p.supplier_id = s.id
WHERE p.description @@@ 'wireless'
ORDER BY p.price ASC
LIMIT 2;
 id |      name      | price | supplier_name 
----+----------------+-------+---------------
 10 | Power Strip    | 24.99 | GlobalSupply
  1 | Wireless Mouse | 29.99 | TechCorp
(2 rows)

-- =============================================================================
-- TEST 4: Both sides have search predicates with ORDER BY + LIMIT
-- =============================================================================
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT p.id, p.name, s.name AS supplier_name
FROM products p
JOIN suppliers s ON p.supplier_id = s.id
WHERE p.description @@@ 'wireless' AND s.contact_info @@@ 'technology'
ORDER BY p.id
LIMIT 5;
                                                                                             QUERY PLAN                                                                                             
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: p.id, p.name, s.name
   ->  Custom Scan (ParadeDB Join Scan)
         Output: p.id, p.name, s.name
         Join Type: Inner
         Relation 0: suppliers (s)
         Relation 1: products (p)
         Join Cond: p.supplier_id = s.id
         Limit: 5
         Order By: p.id asc
         DataFusion Physical Plan: 
           : ProjectionExec: expr=[id@2 as col_1, NULL as col_2, NULL as col_3, ctid_2@0 as ctid_2, ctid_1@1 as ctid_1]
           :   SortExec: TopK(fetch=5), expr=[id@2 ASC NULLS LAST], preserve_partitioning=[false]
           :     HashJoinExec: mode=CollectLeft, join_type=Inner, on=[(id@1, supplier_id@1)], projection=[ctid_2@0, ctid_1@2, id@4]
           :       ProjectionExec: expr=[ctid@0 as ctid_2, id@1 as id]
           :         CooperativeExec
           :           PgSearchScan: {"with_index":{"query":{"parse_with_field":{"field":"contact_info","query_string":"technology","lenient":null,"conjunction_mode":null}}}}, dynamic_filter=true
           :       ProjectionExec: expr=[ctid@0 as ctid_1, supplier_id@1 as supplier_id, id@2 as id]
           :         CooperativeExec
           :           PgSearchScan: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"wireless","lenient":null,"conjunction_mode":null}}}}, dynamic_filter=true
(20 rows)

SELECT p.id, p.name, s.name AS supplier_name
FROM products p
JOIN suppliers s ON p.supplier_id = s.id
WHERE p.description @@@ 'wireless' AND s.contact_info @@@ 'technology'
ORDER BY p.id
LIMIT 5;
 id |      name      | supplier_name 
----+----------------+---------------
  1 | Wireless Mouse | TechCorp
  6 | Headphones     | TechCorp
(2 rows)

-- =============================================================================
-- TEST 5: Without LIMIT - no dynamic filter should appear
-- =============================================================================
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT p.id, p.name, s.name AS supplier_name
FROM products p
JOIN suppliers s ON p.supplier_id = s.id
WHERE p.description @@@ 'wireless'
ORDER BY p.id;
WARNING:  JoinScan not used: query must have a LIMIT clause
                                                                                QUERY PLAN                                                                                 
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sort
   Output: p.id, p.name, s.name
   Sort Key: p.id
   ->  Hash Join
         Output: p.id, p.name, s.name
         Hash Cond: (s.id = p.supplier_id)
         ->  Seq Scan on public.suppliers s
               Output: s.id, s.name, s.contact_info, s.country
         ->  Hash
               Output: p.id, p.name, p.supplier_id
               ->  Custom Scan (ParadeDB Scan) on public.products p
                     Output: p.id, p.name, p.supplier_id
                     Table: products
                     Index: products_bm25_idx
                     Exec Method: NormalScanExecState
                     Scores: false
                     Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"description","query_string":"wireless","lenient":null,"conjunction_mode":null}}}}
(17 rows)

-- =============================================================================
-- CLEANUP
-- =============================================================================
DROP TABLE products CASCADE;
DROP TABLE suppliers CASCADE;
