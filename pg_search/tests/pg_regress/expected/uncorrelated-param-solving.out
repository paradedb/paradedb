CREATE EXTENSION IF NOT EXISTS pg_search;
DROP TABLE IF EXISTS items CASCADE;
CREATE TABLE items (
    id text NOT NULL,
    group_id text NOT NULL,
    status text NOT NULL,
    created_at timestamp NOT NULL
);
ALTER TABLE ONLY items
    ADD CONSTRAINT items_pkey PRIMARY KEY (id);
CREATE INDEX items_idx ON items USING bm25 (
    id,
    group_id,
    status,
    created_at
)
WITH (
    key_field = 'id',
    text_fields = '{
        "group_id": { "fast": true, "tokenizer": { "type": "keyword" } },
        "status": { "fast": true, "tokenizer": { "type": "keyword" } }
    }',
    datetime_fields = '{"created_at": {}}'
);
INSERT INTO items (id, group_id, status, created_at)
VALUES
    ('4', 'g1', 'posted', '2025-01-01 12:00:00'),
    ('3', 'g1', 'pending', '2025-01-01 12:00:00'),
    ('2', 'g1', 'posted', '2025-01-01 11:00:00'),
    ('1', 'g1', 'pending', '2025-01-01 10:00:00');
-- The subqueries here are uncorrelated, and should get InitPlan nodes which we can
-- solve at `BeginCustomScan` time. They should NOT get a "heap filter" plan, as that would
-- prevent index pushdown.
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT id, status, created_at
FROM items
WHERE
    group_id = 'g1'
    AND (id @@@ paradedb.all())
    AND status @@@ 'IN [posted pending]'
    AND created_at <= (SELECT created_at FROM items WHERE id = '4')
    AND (
        created_at < (SELECT created_at FROM items WHERE id = '4')
        OR
        (id < '4' AND created_at = (SELECT created_at FROM items WHERE id = '4'))
    )
ORDER BY created_at DESC, id DESC
LIMIT 100;
                                                                                                                                                                                                                                                                                                                                                                                                             QUERY PLAN                                                                                                                                                                                                                                                                                                                                                                                                             
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: items.id, items.status, items.created_at
   InitPlan 1
     ->  Index Scan using items_pkey on public.items items_1
           Output: items_1.created_at
           Index Cond: (items_1.id = '4'::text)
   InitPlan 2
     ->  Index Scan using items_pkey on public.items items_2
           Output: items_2.created_at
           Index Cond: (items_2.id = '4'::text)
   InitPlan 3
     ->  Index Scan using items_pkey on public.items items_3
           Output: items_3.created_at
           Index Cond: (items_3.id = '4'::text)
   ->  Custom Scan (ParadeDB Scan) on public.items
         Output: items.id, items.status, items.created_at
         Table: items
         Index: items_idx
         Exec Method: TopNScanExecState
         Scores: false
            TopN Order By: created_at desc, id desc
            TopN Limit: 100
         Tantivy Query: {"boolean":{"must":[{"with_index":{"query":"all"}},{"with_index":{"query":{"parse_with_field":{"field":"status","query_string":"IN [posted pending]","lenient":null,"conjunction_mode":null}}}},{"postgres_expression":{"expr":{"expr_desc":"paradedb.term_with_operator('created_at'::paradedb.fieldname, '<='::text, $1)"}}},{"boolean":{"should":[{"postgres_expression":{"expr":{"expr_desc":"paradedb.term_with_operator('created_at'::paradedb.fieldname, '<'::text, $2)"}}},{"boolean":{"must":[{"range":{"field":"id","lower_bound":null,"upper_bound":{"excluded":"4"},"is_datetime":false}},{"postgres_expression":{"expr":{"expr_desc":"paradedb.term_with_operator('created_at'::paradedb.fieldname, '='::text, $3)"}}}]}}]}},{"term":{"field":"group_id","value":"g1","is_datetime":false}}]}}
(23 rows)

SELECT id, status, created_at
FROM items
WHERE
    group_id = 'g1'
    AND (id @@@ paradedb.all())
    AND status @@@ 'IN [posted pending]'
    AND created_at <= (SELECT created_at FROM items WHERE id = '4')
    AND (
        created_at < (SELECT created_at FROM items WHERE id = '4')
        OR
        (id < '4' AND created_at = (SELECT created_at FROM items WHERE id = '4'))
    )
ORDER BY created_at DESC, id DESC
LIMIT 100;
 id | status  |        created_at        
----+---------+--------------------------
 3  | pending | Wed Jan 01 12:00:00 2025
 2  | posted  | Wed Jan 01 11:00:00 2025
 1  | pending | Wed Jan 01 10:00:00 2025
(3 rows)

