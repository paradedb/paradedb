-- Test paradedb.verify_bm25_index function
-- This tests the amcheck-style index verification for BM25 indexes
-- Setup: Create a test table and index
DROP TABLE IF EXISTS verify_test CASCADE;
NOTICE:  table "verify_test" does not exist, skipping
CREATE TABLE verify_test (
    id SERIAL PRIMARY KEY,
    content TEXT,
    category TEXT,
    score INT
);
CREATE INDEX verify_test_idx ON verify_test USING bm25 (id, content, category, score) WITH (key_field = 'id');
-- Insert some test data
INSERT INTO verify_test (content, category, score) VALUES
    ('hello world', 'greeting', 10),
    ('goodbye world', 'farewell', 20),
    ('search engine', 'technology', 30),
    ('full text search', 'technology', 40),
    ('paradedb postgres', 'database', 50);
-- Test 1: Basic verification without heapallindexed option
-- Should return schema_valid, index_readable, checksums_valid, segment_metadata_valid
SELECT check_name, passed FROM paradedb.verify_bm25_index('verify_test_idx') ORDER BY check_name;
               check_name                | passed 
-----------------------------------------+--------
 verify_test_idx: checksums_valid        | t
 verify_test_idx: index_readable         | t
 verify_test_idx: schema_valid           | t
 verify_test_idx: segment_metadata_valid | t
(4 rows)

-- Test 2: Verification with heapallindexed option
-- Should also check heap references
SELECT check_name, passed FROM paradedb.verify_bm25_index('verify_test_idx', heapallindexed := true) ORDER BY check_name;
               check_name                | passed 
-----------------------------------------+--------
 verify_test_idx: checksums_valid        | t
 verify_test_idx: heap_references_valid  | t
 verify_test_idx: index_readable         | t
 verify_test_idx: schema_valid           | t
 verify_test_idx: segment_metadata_valid | t
(5 rows)

-- Test 3: Verify after more data is added
INSERT INTO verify_test (content, category, score)
SELECT 
    'test content ' || i,
    CASE WHEN i % 2 = 0 THEN 'even' ELSE 'odd' END,
    i
FROM generate_series(1, 100) i;
-- Verify the index is still valid after inserts
SELECT check_name, passed FROM paradedb.verify_bm25_index('verify_test_idx') ORDER BY check_name;
               check_name                | passed 
-----------------------------------------+--------
 verify_test_idx: checksums_valid        | t
 verify_test_idx: index_readable         | t
 verify_test_idx: schema_valid           | t
 verify_test_idx: segment_metadata_valid | t
(4 rows)

-- Test 4: Verify with heapallindexed after more data
SELECT check_name, passed FROM paradedb.verify_bm25_index('verify_test_idx', heapallindexed := true) ORDER BY check_name;
               check_name                | passed 
-----------------------------------------+--------
 verify_test_idx: checksums_valid        | t
 verify_test_idx: heap_references_valid  | t
 verify_test_idx: index_readable         | t
 verify_test_idx: schema_valid           | t
 verify_test_idx: segment_metadata_valid | t
(5 rows)

-- Test 5: Verify after some deletes
DELETE FROM verify_test WHERE id <= 3;
-- Wait for any background processes to settle
SELECT pg_sleep(0.1);
 pg_sleep 
----------
 
(1 row)

-- Run vacuum to clean up
VACUUM verify_test;
-- Verify index still valid after deletes and vacuum
SELECT check_name, passed FROM paradedb.verify_bm25_index('verify_test_idx') ORDER BY check_name;
               check_name                | passed 
-----------------------------------------+--------
 verify_test_idx: checksums_valid        | t
 verify_test_idx: index_readable         | t
 verify_test_idx: schema_valid           | t
 verify_test_idx: segment_metadata_valid | t
(4 rows)

-- Test 6: Verify with heapallindexed after deletes
SELECT check_name, passed FROM paradedb.verify_bm25_index('verify_test_idx', heapallindexed := true) ORDER BY check_name;
               check_name                | passed 
-----------------------------------------+--------
 verify_test_idx: checksums_valid        | t
 verify_test_idx: heap_references_valid  | t
 verify_test_idx: index_readable         | t
 verify_test_idx: schema_valid           | t
 verify_test_idx: segment_metadata_valid | t
(5 rows)

-- Test 7: Verify that the index can still be used for searches after verification
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT id, content FROM verify_test WHERE content @@@ 'test' LIMIT 5;
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: id, content
   ->  Custom Scan (ParadeDB Scan) on public.verify_test
         Output: id, content
         Table: verify_test
         Index: verify_test_idx
         Exec Method: TopNScanExecState
         Scores: false
            TopN Limit: 5
         Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"content","query_string":"test","lenient":null,"conjunction_mode":null}}}}
(10 rows)

SELECT id, content FROM verify_test WHERE content @@@ 'test' ORDER BY id LIMIT 5;
 id |    content     
----+----------------
  6 | test content 1
  7 | test content 2
  8 | test content 3
  9 | test content 4
 10 | test content 5
(5 rows)

-- Cleanup
DROP TABLE verify_test CASCADE;
-- Test 8: Test with sampling (for large indexes)
-- Create a larger table to test sampling
DROP TABLE IF EXISTS verify_sampling_test CASCADE;
NOTICE:  table "verify_sampling_test" does not exist, skipping
CREATE TABLE verify_sampling_test (id SERIAL PRIMARY KEY, content TEXT);
CREATE INDEX verify_sampling_idx ON verify_sampling_test USING bm25 (id, content) WITH (key_field = 'id');
INSERT INTO verify_sampling_test (content)
SELECT 'test content ' || i FROM generate_series(1, 1000) i;
-- Test sampling at 50% - should check approximately half the documents
SELECT check_name, passed, 
       details LIKE '%sampled%' as is_sampled
FROM paradedb.verify_bm25_index('verify_sampling_idx', heapallindexed := true, sample_rate := 0.5) 
WHERE check_name LIKE '%heap_references%';
                 check_name                 | passed | is_sampled 
--------------------------------------------+--------+------------
 verify_sampling_idx: heap_references_valid | t      | t
(1 row)

DROP TABLE verify_sampling_test CASCADE;
