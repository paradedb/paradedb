-- Test paradedb.verify_bm25_index function
-- This tests the amcheck-style index verification for BM25 indexes
-- Setup: Create a test table and index
DROP TABLE IF EXISTS verify_test CASCADE;
NOTICE:  table "verify_test" does not exist, skipping
CREATE TABLE verify_test (
    id SERIAL PRIMARY KEY,
    content TEXT,
    category TEXT,
    score INT
);
CREATE INDEX verify_test_idx ON verify_test USING bm25 (id, content, category, score) WITH (key_field = 'id');
-- Insert some test data
INSERT INTO verify_test (content, category, score) VALUES
    ('hello world', 'greeting', 10),
    ('goodbye world', 'farewell', 20),
    ('search engine', 'technology', 30),
    ('full text search', 'technology', 40),
    ('paradedb postgres', 'database', 50);
-- Test 1: Basic verification without heapallindexed option
-- Should return schema_valid, index_readable, checksums_valid, segment_metadata_valid
SELECT check_name, passed FROM paradedb.verify_bm25_index('verify_test_idx') ORDER BY check_name;
               check_name                | passed 
-----------------------------------------+--------
 verify_test_idx: checksums_valid        | t
 verify_test_idx: index_readable         | t
 verify_test_idx: schema_valid           | t
 verify_test_idx: segment_metadata_valid | t
(4 rows)

-- Test 2: Verification with heapallindexed option
-- Should also check heap references
SELECT check_name, passed FROM paradedb.verify_bm25_index('verify_test_idx', heapallindexed := true) ORDER BY check_name;
               check_name                | passed 
-----------------------------------------+--------
 verify_test_idx: checksums_valid        | t
 verify_test_idx: heap_references_valid  | t
 verify_test_idx: index_readable         | t
 verify_test_idx: schema_valid           | t
 verify_test_idx: segment_metadata_valid | t
(5 rows)

-- Test 3: Verify after more data is added
INSERT INTO verify_test (content, category, score)
SELECT 
    'test content ' || i,
    CASE WHEN i % 2 = 0 THEN 'even' ELSE 'odd' END,
    i
FROM generate_series(1, 100) i;
-- Verify the index is still valid after inserts
SELECT check_name, passed FROM paradedb.verify_bm25_index('verify_test_idx') ORDER BY check_name;
               check_name                | passed 
-----------------------------------------+--------
 verify_test_idx: checksums_valid        | t
 verify_test_idx: index_readable         | t
 verify_test_idx: schema_valid           | t
 verify_test_idx: segment_metadata_valid | t
(4 rows)

-- Test 4: Verify with heapallindexed after more data
SELECT check_name, passed FROM paradedb.verify_bm25_index('verify_test_idx', heapallindexed := true) ORDER BY check_name;
               check_name                | passed 
-----------------------------------------+--------
 verify_test_idx: checksums_valid        | t
 verify_test_idx: heap_references_valid  | t
 verify_test_idx: index_readable         | t
 verify_test_idx: schema_valid           | t
 verify_test_idx: segment_metadata_valid | t
(5 rows)

-- Test 5: Verify after some deletes
DELETE FROM verify_test WHERE id <= 3;
-- Wait for any background processes to settle
SELECT pg_sleep(0.1);
 pg_sleep 
----------
 
(1 row)

-- Run vacuum to clean up
VACUUM verify_test;
-- Verify index still valid after deletes and vacuum
SELECT check_name, passed FROM paradedb.verify_bm25_index('verify_test_idx') ORDER BY check_name;
               check_name                | passed 
-----------------------------------------+--------
 verify_test_idx: checksums_valid        | t
 verify_test_idx: index_readable         | t
 verify_test_idx: schema_valid           | t
 verify_test_idx: segment_metadata_valid | t
(4 rows)

-- Test 6: Verify with heapallindexed after deletes
SELECT check_name, passed FROM paradedb.verify_bm25_index('verify_test_idx', heapallindexed := true) ORDER BY check_name;
               check_name                | passed 
-----------------------------------------+--------
 verify_test_idx: checksums_valid        | t
 verify_test_idx: heap_references_valid  | t
 verify_test_idx: index_readable         | t
 verify_test_idx: schema_valid           | t
 verify_test_idx: segment_metadata_valid | t
(5 rows)

-- Test 7: Verify that the index can still be used for searches after verification
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT id, content FROM verify_test WHERE content @@@ 'test' LIMIT 5;
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: id, content
   ->  Custom Scan (ParadeDB Scan) on public.verify_test
         Output: id, content
         Table: verify_test
         Index: verify_test_idx
         Exec Method: TopNScanExecState
         Scores: false
            TopN Limit: 5
         Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"content","query_string":"test","lenient":null,"conjunction_mode":null}}}}
(10 rows)

SELECT id, content FROM verify_test WHERE content @@@ 'test' ORDER BY id LIMIT 5;
 id |    content     
----+----------------
  6 | test content 1
  7 | test content 2
  8 | test content 3
  9 | test content 4
 10 | test content 5
(5 rows)

-- Cleanup
DROP TABLE verify_test CASCADE;
-- Test 8: Test with sampling (for large indexes)
-- Create a larger table to test sampling
DROP TABLE IF EXISTS verify_sampling_test CASCADE;
NOTICE:  table "verify_sampling_test" does not exist, skipping
CREATE TABLE verify_sampling_test (id SERIAL PRIMARY KEY, content TEXT);
CREATE INDEX verify_sampling_idx ON verify_sampling_test USING bm25 (id, content) WITH (key_field = 'id');
INSERT INTO verify_sampling_test (content)
SELECT 'test content ' || i FROM generate_series(1, 1000) i;
-- Test sampling at 50% - should check approximately half the documents
SELECT check_name, passed, 
       details LIKE '%sampled%' as is_sampled
FROM paradedb.verify_bm25_index('verify_sampling_idx', heapallindexed := true, sample_rate := 0.5) 
WHERE check_name LIKE '%heap_references%';
                 check_name                 | passed | is_sampled 
--------------------------------------------+--------+------------
 verify_sampling_idx: heap_references_valid | t      | t
(1 row)

DROP TABLE verify_sampling_test CASCADE;
-- Test 9: Test with segment_ids for manual parallelization
-- Create a table and force multiple segments by doing separate inserts (each is its own transaction)
DROP TABLE IF EXISTS verify_parallel_test CASCADE;
NOTICE:  table "verify_parallel_test" does not exist, skipping
CREATE TABLE verify_parallel_test (id SERIAL PRIMARY KEY, content TEXT);
-- Create index with low mutable_segment_rows to ensure segments are created
CREATE INDEX verify_parallel_idx ON verify_parallel_test 
  USING bm25 (id, content) 
  WITH (key_field = 'id', mutable_segment_rows = 10);
-- Insert data in multiple separate statements (each creates a new segment)
INSERT INTO verify_parallel_test (content) SELECT 'batch1 ' || i FROM generate_series(1, 50) i;
INSERT INTO verify_parallel_test (content) SELECT 'batch2 ' || i FROM generate_series(1, 50) i;
INSERT INTO verify_parallel_test (content) SELECT 'batch3 ' || i FROM generate_series(1, 50) i;
INSERT INTO verify_parallel_test (content) SELECT 'batch4 ' || i FROM generate_series(1, 50) i;
-- Get the segment count - should have multiple segments now (typically 4-8)
SELECT COUNT(*) >= 2 as has_multiple_segments FROM paradedb.index_info('verify_parallel_idx');
 has_multiple_segments 
-----------------------
 t
(1 row)

-- Test verifying with segment_ids parameter (verify only segments 0 and 1)
-- The segment_metadata details should show "2 of N" for filtering
SELECT check_name, passed, details LIKE '%2 of%' as shows_partial_segments
FROM paradedb.verify_bm25_index('verify_parallel_idx', heapallindexed := true, segment_ids := ARRAY[0, 1])
WHERE check_name LIKE '%segment_metadata%';
                 check_name                  | passed | shows_partial_segments 
---------------------------------------------+--------+------------------------
 verify_parallel_idx: segment_metadata_valid | t      | t
(1 row)

-- Test with empty segment_ids array (should check 0 segments)
SELECT check_name, passed, details LIKE '%0 of%' as verifies_none
FROM paradedb.verify_bm25_index('verify_parallel_idx', segment_ids := ARRAY[]::int[])
WHERE check_name LIKE '%segment_metadata%';
                 check_name                  | passed | verifies_none 
---------------------------------------------+--------+---------------
 verify_parallel_idx: segment_metadata_valid | t      | t
(1 row)

-- Test with NULL segment_ids (default behavior - checks all segments, no "of" in details)
SELECT check_name, passed, details NOT LIKE '% of %' as no_partial_indicator
FROM paradedb.verify_bm25_index('verify_parallel_idx', segment_ids := NULL)
WHERE check_name LIKE '%segment_metadata%';
                 check_name                  | passed | no_partial_indicator 
---------------------------------------------+--------+----------------------
 verify_parallel_idx: segment_metadata_valid | t      | t
(1 row)

-- Test verifying a non-existent segment (should show 0 of N segments validated)
SELECT check_name, details LIKE '%0 of%' as shows_zero_of_total
FROM paradedb.verify_bm25_index('verify_parallel_idx', segment_ids := ARRAY[999])
WHERE check_name LIKE '%segment_metadata%';
                 check_name                  | shows_zero_of_total 
---------------------------------------------+---------------------
 verify_parallel_idx: segment_metadata_valid | t
(1 row)

-- Test 10: Test bm25_index_segments function for listing segments
-- This function helps with automated multi-client verification
SELECT COUNT(*) >= 2 as has_segments FROM paradedb.bm25_index_segments('verify_parallel_idx');
 has_segments 
--------------
 t
(1 row)

-- Verify segment_idx values are sequential starting from 0
SELECT bool_and(segment_idx >= 0) as valid_indices,
       COUNT(DISTINCT segment_idx) = COUNT(*) as unique_indices
FROM paradedb.bm25_index_segments('verify_parallel_idx');
 valid_indices | unique_indices 
---------------+----------------
 t             | t
(1 row)

-- Example of using bm25_index_segments to automate parallel verification
-- Verify only even-indexed segments
SELECT check_name, passed, details LIKE '%of%' as is_partial
FROM paradedb.verify_bm25_index('verify_parallel_idx',
    heapallindexed := true,
    segment_ids := (SELECT array_agg(segment_idx) FROM paradedb.bm25_index_segments('verify_parallel_idx') WHERE segment_idx % 2 = 0))
WHERE check_name LIKE '%segment_metadata%';
                 check_name                  | passed | is_partial 
---------------------------------------------+--------+------------
 verify_parallel_idx: segment_metadata_valid | t      | t
(1 row)

DROP TABLE verify_parallel_test CASCADE;
