-- Test pdb.verify_index and related functions
-- This tests the amcheck-style index verification for BM25 indexes
-- Setup: Create the extension first
CREATE EXTENSION IF NOT EXISTS pg_search;
-- Setup: Create a test table and index
DROP TABLE IF EXISTS verify_test CASCADE;
CREATE TABLE verify_test (
    id SERIAL PRIMARY KEY,
    content TEXT,
    category TEXT,
    score INT
);
CREATE INDEX verify_test_idx ON verify_test USING bm25 (id, content, category, score) WITH (key_field = 'id');
-- Insert some test data
INSERT INTO verify_test (content, category, score) VALUES
    ('hello world', 'greeting', 10),
    ('goodbye world', 'farewell', 20),
    ('search engine', 'technology', 30),
    ('full text search', 'technology', 40),
    ('paradedb postgres', 'database', 50);
-- Test 1: Basic verification without heapallindexed option
-- Should return schema_valid, index_readable, checksums_valid, segment_metadata_valid
SELECT check_name, passed FROM pdb.verify_index('verify_test_idx') ORDER BY check_name;
               check_name                | passed 
-----------------------------------------+--------
 verify_test_idx: checksums_valid        | t
 verify_test_idx: index_readable         | t
 verify_test_idx: schema_valid           | t
 verify_test_idx: segment_metadata_valid | t
(4 rows)

-- Test 2: Verification with heapallindexed option
-- Should also check heap references
SELECT check_name, passed FROM pdb.verify_index('verify_test_idx', heapallindexed := true) ORDER BY check_name;
               check_name                | passed 
-----------------------------------------+--------
 verify_test_idx: checksums_valid        | t
 verify_test_idx: ctid_field_valid       | t
 verify_test_idx: heap_references_valid  | t
 verify_test_idx: index_readable         | t
 verify_test_idx: schema_valid           | t
 verify_test_idx: segment_metadata_valid | t
(6 rows)

-- Test 3: Verify after more data is added
INSERT INTO verify_test (content, category, score)
SELECT 
    'test content ' || i,
    CASE WHEN i % 2 = 0 THEN 'even' ELSE 'odd' END,
    i
FROM generate_series(1, 100) i;
-- Verify the index is still valid after inserts
SELECT check_name, passed FROM pdb.verify_index('verify_test_idx') ORDER BY check_name;
               check_name                | passed 
-----------------------------------------+--------
 verify_test_idx: checksums_valid        | t
 verify_test_idx: index_readable         | t
 verify_test_idx: schema_valid           | t
 verify_test_idx: segment_metadata_valid | t
(4 rows)

-- Test 4: Verify with heapallindexed after more data
SELECT check_name, passed FROM pdb.verify_index('verify_test_idx', heapallindexed := true) ORDER BY check_name;
               check_name                | passed 
-----------------------------------------+--------
 verify_test_idx: checksums_valid        | t
 verify_test_idx: ctid_field_valid       | t
 verify_test_idx: heap_references_valid  | t
 verify_test_idx: index_readable         | t
 verify_test_idx: schema_valid           | t
 verify_test_idx: segment_metadata_valid | t
(6 rows)

-- Test 5: Verify after some deletes
DELETE FROM verify_test WHERE id <= 3;
-- Wait for any background processes to settle
SELECT pg_sleep(0.1);
 pg_sleep 
----------
 
(1 row)

-- Run vacuum to clean up
VACUUM verify_test;
-- Verify index still valid after deletes and vacuum
SELECT check_name, passed FROM pdb.verify_index('verify_test_idx') ORDER BY check_name;
               check_name                | passed 
-----------------------------------------+--------
 verify_test_idx: checksums_valid        | t
 verify_test_idx: index_readable         | t
 verify_test_idx: schema_valid           | t
 verify_test_idx: segment_metadata_valid | t
(4 rows)

-- Test 6: Verify with heapallindexed after deletes
SELECT check_name, passed FROM pdb.verify_index('verify_test_idx', heapallindexed := true) ORDER BY check_name;
               check_name                | passed 
-----------------------------------------+--------
 verify_test_idx: checksums_valid        | t
 verify_test_idx: ctid_field_valid       | t
 verify_test_idx: heap_references_valid  | t
 verify_test_idx: index_readable         | t
 verify_test_idx: schema_valid           | t
 verify_test_idx: segment_metadata_valid | t
(6 rows)

-- Test 7: Verify that the index can still be used for searches after verification
EXPLAIN (COSTS OFF, VERBOSE, TIMING OFF)
SELECT id, content FROM verify_test WHERE content @@@ 'test' LIMIT 5;
                                                                      QUERY PLAN                                                                       
-------------------------------------------------------------------------------------------------------------------------------------------------------
 Limit
   Output: id, content
   ->  Custom Scan (ParadeDB Scan) on public.verify_test
         Output: id, content
         Table: verify_test
         Index: verify_test_idx
         Exec Method: TopNScanExecState
         Scores: false
            TopN Limit: 5
         Tantivy Query: {"with_index":{"query":{"parse_with_field":{"field":"content","query_string":"test","lenient":null,"conjunction_mode":null}}}}
(10 rows)

SELECT id, content FROM verify_test WHERE content @@@ 'test' ORDER BY id LIMIT 5;
 id |    content     
----+----------------
  6 | test content 1
  7 | test content 2
  8 | test content 3
  9 | test content 4
 10 | test content 5
(5 rows)

-- Cleanup
DROP TABLE verify_test CASCADE;
-- Test 8: Test with sampling (for large indexes)
-- Create a larger table to test sampling
DROP TABLE IF EXISTS verify_sampling_test CASCADE;
CREATE TABLE verify_sampling_test (id SERIAL PRIMARY KEY, content TEXT);
CREATE INDEX verify_sampling_idx ON verify_sampling_test USING bm25 (id, content) WITH (key_field = 'id');
INSERT INTO verify_sampling_test (content)
SELECT 'test content ' || i FROM generate_series(1, 1000) i;
-- Test sampling at 50% - should check approximately half the documents
SELECT check_name, passed, 
       details LIKE '%sampled%' as is_sampled
FROM pdb.verify_index('verify_sampling_idx', heapallindexed := true, sample_rate := 0.5) 
WHERE check_name LIKE '%heap_references%';
                 check_name                 | passed | is_sampled 
--------------------------------------------+--------+------------
 verify_sampling_idx: heap_references_valid | t      | t
(1 row)

DROP TABLE verify_sampling_test CASCADE;
-- Test 9: Test with segment_ids for manual parallelization
-- Create a table and force multiple segments by doing separate inserts (each is its own transaction)
DROP TABLE IF EXISTS verify_parallel_test CASCADE;
CREATE TABLE verify_parallel_test (id SERIAL PRIMARY KEY, content TEXT);
-- Create index with low mutable_segment_rows to ensure segments are created
CREATE INDEX verify_parallel_idx ON verify_parallel_test 
  USING bm25 (id, content) 
  WITH (key_field = 'id', mutable_segment_rows = 10);
-- Insert data in multiple separate statements (each creates a new segment)
INSERT INTO verify_parallel_test (content) SELECT 'batch1 ' || i FROM generate_series(1, 50) i;
INSERT INTO verify_parallel_test (content) SELECT 'batch2 ' || i FROM generate_series(1, 50) i;
INSERT INTO verify_parallel_test (content) SELECT 'batch3 ' || i FROM generate_series(1, 50) i;
INSERT INTO verify_parallel_test (content) SELECT 'batch4 ' || i FROM generate_series(1, 50) i;
-- Get the segment count - should have multiple segments now (typically 4-8)
SELECT COUNT(*) >= 2 as has_multiple_segments FROM pdb.index_segments('verify_parallel_idx');
 has_multiple_segments 
-----------------------
 t
(1 row)

-- Test verifying with segment_ids parameter (verify only segments 0 and 1)
-- The segment_metadata details should show "2 of N" for filtering
SELECT check_name, passed, details LIKE '%2 of%' as shows_partial_segments
FROM pdb.verify_index('verify_parallel_idx', heapallindexed := true, segment_ids := ARRAY[0, 1])
WHERE check_name LIKE '%segment_metadata%';
                 check_name                  | passed | shows_partial_segments 
---------------------------------------------+--------+------------------------
 verify_parallel_idx: segment_metadata_valid | t      | t
(1 row)

-- Test with empty segment_ids array (should check 0 segments)
SELECT check_name, passed, details LIKE '%0 of%' as verifies_none
FROM pdb.verify_index('verify_parallel_idx', segment_ids := ARRAY[]::int[])
WHERE check_name LIKE '%segment_metadata%';
                 check_name                  | passed | verifies_none 
---------------------------------------------+--------+---------------
 verify_parallel_idx: segment_metadata_valid | t      | t
(1 row)

-- Test with NULL segment_ids (default behavior - checks all segments, no "of" in details)
SELECT check_name, passed, details NOT LIKE '% of %' as no_partial_indicator
FROM pdb.verify_index('verify_parallel_idx', segment_ids := NULL)
WHERE check_name LIKE '%segment_metadata%';
                 check_name                  | passed | no_partial_indicator 
---------------------------------------------+--------+----------------------
 verify_parallel_idx: segment_metadata_valid | t      | t
(1 row)

-- Test verifying a non-existent segment (should show 0 of N segments validated)
SELECT check_name, details LIKE '%0 of%' as shows_zero_of_total
FROM pdb.verify_index('verify_parallel_idx', segment_ids := ARRAY[999])
WHERE check_name LIKE '%segment_metadata%';
                 check_name                  | shows_zero_of_total 
---------------------------------------------+---------------------
 verify_parallel_idx: segment_metadata_valid | t
(1 row)

-- Test 10: Test pdb.index_segments function for listing segments
-- This function helps with automated multi-client verification
SELECT COUNT(*) >= 2 as has_segments FROM pdb.index_segments('verify_parallel_idx');
 has_segments 
--------------
 t
(1 row)

-- Verify segment_idx values are sequential starting from 0
SELECT bool_and(segment_idx >= 0) as valid_indices,
       COUNT(DISTINCT segment_idx) = COUNT(*) as unique_indices
FROM pdb.index_segments('verify_parallel_idx');
 valid_indices | unique_indices 
---------------+----------------
 t             | t
(1 row)

-- Example of using pdb.index_segments to automate parallel verification
-- Verify only even-indexed segments
SELECT check_name, passed, details LIKE '%of%' as is_partial
FROM pdb.verify_index('verify_parallel_idx',
    heapallindexed := true,
    segment_ids := (SELECT array_agg(segment_idx) FROM pdb.index_segments('verify_parallel_idx') WHERE segment_idx % 2 = 0))
WHERE check_name LIKE '%segment_metadata%';
                 check_name                  | passed | is_partial 
---------------------------------------------+--------+------------
 verify_parallel_idx: segment_metadata_valid | t      | t
(1 row)

DROP TABLE verify_parallel_test CASCADE;
-- Test 11: Test pdb.indexes() function for listing all BM25 indexes
DROP TABLE IF EXISTS test_all_idx1, test_all_idx2;
CREATE TABLE test_all_idx1 (id serial, content text);
CREATE INDEX test_all_idx1_idx ON test_all_idx1 USING bm25 (id, content) WITH (key_field = 'id');
INSERT INTO test_all_idx1 (content) SELECT 'test' || i FROM generate_series(1,10) i;
CREATE TABLE test_all_idx2 (id serial, title text);
CREATE INDEX test_all_idx2_idx ON test_all_idx2 USING bm25 (id, title) WITH (key_field = 'id');
INSERT INTO test_all_idx2 (title) SELECT 'doc' || i FROM generate_series(1,5) i;
-- List all BM25 indexes
SELECT schemaname, tablename, indexname, num_segments > 0 as has_segments, total_docs > 0 as has_docs
FROM pdb.indexes()
WHERE indexname LIKE 'test_all%'
ORDER BY indexname;
 schemaname |   tablename   |     indexname     | has_segments | has_docs 
------------+---------------+-------------------+--------------+----------
 public     | test_all_idx1 | test_all_idx1_idx | t            | t
 public     | test_all_idx2 | test_all_idx2_idx | t            | t
(2 rows)

-- Test 12: Test pdb.verify_all_indexes() function
SELECT schemaname, indexname, check_name, passed
FROM pdb.verify_all_indexes(index_pattern := 'test_all%')
ORDER BY indexname, check_name;
 schemaname |     indexname     |                check_name                 | passed 
------------+-------------------+-------------------------------------------+--------
 public     | test_all_idx1_idx | test_all_idx1_idx: checksums_valid        | t
 public     | test_all_idx1_idx | test_all_idx1_idx: index_readable         | t
 public     | test_all_idx1_idx | test_all_idx1_idx: schema_valid           | t
 public     | test_all_idx1_idx | test_all_idx1_idx: segment_metadata_valid | t
 public     | test_all_idx2_idx | test_all_idx2_idx: checksums_valid        | t
 public     | test_all_idx2_idx | test_all_idx2_idx: index_readable         | t
 public     | test_all_idx2_idx | test_all_idx2_idx: schema_valid           | t
 public     | test_all_idx2_idx | test_all_idx2_idx: segment_metadata_valid | t
(8 rows)

-- Test 13: Test on_error_stop parameter (should complete all checks since no errors)
SELECT check_name, passed
FROM pdb.verify_index('test_all_idx1_idx', on_error_stop := true);
                check_name                 | passed 
-------------------------------------------+--------
 test_all_idx1_idx: schema_valid           | t
 test_all_idx1_idx: index_readable         | t
 test_all_idx1_idx: checksums_valid        | t
 test_all_idx1_idx: segment_metadata_valid | t
(4 rows)

DROP TABLE test_all_idx1, test_all_idx2;
-- =============================================================================
-- CORRUPTION DETECTION TESTS
-- These tests verify that the verification functions correctly detect corruption
-- =============================================================================
-- Test 14: Heap reference corruption detection
-- Disable triggers and delete rows to create "dangling" index entries
DROP TABLE IF EXISTS corruption_test CASCADE;
CREATE TABLE corruption_test (id serial PRIMARY KEY, content text);
CREATE INDEX corruption_idx ON corruption_test USING bm25 (id, content) WITH (key_field = 'id');
INSERT INTO corruption_test (content) SELECT 'document ' || i FROM generate_series(1, 50) i;
-- Verify healthy state first
SELECT 'Before corruption' as state, check_name, passed
FROM pdb.verify_index('corruption_idx', heapallindexed := true)
WHERE check_name LIKE '%heap%' OR check_name LIKE '%ctid_field%';
       state       |              check_name               | passed 
-------------------+---------------------------------------+--------
 Before corruption | corruption_idx: ctid_field_valid      | t
 Before corruption | corruption_idx: heap_references_valid | t
(2 rows)

-- Induce corruption: delete rows without updating the index
ALTER TABLE corruption_test DISABLE TRIGGER ALL;
DELETE FROM corruption_test WHERE id <= 5;
ALTER TABLE corruption_test ENABLE TRIGGER ALL;
-- Verify corruption is detected
SELECT 'After corruption' as state, check_name, passed, 
       details LIKE '%5 of 50%' as detected_5_missing
FROM pdb.verify_index('corruption_idx', heapallindexed := true)
WHERE check_name LIKE '%heap%' OR check_name LIKE '%ctid_field%';
      state       |              check_name               | passed | detected_5_missing 
------------------+---------------------------------------+--------+--------------------
 After corruption | corruption_idx: ctid_field_valid      | t      | f
 After corruption | corruption_idx: heap_references_valid | f      | t
(2 rows)

-- Test 15: Sampling with corruption
-- With 100% sampling, corruption should always be detected
SELECT '100% sample' as test, passed, details LIKE '%missing%' as found_missing
FROM pdb.verify_index('corruption_idx', heapallindexed := true, sample_rate := 1.0)
WHERE check_name LIKE '%heap%';
    test     | passed | found_missing 
-------------+--------+---------------
 100% sample | f      | t
(1 row)

-- Test 16: on_error_stop with corruption
-- Should return results up to and including the first failure
SELECT check_name, passed
FROM pdb.verify_index('corruption_idx', heapallindexed := true, on_error_stop := true);
               check_name               | passed 
----------------------------------------+--------
 corruption_idx: schema_valid           | t
 corruption_idx: index_readable         | t
 corruption_idx: checksums_valid        | t
 corruption_idx: segment_metadata_valid | t
 corruption_idx: ctid_field_valid       | t
 corruption_idx: heap_references_valid  | f
(6 rows)

DROP TABLE corruption_test CASCADE;
-- Test 17: pdb.verify_all_indexes with mixed healthy and corrupted indexes
DROP TABLE IF EXISTS healthy_table, corrupted_table CASCADE;
-- Create healthy table and index
CREATE TABLE healthy_table (id serial PRIMARY KEY, content text);
CREATE INDEX healthy_idx ON healthy_table USING bm25 (id, content) WITH (key_field = 'id');
INSERT INTO healthy_table (content) SELECT 'healthy ' || i FROM generate_series(1, 20) i;
-- Create corrupted table and index
CREATE TABLE corrupted_table (id serial PRIMARY KEY, content text);
CREATE INDEX corrupted_idx ON corrupted_table USING bm25 (id, content) WITH (key_field = 'id');
INSERT INTO corrupted_table (content) SELECT 'corrupted ' || i FROM generate_series(1, 20) i;
-- Corrupt the second index
ALTER TABLE corrupted_table DISABLE TRIGGER ALL;
DELETE FROM corrupted_table WHERE id <= 3;
ALTER TABLE corrupted_table ENABLE TRIGGER ALL;
-- verify_all should show healthy passing and corrupted failing
SELECT indexname, check_name, passed
FROM pdb.verify_all_indexes(index_pattern := '%_idx', heapallindexed := true)
WHERE check_name LIKE '%heap%' OR check_name LIKE '%ctid_field%'
ORDER BY indexname, check_name;
   indexname   |              check_name              | passed 
---------------+--------------------------------------+--------
 corrupted_idx | corrupted_idx: ctid_field_valid      | t
 corrupted_idx | corrupted_idx: heap_references_valid | f
 healthy_idx   | healthy_idx: ctid_field_valid        | t
 healthy_idx   | healthy_idx: heap_references_valid   | t
(4 rows)

-- Test 18: verify_all with on_error_stop should stop at first corrupted index
SELECT indexname, check_name, passed
FROM pdb.verify_all_indexes(index_pattern := '%_idx', heapallindexed := true, on_error_stop := true)
WHERE check_name LIKE '%heap%' OR check_name LIKE '%ctid_field%'
ORDER BY indexname, check_name;
   indexname   |              check_name              | passed 
---------------+--------------------------------------+--------
 corrupted_idx | corrupted_idx: ctid_field_valid      | t
 corrupted_idx | corrupted_idx: heap_references_valid | f
(2 rows)

DROP TABLE healthy_table, corrupted_table CASCADE;
