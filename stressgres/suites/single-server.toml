[[server]]
name = "Primary"
[server.style.Automatic]

[server.setup]
sql = """
DROP EXTENSION IF EXISTS pg_search CASCADE;
DROP TABLE IF EXISTS test CASCADE;
CREATE EXTENSION pg_search;
CREATE TABLE test (
    id SERIAL8 NOT NULL PRIMARY KEY,
    message TEXT,
    category TEXT DEFAULT 'common'
);

INSERT INTO test (message) VALUES ('beer wine cheese a');
INSERT INTO test (message) VALUES ('beer wine a');
INSERT INTO test (message) VALUES ('beer cheese a');
INSERT INTO test (message) VALUES ('beer a');
INSERT INTO test (message) VALUES ('wine cheese a');
INSERT INTO test (message) VALUES ('wine a');
INSERT INTO test (message) VALUES ('cheese a');
INSERT INTO test (message) VALUES ('beer wine cheese a');
INSERT INTO test (message) VALUES ('beer wine a');
INSERT INTO test (message) VALUES ('beer cheese a');
INSERT INTO test (message) VALUES ('beer a');
INSERT INTO test (message) VALUES ('wine cheese a');
INSERT INTO test (message) VALUES ('wine a');
INSERT INTO test (message) VALUES ('cheese a');

CREATE INDEX idxtest ON test USING bm25(
    id,
    message,
    (category::pdb.literal)
) WITH (key_field = 'id');

CREATE OR REPLACE FUNCTION assert(a bigint, b bigint) RETURNS bool LANGUAGE plpgsql AS $$
DECLARE
    current_txid bigint;
BEGIN
    -- Get the current transaction ID
    current_txid := txid_current();

    -- Check if the values are not equal
    IF a <> b THEN
        RAISE EXCEPTION 'Assertion failed: % <> %. Transaction ID: %', a, b, current_txid;
    END IF;

    RETURN true;
END;
$$;

CREATE OR REPLACE FUNCTION assert_plan_contains(
    p_query text,
    p_expected_text text
) RETURNS boolean AS $$
DECLARE
    plan_line text;
BEGIN
    -- Loop through each line of the EXPLAIN output
    FOR plan_line IN EXECUTE 'EXPLAIN ' || p_query LOOP
        -- Check if the current line contains the expected text
        IF plan_line ILIKE '%' || p_expected_text || '%' THEN
            RETURN true;
        END IF;
    END LOOP;

    RAISE EXCEPTION 'Plan assertion failed: Expected text "%" not found in plan for query: %', p_expected_text, p_query;
END;
$$ LANGUAGE plpgsql;


ALTER SYSTEM SET autovacuum_naptime = '1s';
SELECT pg_reload_conf();
"""

[server.teardown]
sql = """
DROP TABLE test CASCADE;
DROP EXTENSION pg_search CASCADE;
"""
[server.monitor]
refresh_ms = 10
title = "Monitor Index Size"
log_columns = ["block_count", "segment_count"]

# Combined query returning both columns
sql = """
SELECT
    pg_relation_size('idxtest') / current_setting('block_size')::int AS block_count,
    (
      SELECT COUNT(*)::bigint
      FROM paradedb.index_info('idxtest')
    ) AS segment_count
"""

[[jobs]]
refresh_ms = 100
title = "Index Scan"
log_tps = true
on_connect = """
SET paradedb.enable_custom_scan = off;
SELECT assert_plan_contains(
    $q$ SELECT count(*) FROM test where message ||| 'cheese' $q$,
    'Index Only Scan'
);
"""
sql = """
SELECT assert(count(*)::bigint, 8::bigint), count(*) FROM test where message ||| 'cheese';
"""

[[jobs]]
refresh_ms = 5
title = "Normal Scan"
log_tps = true
on_connect = """
SELECT assert_plan_contains(
    $q$ SELECT count(*) FROM test where message ||| 'wine' $q$,
    'NormalScanExecState'
);
"""
sql = """
SELECT assert(count(*)::bigint, 8::bigint), count(*) FROM test where message ||| 'wine';
"""

[[jobs]]
refresh_ms = 5
title = "Mixed Fast Field Scan"
log_tps = true
on_connect = """
SET paradedb.enable_mixed_fast_field_exec = on;
SELECT assert_plan_contains(
    $q$ SELECT id, category FROM test WHERE message ||| 'beer' $q$,
    'MixedFastFieldExecState'
);
"""
sql = """
SELECT assert(count(*)::bigint, 8::bigint), count(*) FROM (SELECT id, category FROM test WHERE message ||| 'beer') sub;
"""

[[jobs]]
refresh_ms = 5
title = "Aggregate Custom Scan"
log_tps = true
on_connect = """
SET paradedb.enable_aggregate_custom_scan = on;
SELECT assert_plan_contains(
    $q$ SELECT pdb.agg('{"value_count": {"field": "id"}}'::jsonb) FROM test WHERE message ||| 'beer' $q$,
    'ParadeDB Aggregate Scan'
);
"""
sql = """
SELECT assert((pdb.agg('{"value_count": {"field": "id"}}'::jsonb)->>'value')::numeric::bigint, 8::bigint) FROM test WHERE message ||| 'beer';
"""

[[jobs]]
refresh_ms = 25
title = "Update random values"
log_tps = true
sql = """
UPDATE test
SET message = substring(message FROM 1 FOR length(message)-1)
              || chr((trunc(random() * 26) + 65)::int)
WHERE id < 10;
"""

[[jobs]]
refresh_ms = 10
title = "Insert value"
log_tps = true
sql = """
INSERT INTO test (message) VALUES ('test');
"""

[[jobs]]
refresh_ms = 10
title = "Insert value"
log_tps = true
sql = """
INSERT INTO test (message) VALUES ('test');
"""

[[jobs]]
refresh_ms = 10
title = "Delete values"
sql = """
DELETE FROM test WHERE id > 14;
"""

[[jobs]]
refresh_ms = 3000
title = "Vacuum"
log_tps = true
sql = """
SET vacuum_freeze_min_age = 0;
VACUUM test;
"""
